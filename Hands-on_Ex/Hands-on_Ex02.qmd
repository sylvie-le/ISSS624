---
title: "Global and Local Measures of Spatial Autocorrelation"
editor: visual
---

## Overview

This exercise provide the steps of computing the Global and Local Measures of Spatial Autocorrelation using `spdep` package.

## Getting Started

### The analytical question

We may ask, is a character or attribute evenly distributed across areas or regions? If they are not, then is there a sign of spatial clustering, and if yes, where are the clusters? Those questions can be applied to a wide range of domains: development planning of city councils, shop outlet location setting of a fashion chain, examining the habitat clusters of a certain plant species, etc.

In this case study, we are interested to examine the spatial pattern of a selected development indicator (i.e. GDP per capita) of [Hunan Provice, People Republic of China](https://en.wikipedia.org/wiki/Hunan).

### The study area and data

Two data sets will be used in this hands-on exercise, they are:

-   Hunan province administrative boundary layer at county level. This is a geospatial data set in ESRI shapefile format.

-   Hunan_2012.csv: This csv file contains selected Hunan\'s local development indicators in 2012.

We will reuse the data that we exercised in the [In-class Exercise 2 - Spatial Weights and Application](https://isss624-1stcommit.netlify.app/in-class_ex/in-class_ex1/in-class_ex1) segment of this website.

### Setting the analytical tools

First, we load the necessary R packages.

```{r}
pacman::p_load(sf, spdep, tmap, tidyverse)
```

## Getting the Data into the R Environment

### Import shapefile into R environment

We import the Hunan shapefile into R using the `sf` package.

```{r}
hunan <- st_read(dsn = "~/sylvie-le/ISSS624/In-class_Ex/In-class_Ex1/dataC/geospatial", layer = "Hunan")
```

### Import CSV file into R environment

```{r}
hunan2012 <- read_csv("~/sylvie-le/ISSS624/In-class_Ex/In-class_Ex1/dataC/aspatial/Hunan_2012.csv", show_col_types = FALSE)
```

### Perform relational join

```{r}
hunan <- left_join(hunan, hunan2012)
```

### Visualize regional development indicator

Now we will prepare a choropleth map showing the distribution of GDPPC 2012 in Hunan.

```{r}
equal <- tm_shape(hunan) +
  tm_fill("GDPPC",
          n = 5,
          style = "equal") +
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "Equal interval classification",
            main.title.size = 1,
            main.title.position = "center",
            legend.text.size = 0.45)

quantile <- tm_shape(hunan) +
  tm_fill("GDPPC",
          n = 5,
          style = "quantile") +
  tm_borders(alpha = 0.5) +
  tm_layout(main.title = "Equal quantile classification",
            main.title.size = 1,
            main.title.position = "center",
            legend.text.size = 0.45)

tmap_arrange(equal, quantile, asp = 1, ncol = 2)
```

## Global Spatial Autocorrelation

### Computing contiguity spatial weight

Before we can compute the global spatial autocorrelation statistics, we need to construct a spatial weights of the study area. The spatial weights is used to define the neighbourhood relationships between the geographical units (i.e. county) in the study area.

```{r}
wm_q <- poly2nb(hunan, queen = TRUE)
summary(wm_q)
```

### Row-standardized weights matrix

```{r}
rswm_q <- nb2listw(wm_q, style = "W", zero.policy = TRUE)
rswm_q
```

Refer [HERE](https://r4gdsa.netlify.app/chap04.html#row-standardised-weights-matrix) for an explanation of the code and [HERE](https://www.rdocumentation.org/packages/spdep/versions/1.2-7/topics/nb2listw) for documentation on `nb2listw()`.

### Global Spatial Autocorrelation: Moran's I

#### Moran's Test

We will perform Moran test using `moran.test()` from `spdep`.

```{r}
moran.test(hunan$GDPPC,
           listw = rswm_q,
           zero.policy = TRUE,
           na.action = na.omit)
```

Moran I statistic is approximately 0.3, indicating clustered data. The neighbor observations tend to be similar.

#### Computing Monte Carlo Moran's I

We will conduct a permutation test for Moran's I statistic by generating 1,000 simulations.

```{r}
set.seed(1234) #to prevent the result from changing due to random calculation
bperm = moran.mc(hunan$GDPPC,
                 listw = rswm_q,
                 nsim = 999,
                 zero.policy = TRUE,
                 na.action = na.omit)
bperm
```

The result of 1,000 simulation is similar to the Moran's I test.

#### Visulize Monte Carlo Moran's I

```{r}
mean(bperm$res[1:999])
```

```{r}
var(bperm$res[1:999])
```

```{r}
summary(bperm$res[1:999])
```

```{r}
hist(bperm$res,
     freq = TRUE,
     breaks = 20,
     xlab = "Simulated Moran's I")
abline(v = 0, col = "red")
```

The distribution of the simulation result are skewed to the right. Most results are less than 0.

We can use ggplot2 to visualize Monte Carlo Moran's I.

```{r}
library(ggplot2)
df <- data.frame(bperm$res)
ggplot(df, aes(bperm$res)) +
  geom_histogram(fill = "gray", color = "black") +
  scale_x_continuous() +
  geom_vline(aes(xintercept = 0), color = "red") +
  labs(title = "Histogram of bperm$res", x = "Simulated Moran's I", y = "Frequency")
```
