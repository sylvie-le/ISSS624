[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Map Here and There",
    "section": "",
    "text": "This is my journey of learning geospatial analytics. Follow me on this webpage for more!"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Hello, this is an introduction site. I will update content later, maybe stories of my learning journey?"
  },
  {
    "objectID": "Hands-on_Ex01.html",
    "href": "Hands-on_Ex01.html",
    "title": "Hands-on Exercise 1: Geospatial Wrangling with R",
    "section": "",
    "text": "In this hands-on exercise, I learn how to import and wrangle geospatial data using appropriate R packages."
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html",
    "title": "Hands-on Exercise 1: Geospatial Wrangling and Choropleth Mapping with R",
    "section": "",
    "text": "In this hands-on exercise, I learn how to import and wrangle geospatial data using appropriate R packages.\n\n\n\nThe code chunk below installs and loads sf and tidyverse.\nNotes: Make sure you imported the pacman package before running the code below.\n\npacman::p_load(sf, tidyverse)\n\n\n\n\nBefore importing anything, download the data zip file(s), unzip, and put them into the folder inside the directory of your page. Then create a Quarto document within that folder. The Quarto document and the data files need to be in the same folder, or you need to clarify the path to the data file while running the code below.\n\n\nNotes: You need to save your working R document as an qmd file before you can run the code below.\n\nmpsz <- st_read(dsn = \"data/geospatial\", layer = \"MP14_SUBZONE_WEB_PL\")\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/Hands-on_Ex01/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\n\n\n\n\nRun the code chunk below.\n\ncyclingpath <- st_read(dsn = \"data/geospatial\", layer = \"CyclingPath\")\n\nReading layer `CyclingPath' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/Hands-on_Ex01/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 1625 features and 2 fields\nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: 12711.19 ymin: 28711.33 xmax: 42626.09 ymax: 48948.15\nProjected CRS: SVY21\n\n\n\n\n\nRun the code chunk below.\n\npreschool <- st_read(\"data/geospatial/pre-schools-location-kml.kml\")\n\nReading layer `PRESCHOOLS_LOCATION' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/Hands-on_Ex01/data/geospatial/pre-schools-location-kml.kml' \n  using driver `KML'\nSimple feature collection with 1359 features and 2 fields\nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6824 ymin: 1.248403 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\n\n\n\n\n\n\n\n\nThe type of geometry is multipolygon.\n\nst_geometry(mpsz)\n\nGeometry set for 323 features \nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\nFirst 5 geometries:\n\n\nMULTIPOLYGON (((31495.56 30140.01, 31980.96 296...\n\n\nMULTIPOLYGON (((29092.28 30021.89, 29119.64 300...\n\n\nMULTIPOLYGON (((29932.33 29879.12, 29947.32 298...\n\n\nMULTIPOLYGON (((27131.28 30059.73, 27088.33 297...\n\n\nMULTIPOLYGON (((26451.03 30396.46, 26440.47 303...\n\n\n\n\n\nGlimpse display a sneak peek into the data type and values of the variables. Notice that X_ADDR and Y_ADDR are double type. There are other types like character, integer, and date.\n\nglimpse(mpsz)\n\nRows: 323\nColumns: 16\n$ OBJECTID   <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, …\n$ SUBZONE_NO <int> 1, 1, 3, 8, 3, 7, 9, 2, 13, 7, 12, 6, 1, 5, 1, 1, 3, 2, 2, …\n$ SUBZONE_N  <chr> \"MARINA SOUTH\", \"PEARL'S HILL\", \"BOAT QUAY\", \"HENDERSON HIL…\n$ SUBZONE_C  <chr> \"MSSZ01\", \"OTSZ01\", \"SRSZ03\", \"BMSZ08\", \"BMSZ03\", \"BMSZ07\",…\n$ CA_IND     <chr> \"Y\", \"Y\", \"Y\", \"N\", \"N\", \"N\", \"N\", \"Y\", \"N\", \"N\", \"N\", \"N\",…\n$ PLN_AREA_N <chr> \"MARINA SOUTH\", \"OUTRAM\", \"SINGAPORE RIVER\", \"BUKIT MERAH\",…\n$ PLN_AREA_C <chr> \"MS\", \"OT\", \"SR\", \"BM\", \"BM\", \"BM\", \"BM\", \"SR\", \"QT\", \"QT\",…\n$ REGION_N   <chr> \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENT…\n$ REGION_C   <chr> \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\",…\n$ INC_CRC    <chr> \"5ED7EB253F99252E\", \"8C7149B9EB32EEFC\", \"C35FEFF02B13E0E5\",…\n$ FMEL_UPD_D <date> 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05…\n$ X_ADDR     <dbl> 31595.84, 28679.06, 29654.96, 26782.83, 26201.96, 25358.82,…\n$ Y_ADDR     <dbl> 29220.19, 29782.05, 29974.66, 29933.77, 30005.70, 29991.38,…\n$ SHAPE_Leng <dbl> 5267.381, 3506.107, 1740.926, 3313.625, 2825.594, 4428.913,…\n$ SHAPE_Area <dbl> 1630379.27, 559816.25, 160807.50, 595428.89, 387429.44, 103…\n$ geometry   <MULTIPOLYGON [m]> MULTIPOLYGON (((31495.56 30..., MULTIPOLYGON (…\n\n\n\n\n\nUse n = … to select the number of records to display. Head gives a look at the first few rows of the data frame.\n\nhead(mpsz, n = 5)\n\nSimple feature collection with 5 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 25867.68 ymin: 28369.47 xmax: 32362.39 ymax: 30435.54\nProjected CRS: SVY21\n  OBJECTID SUBZONE_NO      SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N\n1        1          1   MARINA SOUTH    MSSZ01      Y    MARINA SOUTH\n2        2          1   PEARL'S HILL    OTSZ01      Y          OUTRAM\n3        3          3      BOAT QUAY    SRSZ03      Y SINGAPORE RIVER\n4        4          8 HENDERSON HILL    BMSZ08      N     BUKIT MERAH\n5        5          3        REDHILL    BMSZ03      N     BUKIT MERAH\n  PLN_AREA_C       REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1         MS CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84\n2         OT CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06\n3         SR CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96\n4         BM CENTRAL REGION       CR 3775D82C5DDBEFBD 2014-12-05 26782.83\n5         BM CENTRAL REGION       CR 85D9ABEF0A40678F 2014-12-05 26201.96\n    Y_ADDR SHAPE_Leng SHAPE_Area                       geometry\n1 29220.19   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...\n2 29782.05   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...\n3 29974.66   1740.926   160807.5 MULTIPOLYGON (((29932.33 29...\n4 29933.77   3313.625   595428.9 MULTIPOLYGON (((27131.28 30...\n5 30005.70   2825.594   387429.4 MULTIPOLYGON (((26451.03 30...\n\n\n\n\n\n\nWith geospatial data, we can use the plot() function to display them as visual elements. We can use max.plot = … to define the number of plots shown. This data set has 15 plots at the maximum but we only sketch 9 plots here, hence max.plot = 9.\n\nplot(mpsz, max.plot = 9)\n\n\n\n\nWe can choose to plot just one plot using the code chunk below. This is the plot of the sf object, which is the frame of all plots.\n\nplot(st_geometry(mpsz))\n\n\n\n\nOr we can plot and view a specific attribute.\n\nplot(mpsz[\"PLN_AREA_N\"])\n\n\n\n\n\nNotes: plot is only used for a quickly. For high cartographic quality plot, use tmap R package.\n\n\n\n\nWhen we want to project two or more geospatial data sets, it is important to ensure the data sets are projected under the same coordinate system. Projection Transformation is the method of projecting a data frame from one coordinate system to another.\n\n\nIssues to notice: missing coordination or wrongly assigned coordination due to the importing process.\nUsing the code chunk below, we can see the coordinate system of mpsz.\n\nst_crs(mpsz)\n\nCoordinate Reference System:\n  User input: SVY21 \n  wkt:\nPROJCRS[\"SVY21\",\n    BASEGEOGCRS[\"SVY21[WGS84]\",\n        DATUM[\"World Geodetic System 1984\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ID[\"EPSG\",6326]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"Degree\",0.0174532925199433]]],\n    CONVERSION[\"unnamed\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]\n\n\n\nNotice the User input says the data is projected in svy21, but the EPSG code is 9001. This is a wrong EPSG code because the EPSG code for svy21 should be 3414.\n\nWe now assign the correct EPSG code using the code below.\n\nmpsz3414 <- st_set_crs(mpsz, 3414)\n\nWarning: st_crs<- : replacing crs does not reproject data; use st_transform for\nthat\n\n\nR warns us that st_crs does not reproject data. While this is true in case we want to do projection transformation, here we simply want to fix the EPSG code. Therefore, reprojection is not necessary and we can proceed with checking the EPSG of mpsz3414, which shows the correct EPSG code.\n\nst_crs(mpsz3414)\n\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n\n\n\n\n\nNow we inspect the geometry of preschool. It is clear that preschool is projected in the WGS84 coordinate system.\n\nst_geometry(preschool)\n\nGeometry set for 1359 features \nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6824 ymin: 1.248403 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\nFirst 5 geometries:\n\n\nPOINT Z (103.7614 1.308683 0)\n\n\nPOINT Z (103.7536 1.315748 0)\n\n\nPOINT Z (103.7645 1.305078 0)\n\n\nPOINT Z (103.765 1.305239 0)\n\n\nPOINT Z (103.7597 1.315983 0)\n\n\nWe will transform the projection of preschool to svy21 using st_transform.\n\npreschool3414 <- st_transform(preschool, crs = 3414)\n\nNow we can inspect the geometry of preschool3414, which is now projected in svy21 coordinate system.\n\nst_geometry(preschool3414)\n\nGeometry set for 1359 features \nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 11203.01 ymin: 25667.6 xmax: 45404.24 ymax: 49300.88\nz_range:       zmin: 0 zmax: 0\nProjected CRS: SVY21 / Singapore TM\nFirst 5 geometries:\n\n\nPOINT Z (19997.26 32333.17 0)\n\n\nPOINT Z (19126.75 33114.35 0)\n\n\nPOINT Z (20345.12 31934.56 0)\n\n\nPOINT Z (20400.31 31952.36 0)\n\n\nPOINT Z (19810.78 33140.31 0)\n\n\n\nNotes: in Bounding box, the values are greater than 0-360 range of decimal degree commonly used by most of the geographic coordinate systems.\n\n\n\n\n\n\n\nBecause the listings dataset is in the csv format, we use the read.csv() function to import the data into an object called listings, which is a tibble data frame.\n\nlistings <- read.csv(\"data/aspatial/listings.csv\")\n\nTo inspect the data set, instead of using glimpse, now we use list because of the object type.\n\noptions(max.print = 10)\nlist(listings)\n\n[[1]]\n     id name host_id host_name neighbourhood_group neighbourhood latitude\n     longitude room_type price minimum_nights number_of_reviews last_review\n     reviews_per_month calculated_host_listings_count availability_365\n [ reached 'max' / getOption(\"max.print\") -- omitted 4252 rows ]\n\n\nWe can see that listings has 4,252 rows and 16 columns. We are going to use latitude and longitude.\n\nNote that they are in decimal degree format. As a best guess, we will assume that the data is in wgs84 Geographic Coordinate System.\n\n\n\n\nWe now convert listings into a simple feature data frame using st_as_sf().\n\nlistings_sf <- st_as_sf(listings, coords = c(\"longitude\", \"latitude\"), crs = 4326) %>%\n  st_transform(crs = 3414)\n\nNotes\n\n\ncoords argument requires you to provide the column name of the x-coordinates first then followed by the column name of the y-coordinates.\ncrs argument requires you to provide the coordinates system in epsg format. EPSG: 4326 is wgs84 Geographic Coordinate System and EPSG: 3414 is Singapore SVY21 Projected Coordinate System. You can search for other country’s epsg code by referring to epsg.io.\n%>% is used to nest st_transform() to transform the newly created simple feature data frame into svy21 projected coordinates system.\n\n\nAfter the transformation, we can examine the new object listings_sf using glimpse.\n\nglimpse(listings_sf)\n\nRows: 4,252\nColumns: 15\n$ id                             <int> 50646, 71609, 71896, 71903, 275343, 275…\n$ name                           <chr> \"Pleasant Room along Bukit Timah\", \"Ens…\n$ host_id                        <int> 227796, 367042, 367042, 367042, 1439258…\n$ host_name                      <chr> \"Sujatha\", \"Belinda\", \"Belinda\", \"Belin…\n$ neighbourhood_group            <chr> \"Central Region\", \"East Region\", \"East …\n$ neighbourhood                  <chr> \"Bukit Timah\", \"Tampines\", \"Tampines\", …\n$ room_type                      <chr> \"Private room\", \"Private room\", \"Privat…\n$ price                          <int> 80, 178, 81, 81, 52, 40, 72, 41, 49, 49…\n$ minimum_nights                 <int> 90, 90, 90, 90, 14, 14, 90, 8, 14, 14, …\n$ number_of_reviews              <int> 18, 20, 24, 48, 20, 13, 133, 105, 14, 1…\n$ last_review                    <chr> \"2014-07-08\", \"2019-12-28\", \"2014-12-10…\n$ reviews_per_month              <dbl> 0.22, 0.28, 0.33, 0.67, 0.20, 0.16, 1.2…\n$ calculated_host_listings_count <int> 1, 4, 4, 4, 50, 50, 7, 1, 50, 50, 50, 4…\n$ availability_365               <int> 365, 365, 365, 365, 353, 364, 365, 90, …\n$ geometry                       <POINT [m]> POINT (22646.02 35167.9), POINT (…\n\n\n\n\n\n\n\n\nThe scenario\nThe authority is planning to upgrade the exiting cycling path. To do so, they need to acquire 5 metres of reserved land on the both sides of the current cycling path. You are tasked to determine the extend of the land need to be acquired and their total area.\nSolution\nCompute the 5-meter buffers around cycling paths\n\nbuffer_cycling <- st_buffer(cyclingpath, dist = 5, nQuadSegs = 30)\n\nCalculate the area of the buffers as shown in the code chunk below.\n\nbuffer_cycling$AREA <- st_area(buffer_cycling)\n\nLastly, sum() of Base R will be used to derive the total land involved.\n\nsum(buffer_cycling$AREA)\n\n773143.9 [m^2]\n\n\n\n\n\nThe scenario\nA pre-school service group want to find out the numbers of pre-schools in each Planning Subzone.\nThe solution\nThe code chunk below performs two operations at one go. Firstly, identify pre-schools located inside each Planning Subzone by using st_intersects(). Next, length() of Base R is used to calculate numbers of pre-schools that fall inside each planning subzone.\n\nmpsz3414$`PreSch Count` <- lengths(st_intersects(mpsz3414, preschool3414))\n\nNow we check the new PreSch Count field.\n\nsummary(mpsz3414$`PreSch Count`)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  0.000   0.000   2.000   4.207   6.000  37.000 \n\n\nTo list the planning subzone with the most number of pre-school, the top_n() of dplyr package is used as shown in the code chunk below.\n\ntop_n(mpsz3414, 1, `PreSch Count`)\n\nSimple feature collection with 1 feature and 16 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 23449.05 ymin: 46001.23 xmax: 25594.22 ymax: 47996.47\nProjected CRS: SVY21 / Singapore TM\n     OBJECTID SUBZONE_NO SUBZONE_N SUBZONE_C CA_IND PLN_AREA_N PLN_AREA_C\n     REGION_N REGION_C INC_CRC FMEL_UPD_D X_ADDR Y_ADDR SHAPE_Leng SHAPE_Area\n     geometry PreSch Count\n [ reached 'max' / getOption(\"max.print\") -- omitted 1 rows ]\n\n\n\n\n\nFirstly, the code chunk below uses st_area() of sf package to derive the area of each planning subzone.\n\nmpsz3414$Area <- mpsz3414 %>%\n  st_area()\n\nNext, mutate() of dplyr package is used to compute the density by using the code chunk below.\n\nmpsz3414 <- mpsz3414 %>%\n  mutate(`PreSch Density` = `PreSch Count`/Area * 1000000)\n\nResults\n\nsummary(mpsz3414$`PreSch Density`)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  0.000   0.000   2.974   4.076   6.609  29.059 \n\n\n\ntop_n(mpsz3414, 1, `PreSch Density`)\n\nSimple feature collection with 1 feature and 18 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 28896.26 ymin: 28339.16 xmax: 29426.66 ymax: 28685.25\nProjected CRS: SVY21 / Singapore TM\n\n\nWarning in format.data.frame(if (omit) x[seq_len(n0), , drop = FALSE] else x, :\ncorrupt data frame: columns will be truncated or padded with NAs\n\n\n     OBJECTID SUBZONE_NO SUBZONE_N SUBZONE_C CA_IND PLN_AREA_N PLN_AREA_C\n     REGION_N REGION_C INC_CRC FMEL_UPD_D X_ADDR Y_ADDR SHAPE_Leng SHAPE_Area\n     geometry PreSch Count Area PreSch Density\n [ reached 'max' / getOption(\"max.print\") -- omitted 1 rows ]\n\n\n\n\n\n\nFirstly, we will plot a histogram to reveal the distribution of PreSch Density. Conventionally, hist() of R Graphics will be used as shown in the code chunk below.\n\nhist(mpsz3414$`PreSch Density`, main = \"Histogram of School Density\", xlab = \"School Density\")\n\n\n\n\nIn the code chunk below, appropriate ggplot2 functions will be used.\n\nggplot(data=mpsz3414, \n       aes(x= as.numeric(`PreSch Density`)))+\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  labs(title = \"Are pre-school even distributed in Singapore?\",\n       subtitle= \"There are many planning sub-zones with a single pre-school, on the other hand, \\nthere are two planning sub-zones with at least 20 pre-schools\",\n      x = \"Pre-school density (per km sq)\",\n      y = \"Frequency\")\n\n\n\n\n\n\n\nggplot(data = mpsz3414,\n       aes(x = as.numeric(`PreSch Density`), y = as.numeric(`PreSch Count`))) +\n  geom_point() +\n  labs(x = \"Pre-school Density (per km square)\",\n       y = \"Pre-school Count\")"
  },
  {
    "objectID": "Hands-on_Ex01.html#getting-started",
    "href": "Hands-on_Ex01.html#getting-started",
    "title": "Hands-on Exercise 1: Geospatial Wrangling with R",
    "section": "Getting Started",
    "text": "Getting Started\nThe code chunk below installs and loads sf and tidyverse.\nNotes: Make sure you imported the pacman package before running the code below.\n\npacman::p_load(sf, tidyverse)"
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#getting-started",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#getting-started",
    "title": "Hands-on Exercise 1: Geospatial Wrangling with R",
    "section": "Getting Started",
    "text": "Getting Started\nThe code chunk below installs and loads sf and tidyverse.\nNotes: Make sure you imported the pacman package before running the code below.\n\npacman::p_load(sf, tidyverse)"
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#import-geospatial-data",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#import-geospatial-data",
    "title": "Hands-on Exercise 1: Geospatial Wrangling with R",
    "section": "Import Geospatial Data",
    "text": "Import Geospatial Data\nBefore importing anything, download the data zip file(s), unzip, and put them into the folder inside the directory of your page. Then create a Quarto document within that folder. The Quarto document and the data files need to be in the same folder, or you need to clarify the path to the data file while running the code below.\n\nImport polygon feature data\nNotes: You need to save your working R document as an qmd file before you can run the code below.\n\nmpsz <- st_read(dsn = \"data/geospatial\", layer = \"MP14_SUBZONE_WEB_PL\")\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/Hands-on_Ex01/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\n\n\n\nImport polyline feature data\nRun the code chunk below.\n\ncyclingpath <- st_read(dsn = \"data/geospatial\", layer = \"CyclingPath\")\n\nReading layer `CyclingPath' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/Hands-on_Ex01/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 1625 features and 2 fields\nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: 12711.19 ymin: 28711.33 xmax: 42626.09 ymax: 48948.15\nProjected CRS: SVY21\n\n\n\n\nImport GIS data in kml format\nRun the code chunk below.\n\npreschool <- st_read(\"data/geospatial/pre-schools-location-kml.kml\")\n\nReading layer `PRESCHOOLS_LOCATION' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/Hands-on_Ex01/data/geospatial/pre-schools-location-kml.kml' \n  using driver `KML'\nSimple feature collection with 1359 features and 2 fields\nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6824 ymin: 1.248403 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84"
  },
  {
    "objectID": "Hands-on_Ex01.html#import-geospatial-data",
    "href": "Hands-on_Ex01.html#import-geospatial-data",
    "title": "Hands-on Exercise 1: Geospatial Wrangling with R",
    "section": "Import Geospatial Data",
    "text": "Import Geospatial Data\n\nImport polygon feature data\nNotes: You need to save your working R document as an qmd file before you can run the code below.\n\nmpsz <- st_read(dsn = \"Hands-on_Ex01/data/geospatial\", layer = \"MP14_SUBZONE_WEB_PL\")\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/Hands-on_Ex01/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21"
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#checking-data-frame-content",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#checking-data-frame-content",
    "title": "Hands-on Exercise 1: Geospatial Wrangling with R",
    "section": "Checking Data Frame Content",
    "text": "Checking Data Frame Content\n\nWorking with st_geometry()\nThe type of geometry is multipolygon.\n\nst_geometry(mpsz)\n\nGeometry set for 323 features \nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\nFirst 5 geometries:\n\n\nMULTIPOLYGON (((31495.56 30140.01, 31980.96 296...\n\n\nMULTIPOLYGON (((29092.28 30021.89, 29119.64 300...\n\n\nMULTIPOLYGON (((29932.33 29879.12, 29947.32 298...\n\n\nMULTIPOLYGON (((27131.28 30059.73, 27088.33 297...\n\n\nMULTIPOLYGON (((26451.03 30396.46, 26440.47 303...\n\n\n\n\nWorking with glimpse()\nGlimpse display a sneak peek into the data type and values of the variables. Notice that X_ADDR and Y_ADDR are double type. There are other types like character, integer, and date.\n\nglimpse(mpsz)\n\nRows: 323\nColumns: 16\n$ OBJECTID   <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, …\n$ SUBZONE_NO <int> 1, 1, 3, 8, 3, 7, 9, 2, 13, 7, 12, 6, 1, 5, 1, 1, 3, 2, 2, …\n$ SUBZONE_N  <chr> \"MARINA SOUTH\", \"PEARL'S HILL\", \"BOAT QUAY\", \"HENDERSON HIL…\n$ SUBZONE_C  <chr> \"MSSZ01\", \"OTSZ01\", \"SRSZ03\", \"BMSZ08\", \"BMSZ03\", \"BMSZ07\",…\n$ CA_IND     <chr> \"Y\", \"Y\", \"Y\", \"N\", \"N\", \"N\", \"N\", \"Y\", \"N\", \"N\", \"N\", \"N\",…\n$ PLN_AREA_N <chr> \"MARINA SOUTH\", \"OUTRAM\", \"SINGAPORE RIVER\", \"BUKIT MERAH\",…\n$ PLN_AREA_C <chr> \"MS\", \"OT\", \"SR\", \"BM\", \"BM\", \"BM\", \"BM\", \"SR\", \"QT\", \"QT\",…\n$ REGION_N   <chr> \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENT…\n$ REGION_C   <chr> \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\",…\n$ INC_CRC    <chr> \"5ED7EB253F99252E\", \"8C7149B9EB32EEFC\", \"C35FEFF02B13E0E5\",…\n$ FMEL_UPD_D <date> 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05…\n$ X_ADDR     <dbl> 31595.84, 28679.06, 29654.96, 26782.83, 26201.96, 25358.82,…\n$ Y_ADDR     <dbl> 29220.19, 29782.05, 29974.66, 29933.77, 30005.70, 29991.38,…\n$ SHAPE_Leng <dbl> 5267.381, 3506.107, 1740.926, 3313.625, 2825.594, 4428.913,…\n$ SHAPE_Area <dbl> 1630379.27, 559816.25, 160807.50, 595428.89, 387429.44, 103…\n$ geometry   <MULTIPOLYGON [m]> MULTIPOLYGON (((31495.56 30..., MULTIPOLYGON (…\n\n\n\n\nWorking with head()\nUse n = … to select the number of records to display. Head gives a look at the first few rows of the data frame.\n\nhead(mpsz, n = 5)\n\nSimple feature collection with 5 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 25867.68 ymin: 28369.47 xmax: 32362.39 ymax: 30435.54\nProjected CRS: SVY21\n  OBJECTID SUBZONE_NO      SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N\n1        1          1   MARINA SOUTH    MSSZ01      Y    MARINA SOUTH\n2        2          1   PEARL'S HILL    OTSZ01      Y          OUTRAM\n3        3          3      BOAT QUAY    SRSZ03      Y SINGAPORE RIVER\n4        4          8 HENDERSON HILL    BMSZ08      N     BUKIT MERAH\n5        5          3        REDHILL    BMSZ03      N     BUKIT MERAH\n  PLN_AREA_C       REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1         MS CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84\n2         OT CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06\n3         SR CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96\n4         BM CENTRAL REGION       CR 3775D82C5DDBEFBD 2014-12-05 26782.83\n5         BM CENTRAL REGION       CR 85D9ABEF0A40678F 2014-12-05 26201.96\n    Y_ADDR SHAPE_Leng SHAPE_Area                       geometry\n1 29220.19   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...\n2 29782.05   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...\n3 29974.66   1740.926   160807.5 MULTIPOLYGON (((29932.33 29...\n4 29933.77   3313.625   595428.9 MULTIPOLYGON (((27131.28 30...\n5 30005.70   2825.594   387429.4 MULTIPOLYGON (((26451.03 30..."
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#plotting-the-geopspatial-data",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#plotting-the-geopspatial-data",
    "title": "Hands-on Exercise 1: Geospatial Wrangling with R",
    "section": "Plotting The Geopspatial Data",
    "text": "Plotting The Geopspatial Data\nWith geospatial data, we can use the plot() function to display them as visual elements. We can use max.plot = … to define the number of plots shown. This data set has 15 plots at the maximum but we only sketch 9 plots here, hence max.plot = 9.\n\nplot(mpsz, max.plot = 9)\n\n\n\n\nWe can choose to plot just one plot using the code chunk below. This is the plot of the sf object, which is the frame of all plots.\n\nplot(st_geometry(mpsz))\n\n\n\n\nOr we can plot and view a specific attribute.\n\nplot(mpsz[\"PLN_AREA_N\"])\n\n\n\n\n\nNotes: plot is only used for a quickly. For high cartographic quality plot, use tmap R package."
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#working-with-projection",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#working-with-projection",
    "title": "Hands-on Exercise 1: Geospatial Wrangling with R",
    "section": "Working with Projection",
    "text": "Working with Projection\nWhen we want to project two or more geospatial data sets, it is important to ensure the data sets are projected under the same coordinate system. Projection Transformation is the method of projecting a data frame from one coordinate system to another.\n\nAssign EPSG code to a data frame\nIssues to notice: missing coordination or wrongly assigned coordination due to the importing process.\nUsing the code chunk below, we can see the coordinate system of mpsz.\n\nst_crs(mpsz)\n\nCoordinate Reference System:\n  User input: SVY21 \n  wkt:\nPROJCRS[\"SVY21\",\n    BASEGEOGCRS[\"SVY21[WGS84]\",\n        DATUM[\"World Geodetic System 1984\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ID[\"EPSG\",6326]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"Degree\",0.0174532925199433]]],\n    CONVERSION[\"unnamed\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]\n\n\n\nNotice the User input says the data is projected in svy21, but the EPSG code is 9001. This is a wrong EPSG code because the EPSG code for svy21 should be 3414.\n\nWe now assign the correct EPSG code using the code below.\n\nmpsz3414 <- st_set_crs(mpsz, 3414)\n\nWarning: st_crs<- : replacing crs does not reproject data; use st_transform for\nthat\n\n\nR warns us that st_crs does not reproject data. While this is true in case we want to do projection transformation, here we simply want to fix the EPSG code. Therefore, reprojection is not necessary and we can proceed with checking the EPSG of mpsz3414, which shows the correct EPSG code.\n\nst_crs(mpsz3414)\n\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n\n\n\n\nTransform the projection of preschool from wgs84 to svy21\nNow we inspect the geometry of preschool. It is clear that preschool is projected in the WGS84 coordinate system.\n\nst_geometry(preschool)\n\nGeometry set for 1359 features \nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6824 ymin: 1.248403 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\nFirst 5 geometries:\n\n\nPOINT Z (103.7614 1.308683 0)\n\n\nPOINT Z (103.7536 1.315748 0)\n\n\nPOINT Z (103.7645 1.305078 0)\n\n\nPOINT Z (103.765 1.305239 0)\n\n\nPOINT Z (103.7597 1.315983 0)\n\n\nWe will transform the projection of preschool to svy21 using st_transform.\n\npreschool3414 <- st_transform(preschool, crs = 3414)\n\nNow we can inspect the geometry of preschool3414, which is now projected in svy21 coordinate system.\n\nst_geometry(preschool3414)\n\nGeometry set for 1359 features \nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 11203.01 ymin: 25667.6 xmax: 45404.24 ymax: 49300.88\nz_range:       zmin: 0 zmax: 0\nProjected CRS: SVY21 / Singapore TM\nFirst 5 geometries:\n\n\nPOINT Z (19997.26 32333.17 0)\n\n\nPOINT Z (19126.75 33114.35 0)\n\n\nPOINT Z (20345.12 31934.56 0)\n\n\nPOINT Z (20400.31 31952.36 0)\n\n\nPOINT Z (19810.78 33140.31 0)\n\n\n\nNotes: in Bounding box, the values are greater than 0-360 range of decimal degree commonly used by most of the geographic coordinate systems."
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#importing-and-converting-an-aspatial-data",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#importing-and-converting-an-aspatial-data",
    "title": "Hands-on Exercise 1: Geospatial Wrangling with R",
    "section": "Importing and Converting an Aspatial Data",
    "text": "Importing and Converting an Aspatial Data\n\nImport aspatial data\nBecause the listings dataset is in the csv format, we use the read.csv() function to import the data into an object called listings, which is a tibble data frame.\n\nlistings <- read.csv(\"data/aspatial/listings.csv\")\n\nTo inspect the data set, instead of using glimpse, now we use list because of the object type.\n\noptions(max.print = 5)\nlist(listings)\n\n[[1]]\n     id name host_id host_name neighbourhood_group neighbourhood latitude\n     longitude room_type price minimum_nights number_of_reviews last_review\n     reviews_per_month calculated_host_listings_count availability_365\n [ reached 'max' / getOption(\"max.print\") -- omitted 4252 rows ]\n\n\nWe can see that listings has 4,252 rows and 16 columns. We are going to use latitude and longitude.\n\nNote that they are in decimal degree format. As a best guess, we will assume that the data is in wgs84 Geographic Coordinate System.\n\n\n\nCreate a simple feature data frame\nWe now convert listings into a simple feature data frame using st_as_sf().\n\nlistings_sf <- st_as_sf(listings, coords = c(\"longitude\", \"latitude\"), crs = 4326) %>%\n  st_transform(crs = 3414)\n\nNotes\n\n\ncoords argument requires you to provide the column name of the x-coordinates first then followed by the column name of the y-coordinates.\ncrs argument requires you to provide the coordinates system in epsg format. EPSG: 4326 is wgs84 Geographic Coordinate System and EPSG: 3414 is Singapore SVY21 Projected Coordinate System. You can search for other country’s epsg code by referring to epsg.io.\n%>% is used to nest st_transform() to transform the newly created simple feature data frame into svy21 projected coordinates system.\n\n\nAfter the transformation, we can examine the new object listings_sf using glimpse.\n\nglimpse(listings_sf)\n\nRows: 4,252\nColumns: 15\n$ id                             <int> 50646, 71609, 71896, 71903, 275343, 275…\n$ name                           <chr> \"Pleasant Room along Bukit Timah\", \"Ens…\n$ host_id                        <int> 227796, 367042, 367042, 367042, 1439258…\n$ host_name                      <chr> \"Sujatha\", \"Belinda\", \"Belinda\", \"Belin…\n$ neighbourhood_group            <chr> \"Central Region\", \"East Region\", \"East …\n$ neighbourhood                  <chr> \"Bukit Timah\", \"Tampines\", \"Tampines\", …\n$ room_type                      <chr> \"Private room\", \"Private room\", \"Privat…\n$ price                          <int> 80, 178, 81, 81, 52, 40, 72, 41, 49, 49…\n$ minimum_nights                 <int> 90, 90, 90, 90, 14, 14, 90, 8, 14, 14, …\n$ number_of_reviews              <int> 18, 20, 24, 48, 20, 13, 133, 105, 14, 1…\n$ last_review                    <chr> \"2014-07-08\", \"2019-12-28\", \"2014-12-10…\n$ reviews_per_month              <dbl> 0.22, 0.28, 0.33, 0.67, 0.20, 0.16, 1.2…\n$ calculated_host_listings_count <int> 1, 4, 4, 4, 50, 50, 7, 1, 50, 50, 50, 4…\n$ availability_365               <int> 365, 365, 365, 365, 353, 364, 365, 90, …\n$ geometry                       <POINT [m]> POINT (22646.02 35167.9), POINT (…"
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#geoprocessing-with-sf-package",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#geoprocessing-with-sf-package",
    "title": "Hands-on Exercise 1: Geospatial Wrangling with R",
    "section": "Geoprocessing with SF package",
    "text": "Geoprocessing with SF package\n\nBuffering\nThe scenario\nThe authority is planning to upgrade the exiting cycling path. To do so, they need to acquire 5 metres of reserved land on the both sides of the current cycling path. You are tasked to determine the extend of the land need to be acquired and their total area.\nSolution\nCompute the 5-meter buffers around cycling paths\n\nbuffer_cycling <- st_buffer(cyclingpath, dist = 5, nQuadSegs = 30)\n\nCalculate the area of the buffers as shown in the code chunk below.\n\nbuffer_cycling$AREA <- st_area(buffer_cycling)\n\nLastly, sum() of Base R will be used to derive the total land involved.\n\nsum(buffer_cycling$AREA)\n\n773143.9 [m^2]\n\n\n\n\nPoint-in-polygon count\nThe scenario\nA pre-school service group want to find out the numbers of pre-schools in each Planning Subzone.\nThe solution\nThe code chunk below performs two operations at one go. Firstly, identify pre-schools located inside each Planning Subzone by using st_intersects(). Next, length() of Base R is used to calculate numbers of pre-schools that fall inside each planning subzone.\n\nmpsz3414$`PreSch Count` <- lengths(st_intersects(mpsz3414, preschool3414))\n\nNow we check the new PreSch Count field.\n\nsummary(mpsz3414$`PreSch Count`)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  0.000   0.000   2.000   4.207   6.000  37.000 \n\n\nTo list the planning subzone with the most number of pre-school, the top_n() of dplyr package is used as shown in the code chunk below.\n\ntop_n(mpsz3414, 1, `PreSch Count`)\n\nSimple feature collection with 1 feature and 16 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 23449.05 ymin: 46001.23 xmax: 25594.22 ymax: 47996.47\nProjected CRS: SVY21 / Singapore TM\n     OBJECTID SUBZONE_NO SUBZONE_N SUBZONE_C CA_IND PLN_AREA_N PLN_AREA_C\n     REGION_N REGION_C INC_CRC FMEL_UPD_D X_ADDR Y_ADDR SHAPE_Leng SHAPE_Area\n     geometry PreSch Count\n [ reached 'max' / getOption(\"max.print\") -- omitted 1 rows ]\n\n\n\n\nCalculate the density of pre-school by planning subzone\nFirstly, the code chunk below uses st_area() of sf package to derive the area of each planning subzone.\n\nmpsz3414$Area <- mpsz3414 %>%\n  st_area()\n\nNext, mutate() of dplyr package is used to compute the density by using the code chunk below.\n\nmpsz3414 <- mpsz3414 %>%\n  mutate(`PreSch Density` = `PreSch Count`/Area * 1000000)\n\nResults\n\nsummary(mpsz3414$`PreSch Density`)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  0.000   0.000   2.974   4.076   6.609  29.059 \n\n\n\ntop_n(mpsz3414, 1, `PreSch Density`)\n\nSimple feature collection with 1 feature and 18 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 28896.26 ymin: 28339.16 xmax: 29426.66 ymax: 28685.25\nProjected CRS: SVY21 / Singapore TM\n\n\nWarning in format.data.frame(if (omit) x[seq_len(n0), , drop = FALSE] else x, :\ncorrupt data frame: columns will be truncated or padded with NAs\n\n\n     OBJECTID SUBZONE_NO SUBZONE_N SUBZONE_C CA_IND PLN_AREA_N PLN_AREA_C\n     REGION_N REGION_C INC_CRC FMEL_UPD_D X_ADDR Y_ADDR SHAPE_Leng SHAPE_Area\n     geometry PreSch Count Area PreSch Density\n [ reached 'max' / getOption(\"max.print\") -- omitted 1 rows ]"
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#exploratory-data-analysis",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#exploratory-data-analysis",
    "title": "Hands-on Exercise 1: Geospatial Wrangling with R",
    "section": "Exploratory Data Analysis",
    "text": "Exploratory Data Analysis\nFirstly, we will plot a histogram to reveal the distribution of PreSch Density. Conventionally, hist() of R Graphics will be used as shown in the code chunk below.\n\nhist(mpsz3414$`PreSch Density`, main = \"Histogram of School Density\", xlab = \"School Density\")\n\n\n\n\nIn the code chunk below, appropriate ggplot2 functions will be used.\n\nggplot(data=mpsz3414, \n       aes(x= as.numeric(`PreSch Density`)))+\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  labs(title = \"Are pre-school even distributed in Singapore?\",\n       subtitle= \"There are many planning sub-zones with a single pre-school, on the other hand, \\nthere are two planning sub-zones with at least 20 pre-schools\",\n      x = \"Pre-school density (per km sq)\",\n      y = \"Frequency\")\n\n\n\n\n\nRelationship between Pre-school Density and Pre-school Count\n\nggplot(data = mpsz3414,\n       aes(x = as.numeric(`PreSch Density`), y = as.numeric(`PreSch Count`))) +\n  geom_point() +\n  labs(x = \"Pre-school Density (per km square)\",\n       y = \"Pre-school Count\")"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex1/In-class_ex1.html",
    "href": "In-class_Ex/In-class_Ex1/In-class_ex1.html",
    "title": "Spatial Weight and Applications",
    "section": "",
    "text": "The code chunk below will install and load tidyverse and sf package.\n\npacman::p_load(sf, tidyverse)\n\nThen we load tmap.\n\nlibrary(tmap)"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex1/In-class_ex1.html#getting-started",
    "href": "In-class_Ex/In-class_Ex1/In-class_ex1.html#getting-started",
    "title": "In-class Exercise",
    "section": "Getting Started",
    "text": "Getting Started\nThe code chunk below will install and load tidyverse and sf package.\n\npacman::p_load(sf, tidyverse)"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex1/In-class_ex1.html#import-geospatial-data",
    "href": "In-class_Ex/In-class_Ex1/In-class_ex1.html#import-geospatial-data",
    "title": "Spatial Weight and Applications",
    "section": "Import Geospatial Data",
    "text": "Import Geospatial Data\n\nImporting polygon features\nThis code chunk will import ESRI shapefile into R.\n\nhunan <- st_read(dsn = \"dataC/geospatial\", layer = \"Hunan\")\n\nReading layer `Hunan' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/In-class_Ex/In-class_Ex1/dataC/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n\n\n\n\nImporting attribute data in csv\n\nhunan2012 <- read_csv(\"dataC/aspatial/Hunan_2012.csv\", show_col_types = FALSE)\n\n\n\nPerforming Relational Join\n\nhunan <- left_join(hunan,hunan2012)\n\nJoining, by = \"County\""
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#overview-1",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#overview-1",
    "title": "Hands-on Exercise 1: Geospatial Wrangling and Choropleth Mapping with R",
    "section": "Overview",
    "text": "Overview\nChoropleth map is a map showing different colors depending on the value of the attribute that the map is presenting. For example, a map showing population density have different colors for each areas with varying levels of population density."
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#getting-started-1",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#getting-started-1",
    "title": "Hands-on Exercise 1: Geospatial Wrangling and Choropleth Mapping with R",
    "section": "Getting Started",
    "text": "Getting Started\nThis exercise will use the tmap R package and four other R packages.\n\nreadr for importing delimited text file,\ntidyr for tidying data,\ndplyr for wrangling data and\nsf for handling geospatial data.\n\nFirst, we load the packages into R Studio.\n\npacman::p_load(sf, tmap, tidyverse)"
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#importing-data-into-r",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#importing-data-into-r",
    "title": "Hands-on Exercise 1: Geospatial Wrangling and Choropleth Mapping with R",
    "section": "Importing Data into R",
    "text": "Importing Data into R\n\nImporting Geospatial Data into R\nSince we already imported and inspected the MP4_SUBZONE_WEB_PL shapefile as mpsz, we can skip this step.\n\n\nImporting Attribute Data into R\n\npopdata <- read_csv('~/sylvie-le/ISSS624/Hands-on_Ex01/data/aspatial/respopagesextod2011to2020.csv')\n\nRows: 984656 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): PA, SZ, AG, Sex, TOD\ndbl (2): Pop, Time\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\n\nData Preparation\n\n\nWe need to prepare a data table with the necessary data points as below.\n\nYOUNG: age group 0 to 4 until age groyup 20 to 24,\nECONOMY ACTIVE: age group 25-29 until age group 60-64,\nAGED: age group 65 and above,\nTOTAL: all age group, and\nDEPENDENCY: the ratio between young and aged against economy active group\n\n\nData Wrangling\nThe functions below is used to wrangle the data as defined above.\n\npopdata2020 <- popdata %>%\n  filter(Time == 2020) %>%\n  group_by(PA, SZ, AG) %>%\n  summarise(`POP` = sum(`Pop`)) %>%\n  ungroup()%>%\n  pivot_wider(names_from=AG, \n              values_from=POP) %>%\n  mutate(YOUNG = rowSums(.[3:6])\n         +rowSums(.[12])) %>%\nmutate(`ECONOMY ACTIVE` = rowSums(.[7:11])+\nrowSums(.[13:15]))%>%\nmutate(`AGED`=rowSums(.[16:21])) %>%\nmutate(`TOTAL`=rowSums(.[3:21])) %>%  \nmutate(`DEPENDENCY` = (`YOUNG` + `AGED`)\n/`ECONOMY ACTIVE`) %>%\n  select(`PA`, `SZ`, `YOUNG`, \n       `ECONOMY ACTIVE`, `AGED`, \n       `TOTAL`, `DEPENDENCY`)\n\n`summarise()` has grouped output by 'PA', 'SZ'. You can override using the\n`.groups` argument.\n\n\n\n\nJoining the attribute data and geospatial data\nBefore we can perform the georelational join, one extra step is required to convert the values in PA and SZ fields to uppercase. This is because the values of PA and SZ fields are made up of upper- and lowercase. On the other, hand the SUBZONE_N and PLN_AREA_N are in uppercase.\nSince funs() was deprecated, we use list() instead.\n\npopdata2020 <- popdata2020 %>%\n  mutate_at(.vars = vars(PA, SZ), \n          .funs = list(toupper)) %>%\n  filter(`ECONOMY ACTIVE` > 0)\n\nAfter that, we conduct a left join of the data using left_join() , to ensure the output to be simple features data frame.\n\nmpsz_pop2020 <- left_join(mpsz, popdata2020,\n                          by = c(\"SUBZONE_N\" = \"SZ\"))\n\nNow we save the new file after creating a new folder called rds in data folder.\n\nwrite_rds(mpsz_pop2020, \"~/sylvie-le/ISSS624/Hands-on_Ex01/data/rds/mpszpop2020.rds\")"
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#choropleth-mapping-geospatial-data-using-tmap",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#choropleth-mapping-geospatial-data-using-tmap",
    "title": "Hands-on Exercise 1: Geospatial Wrangling and Choropleth Mapping with R",
    "section": "Choropleth Mapping Geospatial Data Using tmap",
    "text": "Choropleth Mapping Geospatial Data Using tmap\nTwo approaches can be used to prepare thematic map using tmap, they are:\n\nPlotting a thematic map quickly by using qtm().\nPlotting highly customisable thematic map by using tmap elements.\n\n\nMethod 1: Plotting using qtm()\n\ntmap_mode(mode = \"plot\")\n\ntmap mode set to plotting\n\nqtm(mpsz_pop2020, \n    fill = \"DEPENDENCY\")\n\n\n\n\nNotes\n\n\ntmap_mode() with “plot” option is used to produce a static map. For interactive mode, “view” option should be used.\nfill argument is used to map the attribute (i.e. DEPENDENCY)\n\n\n\n\nMethod 2: Creating a choropleth map by using tmap’s elements\nWhile being convenient and short, qtm() does not allow for drawing maps with high cartographic quality. To overcome qtm()’s disadvantage, we can use tmap’s elements.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\",\n          title = \"Dependency ratio\") +\n  tm_layout(main.title = \"Distribution of Dependency Ratio by planning subzone\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar() +\n  tm_grid(alpha =0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\\n and Population data from Department of Statistics DOS\", \n             position = c(\"left\", \"bottom\"))\n\n\n\n\nNext, let’s look at the code and draw the map step by step to understand how each element works.\n\nDrawing a base map\nThe building block of tmap is tm_shape(), which is followed by elements such as tm_fill() and tm_polygons(). We will use tm_polygons() as it allows us to fill the polygons with color as tm_fill() does, and also let us draw the border of the polygons as tm_border().\n\ntm_shape(mpsz_pop2020) +\n  tm_polygons()\n\n\n\n\n\n\nDrawing a choropleth map using tm_polygons()\nNext, we will define how the colors are filled into the map by letting tm_polygons() know the criteria to fill. In this case, the criteria is the variable DEPENDENCY.\n\ntm_shape(mpsz_pop2020)+\n  tm_polygons(\"DEPENDENCY\")\n\n\n\n\nNotes\n\n\nThe default binning to draw the choropleth map is called “pretty”. Refer to sub-section 4.3 for more details.\nThe default color scheme is YlOrRd. Refer to sub-section 4.4 for more details of color schemes.\nBy default, Missing value is filled with gray.\n\n\n\n\nDrawing a choropleth map using tm_fill() and tm_border()\nInstead of using tm_polygons(), we can use tm_fill() and tm_border() instead. The code will be longer but if some day we like to type more, we can opt for this option.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\")\n\n\n\n\nWith just tm_fill(), the map is drawn without the borders between the areas. To add the borders, we combine the code chunk above with tm_borders().\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\") +\n  tm_borders(lwd = 0.1,  alpha = 1)\n\n\n\n\nObserving the map, we see that the border thickness are different that what we achieved with tm_polygons(). This suggests that we can customize border thickness with tm_borders().\nThe argument to customize borders are at below.\n\n\ncol = border colour,\nlwd = border line width. The default is 1, and\nlty = border line type. The default is “solid”.\n\n\n\n\n\nData classification methods of tmap\nData classification is to group a large numbers of observations into ranges or classes. It helps us to better describe the data and present the information we want to highlight, besides other roles.\ntmap provides a total ten data classification methods, namely: fixed, sd, equal, pretty (default), quantile, kmeans, hclust, bclust, fisher, and jenks. Refer to R documentations details on the methods.\nTo define a data classification method, the style argument of tm_fill() or tm_polygons() will be used.\n\nPlotting choropleth maps with built-in classification methods\nUse n = 5 as in the code chunk below to classify the data into 5 classes.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\nThe code below classifies the data using equal classification method.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\nNotice that the distribution of quantile data classification method are more evenly distributed then equal data classification method.\nNext, we will use all of the classification methods and compare the results.\n\nMap Comparison\n\nm1 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"sd\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"SD\")\nm2 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Equal\")\nm3 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"pretty\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Pretty\")\nm4 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Quantile\")\nm5 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"kmeans\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Kmeans\")\nm6 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"hclust\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Hclust\")\nm7 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"bclust\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Bclust\")\nm8 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"fisher\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Fisher\")\nm9 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Jenks\")\n\ntmap_arrange(m1, m2, asp=1, ncol=2)\n\n\n\ntmap_arrange(m3, m4, asp=1, ncol=2)\n\n\n\ntmap_arrange(m5, m6, asp=1, ncol=2)\n\n\n\ntmap_arrange(m7, m8, asp=1, ncol=2)\n\n\n\n\nCommittee Member: 1(1) 2(1) 3(1) 4(1) 5(1) 6(1) 7(1) 8(1) 9(1) 10(1)\nComputing Hierarchical Clustering\n\ntmap_arrange(m9, asp=1, ncol=2)\n\n\n\n\nEach data classification methods provide a different representation of the data. Therefore, we should consider which classification method to best presenting the data, and which classification methods are meaningful to the data. Data presentation can be misleading if we don’t choose carefully.\n\n\n\nPlotting choropleth map with custome break\nFor all the built-in styles, the category breaks are computed internally. In order to override these defaults, the breakpoints can be set explicitly by means of the breaks argument to the tm_fill(). It is important to note that, in tmap the breaks include a minimum and maximum. As a result, in order to end up with n categories, n+1 elements must be specified in the breaks option (the values must be in increasing order).\nBefore we get started, it is always a good practice to get some descriptive statistics on the variable before setting the break points. Code chunk below will be used to compute and display the descriptive statistics of DEPENDENCY field.\n\nsummary(mpsz_pop2020$DEPENDENCY)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n 0.0000  0.6519  0.7025  0.7742  0.7645 19.0000      92 \n\n\nWe set break point at 0.60, 0.70, 0.80, and 0.90 to reflect the quartiles, and include the min and max values as 0 and 100 respectively. Our breaks vector will be c(0, 0.60, 0.70, 0.80, 0.90, 100).\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          breaks = c(0, 0.60, 0.70, 0.80, 0.90, 100)) +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\nColour Scheme\ntmap supports colour ramps either defined by the user or a set of predefined colour ramps from the RColorBrewer package.\n\nUsing ColourBrewer palette\nUsing the palette argument of tm_fill(), we can define the color.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 6,\n          style = \"quantile\",\n          palette = \"Blues\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\nIn this map, the color gets bolder when the value increases. To reverse the color map and make the higher values lighter, we use the prefix - before the color map’s name.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          style = \"quantile\",\n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\nMap Layouts\nMap layout refers to the combination of all map elements like title, legend, scale bar, etc. into a cohensive map.\n\nMap Legend\nWe can customize the legend with multiple arguments using tm_layouts(). A histogram legend can be added using legend.hist. legend.is.portrait determines if the legends are in portrait or landscape mode. Refer to R documentation on tm_fill() for more details of legend settings.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"jenks\", \n          palette = \"Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1) +\n  tm_layout(main.title = \"Distribution of Dependency Ratio by planning subzone \\n(Jenks classification)\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            legend.outside = FALSE,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\nMap style\ntmap_style() is used to set many styles for the map. See Details of tm_layout() for predefined styles.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"classic\")\n\ntmap style set to \"classic\"\n\n\nother available styles are: \"white\", \"gray\", \"natural\", \"cobalt\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"watercolor\" \n\n\n\n\n\n\n\nCartographic Furniture\nBeside map style, tmap also also provides arguments to draw other map furniture such as compass, scale bar and grid lines. Refer to tm_layout()’s documentation for more details on the argument to customize the map.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\",\n          title = \"No. of persons\") +\n  tm_layout(main.title = \"Distribution of Dependency Ratio \\nby planning subzone\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\\n and Population data from Department of Statistics DOS\", \n             position = c(\"left\", \"bottom\"))\n\n\n\n\n\n\n\nDrawing Small Multiple Choropleth Maps\nSmall multiple maps, also referred to as facet maps, are composed of many maps arrange side-by-side, and sometimes stacked vertically.\nIn tmap, small multiple maps can be plotted in three ways:\n\nby assigning multiple values to at least one of the asthetic arguments,\nby defining a group-by variable in tm_facets(), and\nby creating multiple stand-alone maps with tmap_arrange().\n\n\nBy assigning multiple values to at least one of the aesthetic arguments\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(c(\"YOUNG\", \"AGED\"),\n          style = \"equal\", \n          palette = \"Blues\") +\n  tm_layout(legend.position = c(\"right\", \"bottom\")) +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"white\")\n\ntmap style set to \"white\"\n\n\nother available styles are: \"gray\", \"natural\", \"cobalt\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"classic\", \"watercolor\" \n\n\n\n\n\nIn this example, small multiple choropleth maps are created by assigning multiple values to at least one of the aesthetic arguments.\n\ntm_shape(mpsz_pop2020)+ \n  tm_polygons(c(\"DEPENDENCY\",\"AGED\"),\n          style = c(\"equal\", \"quantile\"), \n          palette = list(\"Blues\",\"Greens\")) +\n  tm_layout(legend.position = c(\"right\", \"bottom\"))\n\n\n\n\n\n\nBy defining a group-by variable in tm_facets()\n\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          style = \"quantile\",\n          palette = \"Blues\",\n          thres.poly = 0) + \n  tm_facets(by=\"REGION_N\", \n            free.coords=TRUE, \n            drop.shapes=TRUE) +\n  tm_layout(legend.show = FALSE,\n            title.position = c(\"center\", \"center\"), \n            title.size = 20) +\n  tm_borders(alpha = 0.5)\n\nWarning: The argument drop.shapes has been renamed to drop.units, and is\ntherefore deprecated\n\n\n\n\n\n\n\nBy creating multiple stand-alone maps with tmap_arrange()\n\nyoungmap <- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"YOUNG\", \n              style = \"quantile\", \n              palette = \"Blues\")\n\nagedmap <- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"AGED\", \n              style = \"quantile\", \n              palette = \"Blues\")\n\ntmap_arrange(youngmap, agedmap, asp=1, ncol=2)\n\n\n\n\n\n\n\nMappping Spatial Object Meeting a Selection Criterion\nThis code chunk below filter the areas by the criterion determined below in tm_shape().\n\ntm_shape(mpsz_pop2020[mpsz_pop2020$REGION_N==\"CENTRAL REGION\", ])+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1) +\n  tm_layout(legend.outside = TRUE,\n            legend.height = 0.45, \n            legend.width = 5.0,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n\nWarning in pre_process_gt(x, interactive = interactive, orig_crs =\ngm$shape.orig_crs): legend.width controls the width of the legend within a map.\nPlease use legend.outside.size to control the width of the outside legend"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex1/In-class_ex1.html#visualising-regional-development-indicator",
    "href": "In-class_Ex/In-class_Ex1/In-class_ex1.html#visualising-regional-development-indicator",
    "title": "Spatial Weight and Applications",
    "section": "Visualising Regional Development Indicator",
    "text": "Visualising Regional Development Indicator\nNow, we are going to prepare a basemap and a choropleth map showing the distribution of GDPPC 2012 by using qtm() of tmap package.\n\nbasemap <- tm_shape(hunan) +\n  tm_polygons() +\n  tm_text(\"NAME_3\", size=0.3)+\n  tmap_options(check.and.fix = TRUE)\n\ngdppc <- qtm(hunan, \"GDPPC\")+\n  tm_layout(legend.text.size = 0.5)\n\ntmap_arrange(basemap, gdppc, asp=1, ncol=2)"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex1/In-class_ex1.html#computing-contiguity-spatial-weights",
    "href": "In-class_Ex/In-class_Ex1/In-class_ex1.html#computing-contiguity-spatial-weights",
    "title": "Spatial Weight and Applications",
    "section": "Computing Contiguity Spatial Weights",
    "text": "Computing Contiguity Spatial Weights\n\nComputing (QUEEN) contiguity based neighbors\nFirst we install spdep package.\n\npacman::p_load(spdep)\n\n\nwm_q <- poly2nb(hunan, queen=TRUE)\nsummary(wm_q)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n\n\nTo see the neighbors for the first polygon in the object.\n\nwm_q[[1]]\n\n[1]  2  3  4 57 85\n\n\nWe can retrive the county name of Polygon ID=1 by using the code chunk below.\n\nhunan$County[1]\n\n[1] \"Anxiang\"\n\n\nRetrieve the names of the neighboring polygons with polygon 1.\n\nhunan$NAME_3[c(2,3,4,57,85)]\n\n[1] \"Hanshou\" \"Jinshi\"  \"Li\"      \"Nan\"     \"Taoyuan\"\n\n\nRetrieve the GDPPC of the areas.\n\nnb1 <- wm_q[[1]]\nnbb <- hunan$GDPPC[nb1]\nnbb\n\n[1] 20981 34592 24473 21311 22879\n\n\nDisplay the complete weight matrix.\n\nstr(wm_q)\n\nList of 88\n $ : int [1:5] 2 3 4 57 85\n $ : int [1:5] 1 57 58 78 85\n $ : int [1:4] 1 4 5 85\n $ : int [1:4] 1 3 5 6\n $ : int [1:4] 3 4 6 85\n $ : int [1:5] 4 5 69 75 85\n $ : int [1:4] 67 71 74 84\n $ : int [1:7] 9 46 47 56 78 80 86\n $ : int [1:6] 8 66 68 78 84 86\n $ : int [1:8] 16 17 19 20 22 70 72 73\n $ : int [1:3] 14 17 72\n $ : int [1:5] 13 60 61 63 83\n $ : int [1:4] 12 15 60 83\n $ : int [1:3] 11 15 17\n $ : int [1:4] 13 14 17 83\n $ : int [1:5] 10 17 22 72 83\n $ : int [1:7] 10 11 14 15 16 72 83\n $ : int [1:5] 20 22 23 77 83\n $ : int [1:6] 10 20 21 73 74 86\n $ : int [1:7] 10 18 19 21 22 23 82\n $ : int [1:5] 19 20 35 82 86\n $ : int [1:5] 10 16 18 20 83\n $ : int [1:7] 18 20 38 41 77 79 82\n $ : int [1:5] 25 28 31 32 54\n $ : int [1:5] 24 28 31 33 81\n $ : int [1:4] 27 33 42 81\n $ : int [1:3] 26 29 42\n $ : int [1:5] 24 25 33 49 54\n $ : int [1:3] 27 37 42\n $ : int 33\n $ : int [1:8] 24 25 32 36 39 40 56 81\n $ : int [1:8] 24 31 50 54 55 56 75 85\n $ : int [1:5] 25 26 28 30 81\n $ : int [1:3] 36 45 80\n $ : int [1:6] 21 41 47 80 82 86\n $ : int [1:6] 31 34 40 45 56 80\n $ : int [1:4] 29 42 43 44\n $ : int [1:4] 23 44 77 79\n $ : int [1:5] 31 40 42 43 81\n $ : int [1:6] 31 36 39 43 45 79\n $ : int [1:6] 23 35 45 79 80 82\n $ : int [1:7] 26 27 29 37 39 43 81\n $ : int [1:6] 37 39 40 42 44 79\n $ : int [1:4] 37 38 43 79\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:3] 8 47 86\n $ : int [1:5] 8 35 46 80 86\n $ : int [1:5] 50 51 52 53 55\n $ : int [1:4] 28 51 52 54\n $ : int [1:5] 32 48 52 54 55\n $ : int [1:3] 48 49 52\n $ : int [1:5] 48 49 50 51 54\n $ : int [1:3] 48 55 75\n $ : int [1:6] 24 28 32 49 50 52\n $ : int [1:5] 32 48 50 53 75\n $ : int [1:7] 8 31 32 36 78 80 85\n $ : int [1:6] 1 2 58 64 76 85\n $ : int [1:5] 2 57 68 76 78\n $ : int [1:4] 60 61 87 88\n $ : int [1:4] 12 13 59 61\n $ : int [1:7] 12 59 60 62 63 77 87\n $ : int [1:3] 61 77 87\n $ : int [1:4] 12 61 77 83\n $ : int [1:2] 57 76\n $ : int 76\n $ : int [1:5] 9 67 68 76 84\n $ : int [1:4] 7 66 76 84\n $ : int [1:5] 9 58 66 76 78\n $ : int [1:3] 6 75 85\n $ : int [1:3] 10 72 73\n $ : int [1:3] 7 73 74\n $ : int [1:5] 10 11 16 17 70\n $ : int [1:5] 10 19 70 71 74\n $ : int [1:6] 7 19 71 73 84 86\n $ : int [1:6] 6 32 53 55 69 85\n $ : int [1:7] 57 58 64 65 66 67 68\n $ : int [1:7] 18 23 38 61 62 63 83\n $ : int [1:7] 2 8 9 56 58 68 85\n $ : int [1:7] 23 38 40 41 43 44 45\n $ : int [1:8] 8 34 35 36 41 45 47 56\n $ : int [1:6] 25 26 31 33 39 42\n $ : int [1:5] 20 21 23 35 41\n $ : int [1:9] 12 13 15 16 17 18 22 63 77\n $ : int [1:6] 7 9 66 67 74 86\n $ : int [1:11] 1 2 3 5 6 32 56 57 69 75 ...\n $ : int [1:9] 8 9 19 21 35 46 47 74 84\n $ : int [1:4] 59 61 62 88\n $ : int [1:2] 59 87\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language poly2nb(pl = hunan, queen = TRUE)\n - attr(*, \"type\")= chr \"queen\"\n - attr(*, \"sym\")= logi TRUE\n\n\n\n\nCreating (ROOK) contiguity based neighbors\n\nwm_r <- poly2nb(hunan, queen=FALSE)\nsummary(wm_r)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 440 \nPercentage nonzero weights: 5.681818 \nAverage number of links: 5 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 10 \n 2  2 12 20 21 14 11  3  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 10 links\n\n\n\n\nVisualizing contiguity weights\nA connectivity graph takes a point and displays a line to each neighboring point. We are working with polygons, so need to find a way to convert them into points. The most typical method is to find out the polygon centroids.\nGet longitude and latitude value for the centroids.\n\nlongitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])\nlatitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])\n\nNow that we have latitude and longitude, we use cbind to put longitude and latitude into the same object.\n\ncoords <- cbind(longitude, latitude)\n\nCheck the first few observations.\n\nhead(coords)\n\n     longitude latitude\n[1,]  112.1531 29.44362\n[2,]  112.0372 28.86489\n[3,]  111.8917 29.47107\n[4,]  111.7031 29.74499\n[5,]  111.6138 29.49258\n[6,]  111.0341 29.79863\n\n\n\nPlotting Queen contiguity based neighbors map\n\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= \"red\")\n\n\n\n\n\n\nPlotting Rook contiguity based neighbors map\n\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = \"red\")\n\n\n\n\n\n\nPlotting both Queen and Rook contiguity based neighbors maps\n\npar(mfrow=c(1,2))\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= \"red\", main=\"Queen Contiguity\")\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = \"red\", main=\"Rook Contiguity\")"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex1/In-class_ex1.html#computing-distance-based-neighbors",
    "href": "In-class_Ex/In-class_Ex1/In-class_ex1.html#computing-distance-based-neighbors",
    "title": "Spatial Weight and Applications",
    "section": "Computing distance based neighbors",
    "text": "Computing distance based neighbors\n\nk1 <- knn2nb(knearneigh(coords))\nk1dists <- unlist(nbdists(k1, coords, longlat = TRUE))\nsummary(k1dists)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  24.79   32.57   38.01   39.07   44.52   61.79 \n\n\nThe summary report shows that the largest first nearest neighbour distance is 61.79 km, so using this as the upper threshold gives certainty that all units will have at least one neighbor.\n\nComputing fixed distance weight matrix\n\nwm_d62 <- dnearneigh(coords, 0, 62, longlat = TRUE)\nwm_d62\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \n\n\nThe average number of links are the number of nonzero link for each region, which equals 324 divided by 88.\nNow we display the content of wm_d62.\n\nstr(wm_d62)\n\nList of 88\n $ : int [1:5] 3 4 5 57 64\n $ : int [1:4] 57 58 78 85\n $ : int [1:4] 1 4 5 57\n $ : int [1:3] 1 3 5\n $ : int [1:4] 1 3 4 85\n $ : int 69\n $ : int [1:2] 67 84\n $ : int [1:4] 9 46 47 78\n $ : int [1:4] 8 46 68 84\n $ : int [1:4] 16 22 70 72\n $ : int [1:3] 14 17 72\n $ : int [1:5] 13 60 61 63 83\n $ : int [1:4] 12 15 60 83\n $ : int [1:2] 11 17\n $ : int 13\n $ : int [1:4] 10 17 22 83\n $ : int [1:3] 11 14 16\n $ : int [1:3] 20 22 63\n $ : int [1:5] 20 21 73 74 82\n $ : int [1:5] 18 19 21 22 82\n $ : int [1:6] 19 20 35 74 82 86\n $ : int [1:4] 10 16 18 20\n $ : int [1:3] 41 77 82\n $ : int [1:4] 25 28 31 54\n $ : int [1:4] 24 28 33 81\n $ : int [1:4] 27 33 42 81\n $ : int [1:2] 26 29\n $ : int [1:6] 24 25 33 49 52 54\n $ : int [1:2] 27 37\n $ : int 33\n $ : int [1:2] 24 36\n $ : int 50\n $ : int [1:5] 25 26 28 30 81\n $ : int [1:3] 36 45 80\n $ : int [1:6] 21 41 46 47 80 82\n $ : int [1:5] 31 34 45 56 80\n $ : int [1:2] 29 42\n $ : int [1:3] 44 77 79\n $ : int [1:4] 40 42 43 81\n $ : int [1:3] 39 45 79\n $ : int [1:5] 23 35 45 79 82\n $ : int [1:5] 26 37 39 43 81\n $ : int [1:3] 39 42 44\n $ : int [1:2] 38 43\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:5] 8 9 35 47 86\n $ : int [1:5] 8 35 46 80 86\n $ : int [1:5] 50 51 52 53 55\n $ : int [1:4] 28 51 52 54\n $ : int [1:6] 32 48 51 52 54 55\n $ : int [1:4] 48 49 50 52\n $ : int [1:6] 28 48 49 50 51 54\n $ : int [1:2] 48 55\n $ : int [1:5] 24 28 49 50 52\n $ : int [1:4] 48 50 53 75\n $ : int 36\n $ : int [1:5] 1 2 3 58 64\n $ : int [1:5] 2 57 64 66 68\n $ : int [1:3] 60 87 88\n $ : int [1:4] 12 13 59 61\n $ : int [1:5] 12 60 62 63 87\n $ : int [1:4] 61 63 77 87\n $ : int [1:5] 12 18 61 62 83\n $ : int [1:4] 1 57 58 76\n $ : int 76\n $ : int [1:5] 58 67 68 76 84\n $ : int [1:2] 7 66\n $ : int [1:4] 9 58 66 84\n $ : int [1:2] 6 75\n $ : int [1:3] 10 72 73\n $ : int [1:2] 73 74\n $ : int [1:3] 10 11 70\n $ : int [1:4] 19 70 71 74\n $ : int [1:5] 19 21 71 73 86\n $ : int [1:2] 55 69\n $ : int [1:3] 64 65 66\n $ : int [1:3] 23 38 62\n $ : int [1:2] 2 8\n $ : int [1:4] 38 40 41 45\n $ : int [1:5] 34 35 36 45 47\n $ : int [1:5] 25 26 33 39 42\n $ : int [1:6] 19 20 21 23 35 41\n $ : int [1:4] 12 13 16 63\n $ : int [1:4] 7 9 66 68\n $ : int [1:2] 2 5\n $ : int [1:4] 21 46 47 74\n $ : int [1:4] 59 61 62 88\n $ : int [1:2] 59 87\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language dnearneigh(x = coords, d1 = 0, d2 = 62, longlat = TRUE)\n - attr(*, \"dnn\")= num [1:2] 0 62\n - attr(*, \"bounds\")= chr [1:2] \"GE\" \"LE\"\n - attr(*, \"nbtype\")= chr \"distance\"\n - attr(*, \"sym\")= logi TRUE\n\n\nAnother way to display the structure of weight matrix is to combine table() and card() of sddep.\n\ntable(hunan$County, card(wm_d62))\n\n               \n                1 2 3 4 5 6\n  Anhua         1 0 0 0 0 0\n  Anren         0 0 0 1 0 0\n  Anxiang       0 0 0 0 1 0\n  Baojing       0 0 0 0 1 0\n  Chaling       0 0 1 0 0 0\n  Changning     0 0 1 0 0 0\n  Changsha      0 0 0 1 0 0\n  Chengbu       0 1 0 0 0 0\n  Chenxi        0 0 0 1 0 0\n  Cili          0 1 0 0 0 0\n  Dao           0 0 0 1 0 0\n  Dongan        0 0 1 0 0 0\n  Dongkou       0 0 0 1 0 0\n  Fenghuang     0 0 0 1 0 0\n  Guidong       0 0 1 0 0 0\n  Guiyang       0 0 0 1 0 0\n  Guzhang       0 0 0 0 0 1\n  Hanshou       0 0 0 1 0 0\n  Hengdong      0 0 0 0 1 0\n  Hengnan       0 0 0 0 1 0\n  Hengshan      0 0 0 0 0 1\n  Hengyang      0 0 0 0 0 1\n  Hongjiang     0 0 0 0 1 0\n  Huarong       0 0 0 1 0 0\n  Huayuan       0 0 0 1 0 0\n  Huitong       0 0 0 1 0 0\n  Jiahe         0 0 0 0 1 0\n  Jianghua      0 0 1 0 0 0\n  Jiangyong     0 1 0 0 0 0\n  Jingzhou      0 1 0 0 0 0\n  Jinshi        0 0 0 1 0 0\n  Jishou        0 0 0 0 0 1\n  Lanshan       0 0 0 1 0 0\n  Leiyang       0 0 0 1 0 0\n  Lengshuijiang 0 0 1 0 0 0\n  Li            0 0 1 0 0 0\n  Lianyuan      0 0 0 0 1 0\n  Liling        0 1 0 0 0 0\n  Linli         0 0 0 1 0 0\n  Linwu         0 0 0 1 0 0\n  Linxiang      1 0 0 0 0 0\n  Liuyang       0 1 0 0 0 0\n  Longhui       0 0 1 0 0 0\n  Longshan      0 1 0 0 0 0\n  Luxi          0 0 0 0 1 0\n  Mayang        0 0 0 0 0 1\n  Miluo         0 0 0 0 1 0\n  Nan           0 0 0 0 1 0\n  Ningxiang     0 0 0 1 0 0\n  Ningyuan      0 0 0 0 1 0\n  Pingjiang     0 1 0 0 0 0\n  Qidong        0 0 1 0 0 0\n  Qiyang        0 0 1 0 0 0\n  Rucheng       0 1 0 0 0 0\n  Sangzhi       0 1 0 0 0 0\n  Shaodong      0 0 0 0 1 0\n  Shaoshan      0 0 0 0 1 0\n  Shaoyang      0 0 0 1 0 0\n  Shimen        1 0 0 0 0 0\n  Shuangfeng    0 0 0 0 0 1\n  Shuangpai     0 0 0 1 0 0\n  Suining       0 0 0 0 1 0\n  Taojiang      0 1 0 0 0 0\n  Taoyuan       0 1 0 0 0 0\n  Tongdao       0 1 0 0 0 0\n  Wangcheng     0 0 0 1 0 0\n  Wugang        0 0 1 0 0 0\n  Xiangtan      0 0 0 1 0 0\n  Xiangxiang    0 0 0 0 1 0\n  Xiangyin      0 0 0 1 0 0\n  Xinhua        0 0 0 0 1 0\n  Xinhuang      1 0 0 0 0 0\n  Xinning       0 1 0 0 0 0\n  Xinshao       0 0 0 0 0 1\n  Xintian       0 0 0 0 1 0\n  Xupu          0 1 0 0 0 0\n  Yanling       0 0 1 0 0 0\n  Yizhang       1 0 0 0 0 0\n  Yongshun      0 0 0 1 0 0\n  Yongxing      0 0 0 1 0 0\n  You           0 0 0 1 0 0\n  Yuanjiang     0 0 0 0 1 0\n  Yuanling      1 0 0 0 0 0\n  Yueyang       0 0 1 0 0 0\n  Zhijiang      0 0 0 0 1 0\n  Zhongfang     0 0 0 1 0 0\n  Zhuzhou       0 0 0 0 1 0\n  Zixing        0 0 1 0 0 0\n\n\n\nn_comp <- n.comp.nb(wm_d62)\nn_comp$nc\n\n[1] 1\n\n\n\ntable(n_comp$comp.id)\n\n\n 1 \n88 \n\n\n\nPlotting fixed distance weight matrix\n\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_d62, coords, add=TRUE)\nplot(k1, coords, add=TRUE, col=\"red\", length=0.08)\n\n\n\n\nThe red lines show the links of 1st nearest neighbors and the black lines show the links of neighbors within the cut-off distance of 62km.\nAlternatively, we can plot both of them next to each other by using the code chunk below.\n\npar(mfrow=c(1,2))\nplot(hunan$geometry, border=\"lightgrey\")\nplot(k1, coords, add=TRUE, col=\"red\", length=0.08, main=\"1st nearest neighbours\")\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_d62, coords, add=TRUE, pch = 19, cex = 0.6, main=\"Distance link\")\n\n\n\n\n\n\n\nComputing adaptive distance weight matrix\nRemember about distance weight matrix.\n\nMore dense areas have more neighbors.\nLess dense areas have less neighbors.\nHaving many neighbors smoothens the relationship across all neighbors in the area.\n\nIt is possible to control the numbers of neighbors directly using k-nearest neighbors, either accepting asymmetric neighbors or imposing symmetry.\n\nknn6 <- knn2nb(knearneigh(coords, k=6))\nknn6\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 528 \nPercentage nonzero weights: 6.818182 \nAverage number of links: 6 \nNon-symmetric neighbours list\n\n\nDisplay knn6 content. Each county has 6 neighbors because we set k-nearest neighbors with k = 6.\n\nstr(knn6)\n\nList of 88\n $ : int [1:6] 2 3 4 5 57 64\n $ : int [1:6] 1 3 57 58 78 85\n $ : int [1:6] 1 2 4 5 57 85\n $ : int [1:6] 1 3 5 6 69 85\n $ : int [1:6] 1 3 4 6 69 85\n $ : int [1:6] 3 4 5 69 75 85\n $ : int [1:6] 9 66 67 71 74 84\n $ : int [1:6] 9 46 47 78 80 86\n $ : int [1:6] 8 46 66 68 84 86\n $ : int [1:6] 16 19 22 70 72 73\n $ : int [1:6] 10 14 16 17 70 72\n $ : int [1:6] 13 15 60 61 63 83\n $ : int [1:6] 12 15 60 61 63 83\n $ : int [1:6] 11 15 16 17 72 83\n $ : int [1:6] 12 13 14 17 60 83\n $ : int [1:6] 10 11 17 22 72 83\n $ : int [1:6] 10 11 14 16 72 83\n $ : int [1:6] 20 22 23 63 77 83\n $ : int [1:6] 10 20 21 73 74 82\n $ : int [1:6] 18 19 21 22 23 82\n $ : int [1:6] 19 20 35 74 82 86\n $ : int [1:6] 10 16 18 19 20 83\n $ : int [1:6] 18 20 41 77 79 82\n $ : int [1:6] 25 28 31 52 54 81\n $ : int [1:6] 24 28 31 33 54 81\n $ : int [1:6] 25 27 29 33 42 81\n $ : int [1:6] 26 29 30 37 42 81\n $ : int [1:6] 24 25 33 49 52 54\n $ : int [1:6] 26 27 37 42 43 81\n $ : int [1:6] 26 27 28 33 49 81\n $ : int [1:6] 24 25 36 39 40 54\n $ : int [1:6] 24 31 50 54 55 56\n $ : int [1:6] 25 26 28 30 49 81\n $ : int [1:6] 36 40 41 45 56 80\n $ : int [1:6] 21 41 46 47 80 82\n $ : int [1:6] 31 34 40 45 56 80\n $ : int [1:6] 26 27 29 42 43 44\n $ : int [1:6] 23 43 44 62 77 79\n $ : int [1:6] 25 40 42 43 44 81\n $ : int [1:6] 31 36 39 43 45 79\n $ : int [1:6] 23 35 45 79 80 82\n $ : int [1:6] 26 27 37 39 43 81\n $ : int [1:6] 37 39 40 42 44 79\n $ : int [1:6] 37 38 39 42 43 79\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:6] 8 9 35 47 78 86\n $ : int [1:6] 8 21 35 46 80 86\n $ : int [1:6] 49 50 51 52 53 55\n $ : int [1:6] 28 33 48 51 52 54\n $ : int [1:6] 32 48 51 52 54 55\n $ : int [1:6] 28 48 49 50 52 54\n $ : int [1:6] 28 48 49 50 51 54\n $ : int [1:6] 48 50 51 52 55 75\n $ : int [1:6] 24 28 49 50 51 52\n $ : int [1:6] 32 48 50 52 53 75\n $ : int [1:6] 32 34 36 78 80 85\n $ : int [1:6] 1 2 3 58 64 68\n $ : int [1:6] 2 57 64 66 68 78\n $ : int [1:6] 12 13 60 61 87 88\n $ : int [1:6] 12 13 59 61 63 87\n $ : int [1:6] 12 13 60 62 63 87\n $ : int [1:6] 12 38 61 63 77 87\n $ : int [1:6] 12 18 60 61 62 83\n $ : int [1:6] 1 3 57 58 68 76\n $ : int [1:6] 58 64 66 67 68 76\n $ : int [1:6] 9 58 67 68 76 84\n $ : int [1:6] 7 65 66 68 76 84\n $ : int [1:6] 9 57 58 66 78 84\n $ : int [1:6] 4 5 6 32 75 85\n $ : int [1:6] 10 16 19 22 72 73\n $ : int [1:6] 7 19 73 74 84 86\n $ : int [1:6] 10 11 14 16 17 70\n $ : int [1:6] 10 19 21 70 71 74\n $ : int [1:6] 19 21 71 73 84 86\n $ : int [1:6] 6 32 50 53 55 69\n $ : int [1:6] 58 64 65 66 67 68\n $ : int [1:6] 18 23 38 61 62 63\n $ : int [1:6] 2 8 9 46 58 68\n $ : int [1:6] 38 40 41 43 44 45\n $ : int [1:6] 34 35 36 41 45 47\n $ : int [1:6] 25 26 28 33 39 42\n $ : int [1:6] 19 20 21 23 35 41\n $ : int [1:6] 12 13 15 16 22 63\n $ : int [1:6] 7 9 66 68 71 74\n $ : int [1:6] 2 3 4 5 56 69\n $ : int [1:6] 8 9 21 46 47 74\n $ : int [1:6] 59 60 61 62 63 88\n $ : int [1:6] 59 60 61 62 63 87\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language knearneigh(x = coords, k = 6)\n - attr(*, \"sym\")= logi FALSE\n - attr(*, \"type\")= chr \"knn\"\n - attr(*, \"knn-k\")= num 6\n - attr(*, \"class\")= chr \"nb\"\n\n\n\nPlotting distance based neighbors\n\nplot(hunan$geometry, border=\"lightgrey\")\nplot(knn6, coords, pch = 19, cex = 0.6, add = TRUE, col = \"red\")"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex1/In-class_ex1.html#weights-based-on-idw",
    "href": "In-class_Ex/In-class_Ex1/In-class_ex1.html#weights-based-on-idw",
    "title": "Spatial Weight and Applications",
    "section": "Weights based on IDW",
    "text": "Weights based on IDW\nIDW = Inverse Distance Method.\n\ndist <- nbdists(wm_q, coords, longlat = TRUE)\nids <- lapply(dist, function(x) 1/(x))\nids\n\n[[1]]\n[1] 0.01535405 0.03916350 0.01820896 0.02807922 0.01145113\n\n[[2]]\n[1] 0.01535405 0.01764308 0.01925924 0.02323898 0.01719350\n\n[[3]]\n[1] 0.03916350 0.02822040 0.03695795 0.01395765\n\n[[4]]\n[1] 0.01820896 0.02822040 0.03414741 0.01539065\n\n[[5]]\n[1] 0.03695795 0.03414741 0.01524598 0.01618354\n\n[[6]]\n[1] 0.015390649 0.015245977 0.021748129 0.011883901 0.009810297\n\n[[7]]\n[1] 0.01708612 0.01473997 0.01150924 0.01872915\n\n[[8]]\n[1] 0.02022144 0.03453056 0.02529256 0.01036340 0.02284457 0.01500600 0.01515314\n\n[[9]]\n[1] 0.02022144 0.01574888 0.02109502 0.01508028 0.02902705 0.01502980\n\n[[10]]\n[1] 0.02281552 0.01387777 0.01538326 0.01346650 0.02100510 0.02631658 0.01874863\n[8] 0.01500046\n\n[[11]]\n[1] 0.01882869 0.02243492 0.02247473\n\n[[12]]\n[1] 0.02779227 0.02419652 0.02333385 0.02986130 0.02335429\n\n[[13]]\n[1] 0.02779227 0.02650020 0.02670323 0.01714243\n\n[[14]]\n[1] 0.01882869 0.01233868 0.02098555\n\n[[15]]\n[1] 0.02650020 0.01233868 0.01096284 0.01562226\n\n[[16]]\n[1] 0.02281552 0.02466962 0.02765018 0.01476814 0.01671430\n\n[[17]]\n[1] 0.01387777 0.02243492 0.02098555 0.01096284 0.02466962 0.01593341 0.01437996\n\n[[18]]\n[1] 0.02039779 0.02032767 0.01481665 0.01473691 0.01459380\n\n[[19]]\n[1] 0.01538326 0.01926323 0.02668415 0.02140253 0.01613589 0.01412874\n\n[[20]]\n[1] 0.01346650 0.02039779 0.01926323 0.01723025 0.02153130 0.01469240 0.02327034\n\n[[21]]\n[1] 0.02668415 0.01723025 0.01766299 0.02644986 0.02163800\n\n[[22]]\n[1] 0.02100510 0.02765018 0.02032767 0.02153130 0.01489296\n\n[[23]]\n[1] 0.01481665 0.01469240 0.01401432 0.02246233 0.01880425 0.01530458 0.01849605\n\n[[24]]\n[1] 0.02354598 0.01837201 0.02607264 0.01220154 0.02514180\n\n[[25]]\n[1] 0.02354598 0.02188032 0.01577283 0.01949232 0.02947957\n\n[[26]]\n[1] 0.02155798 0.01745522 0.02212108 0.02220532\n\n[[27]]\n[1] 0.02155798 0.02490625 0.01562326\n\n[[28]]\n[1] 0.01837201 0.02188032 0.02229549 0.03076171 0.02039506\n\n[[29]]\n[1] 0.02490625 0.01686587 0.01395022\n\n[[30]]\n[1] 0.02090587\n\n[[31]]\n[1] 0.02607264 0.01577283 0.01219005 0.01724850 0.01229012 0.01609781 0.01139438\n[8] 0.01150130\n\n[[32]]\n[1] 0.01220154 0.01219005 0.01712515 0.01340413 0.01280928 0.01198216 0.01053374\n[8] 0.01065655\n\n[[33]]\n[1] 0.01949232 0.01745522 0.02229549 0.02090587 0.01979045\n\n[[34]]\n[1] 0.03113041 0.03589551 0.02882915\n\n[[35]]\n[1] 0.01766299 0.02185795 0.02616766 0.02111721 0.02108253 0.01509020\n\n[[36]]\n[1] 0.01724850 0.03113041 0.01571707 0.01860991 0.02073549 0.01680129\n\n[[37]]\n[1] 0.01686587 0.02234793 0.01510990 0.01550676\n\n[[38]]\n[1] 0.01401432 0.02407426 0.02276151 0.01719415\n\n[[39]]\n[1] 0.01229012 0.02172543 0.01711924 0.02629732 0.01896385\n\n[[40]]\n[1] 0.01609781 0.01571707 0.02172543 0.01506473 0.01987922 0.01894207\n\n[[41]]\n[1] 0.02246233 0.02185795 0.02205991 0.01912542 0.01601083 0.01742892\n\n[[42]]\n[1] 0.02212108 0.01562326 0.01395022 0.02234793 0.01711924 0.01836831 0.01683518\n\n[[43]]\n[1] 0.01510990 0.02629732 0.01506473 0.01836831 0.03112027 0.01530782\n\n[[44]]\n[1] 0.01550676 0.02407426 0.03112027 0.01486508\n\n[[45]]\n[1] 0.03589551 0.01860991 0.01987922 0.02205991 0.02107101 0.01982700\n\n[[46]]\n[1] 0.03453056 0.04033752 0.02689769\n\n[[47]]\n[1] 0.02529256 0.02616766 0.04033752 0.01949145 0.02181458\n\n[[48]]\n[1] 0.02313819 0.03370576 0.02289485 0.01630057 0.01818085\n\n[[49]]\n[1] 0.03076171 0.02138091 0.02394529 0.01990000\n\n[[50]]\n[1] 0.01712515 0.02313819 0.02551427 0.02051530 0.02187179\n\n[[51]]\n[1] 0.03370576 0.02138091 0.02873854\n\n[[52]]\n[1] 0.02289485 0.02394529 0.02551427 0.02873854 0.03516672\n\n[[53]]\n[1] 0.01630057 0.01979945 0.01253977\n\n[[54]]\n[1] 0.02514180 0.02039506 0.01340413 0.01990000 0.02051530 0.03516672\n\n[[55]]\n[1] 0.01280928 0.01818085 0.02187179 0.01979945 0.01882298\n\n[[56]]\n[1] 0.01036340 0.01139438 0.01198216 0.02073549 0.01214479 0.01362855 0.01341697\n\n[[57]]\n[1] 0.028079221 0.017643082 0.031423501 0.029114131 0.013520292 0.009903702\n\n[[58]]\n[1] 0.01925924 0.03142350 0.02722997 0.01434859 0.01567192\n\n[[59]]\n[1] 0.01696711 0.01265572 0.01667105 0.01785036\n\n[[60]]\n[1] 0.02419652 0.02670323 0.01696711 0.02343040\n\n[[61]]\n[1] 0.02333385 0.01265572 0.02343040 0.02514093 0.02790764 0.01219751 0.02362452\n\n[[62]]\n[1] 0.02514093 0.02002219 0.02110260\n\n[[63]]\n[1] 0.02986130 0.02790764 0.01407043 0.01805987\n\n[[64]]\n[1] 0.02911413 0.01689892\n\n[[65]]\n[1] 0.02471705\n\n[[66]]\n[1] 0.01574888 0.01726461 0.03068853 0.01954805 0.01810569\n\n[[67]]\n[1] 0.01708612 0.01726461 0.01349843 0.01361172\n\n[[68]]\n[1] 0.02109502 0.02722997 0.03068853 0.01406357 0.01546511\n\n[[69]]\n[1] 0.02174813 0.01645838 0.01419926\n\n[[70]]\n[1] 0.02631658 0.01963168 0.02278487\n\n[[71]]\n[1] 0.01473997 0.01838483 0.03197403\n\n[[72]]\n[1] 0.01874863 0.02247473 0.01476814 0.01593341 0.01963168\n\n[[73]]\n[1] 0.01500046 0.02140253 0.02278487 0.01838483 0.01652709\n\n[[74]]\n[1] 0.01150924 0.01613589 0.03197403 0.01652709 0.01342099 0.02864567\n\n[[75]]\n[1] 0.011883901 0.010533736 0.012539774 0.018822977 0.016458383 0.008217581\n\n[[76]]\n[1] 0.01352029 0.01434859 0.01689892 0.02471705 0.01954805 0.01349843 0.01406357\n\n[[77]]\n[1] 0.014736909 0.018804247 0.022761507 0.012197506 0.020022195 0.014070428\n[7] 0.008440896\n\n[[78]]\n[1] 0.02323898 0.02284457 0.01508028 0.01214479 0.01567192 0.01546511 0.01140779\n\n[[79]]\n[1] 0.01530458 0.01719415 0.01894207 0.01912542 0.01530782 0.01486508 0.02107101\n\n[[80]]\n[1] 0.01500600 0.02882915 0.02111721 0.01680129 0.01601083 0.01982700 0.01949145\n[8] 0.01362855\n\n[[81]]\n[1] 0.02947957 0.02220532 0.01150130 0.01979045 0.01896385 0.01683518\n\n[[82]]\n[1] 0.02327034 0.02644986 0.01849605 0.02108253 0.01742892\n\n[[83]]\n[1] 0.023354289 0.017142433 0.015622258 0.016714303 0.014379961 0.014593799\n[7] 0.014892965 0.018059871 0.008440896\n\n[[84]]\n[1] 0.01872915 0.02902705 0.01810569 0.01361172 0.01342099 0.01297994\n\n[[85]]\n [1] 0.011451133 0.017193502 0.013957649 0.016183544 0.009810297 0.010656545\n [7] 0.013416965 0.009903702 0.014199260 0.008217581 0.011407794\n\n[[86]]\n[1] 0.01515314 0.01502980 0.01412874 0.02163800 0.01509020 0.02689769 0.02181458\n[8] 0.02864567 0.01297994\n\n[[87]]\n[1] 0.01667105 0.02362452 0.02110260 0.02058034\n\n[[88]]\n[1] 0.01785036 0.02058034\n\n\n\nRow-standardized weights matrix\nDrawback of weight matrix method:\n\nThe polygons along the edges of the study area will base their lagged values on fewer polygons thus potentially over- or under-estimating the true nature of the spatial autocorrelation in the data. For this example, we’ll stick with the style=“W” option for simplicity’s sake but note that other more robust options are available, notably style=“B”.\n\n\nrswm_q <- nb2listw(wm_q, style=\"W\", zero.policy = TRUE)\nrswm_q\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n\n\nSee the weight of polygon four’s neighbors.\n\nrswm_q$weights[10]\n\n[[1]]\n[1] 0.125 0.125 0.125 0.125 0.125 0.125 0.125 0.125\n\n\nEach neighbor is assigned a value of 0.125 of the total weight.\nRow standardized distance weight matrix.\n\nrswm_ids <- nb2listw(wm_q, glist=ids, style=\"B\", zero.policy=TRUE)\nrswm_ids\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: B \nWeights constants summary:\n   n   nn       S0        S1     S2\nB 88 7744 8.786867 0.3776535 3.8137\n\n\n\nrswm_ids$weights[1]\n\n[[1]]\n[1] 0.01535405 0.03916350 0.01820896 0.02807922 0.01145113\n\n\n\nsummary(unlist(rswm_ids$weights))\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n0.008218 0.015088 0.018739 0.019614 0.022823 0.040338 \n\n\n\nsummary(unlist(rswm_ids$weights))\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n0.008218 0.015088 0.018739 0.019614 0.022823 0.040338"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex1/In-class_ex1.html#application-of-spatial-weight-matrix",
    "href": "In-class_Ex/In-class_Ex1/In-class_ex1.html#application-of-spatial-weight-matrix",
    "title": "Spatial Weight and Applications",
    "section": "Application of Spatial Weight Matrix",
    "text": "Application of Spatial Weight Matrix\n\nSpatial lag with row-standardized weights\nWe’ll compute the average neighbor GDPPC value for each polygon. These values are often referred to as spatially lagged values.\n\nGDPPC.lag <- lag.listw(rswm_q, hunan$GDPPC)\nGDPPC.lag\n\n [1] 24847.20 22724.80 24143.25 27737.50 27270.25 21248.80 43747.00 33582.71\n [9] 45651.17 32027.62 32671.00 20810.00 25711.50 30672.33 33457.75 31689.20\n[17] 20269.00 23901.60 25126.17 21903.43 22718.60 25918.80 20307.00 20023.80\n[25] 16576.80 18667.00 14394.67 19848.80 15516.33 20518.00 17572.00 15200.12\n[33] 18413.80 14419.33 24094.50 22019.83 12923.50 14756.00 13869.80 12296.67\n[41] 15775.17 14382.86 11566.33 13199.50 23412.00 39541.00 36186.60 16559.60\n[49] 20772.50 19471.20 19827.33 15466.80 12925.67 18577.17 14943.00 24913.00\n[57] 25093.00 24428.80 17003.00 21143.75 20435.00 17131.33 24569.75 23835.50\n[65] 26360.00 47383.40 55157.75 37058.00 21546.67 23348.67 42323.67 28938.60\n[73] 25880.80 47345.67 18711.33 29087.29 20748.29 35933.71 15439.71 29787.50\n[81] 18145.00 21617.00 29203.89 41363.67 22259.09 44939.56 16902.00 16930.00\n\n\nRetrieve the GDPPC of the areas.\n\nnb1 <- wm_q[[1]]\nnb1 <- hunan$GDPPC[nb1]\nnb1\n\n[1] 20981 34592 24473 21311 22879\n\n\nAppend the spatially lag GDPPC values onto hunan sf data frame.\n\nlag.list <- list(hunan$NAME_3, lag.listw(rswm_q, hunan$GDPPC))\nlag.res <- as.data.frame(lag.list)\ncolnames(lag.res) <- c(\"NAME_3\", \"lag GDPPC\")\nhunan <- left_join(hunan,lag.res)\n\nJoining, by = \"NAME_3\"\n\n\nDisplay the average neighboring income values (stored in the Inc.lag object) for each county.\n\nhead(hunan)\n\nSimple feature collection with 6 features and 36 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 110.4922 ymin: 28.61762 xmax: 112.3013 ymax: 30.12812\nGeodetic CRS:  WGS 84\n   NAME_2  ID_3  NAME_3   ENGTYPE_3 Shape_Leng Shape_Area  County    City\n1 Changde 21098 Anxiang      County   1.869074 0.10056190 Anxiang Changde\n2 Changde 21100 Hanshou      County   2.360691 0.19978745 Hanshou Changde\n3 Changde 21101  Jinshi County City   1.425620 0.05302413  Jinshi Changde\n4 Changde 21102      Li      County   3.474325 0.18908121      Li Changde\n5 Changde 21103   Linli      County   2.289506 0.11450357   Linli Changde\n6 Changde 21104  Shimen      County   4.171918 0.37194707  Shimen Changde\n  avg_wage deposite     FAI Gov_Rev Gov_Exp     GDP GDPPC     GIO   Loan  NIPCR\n1    31935   5517.2  3541.0  243.64  1779.5 12482.0 23667  5108.9 2806.9 7693.7\n2    32265   7979.0  8665.0  386.13  2062.4 15788.0 20981 13491.0 4550.0 8269.9\n3    28692   4581.7  4777.0  373.31  1148.4  8706.9 34592 10935.0 2242.0 8169.9\n4    32541  13487.0 16066.0  709.61  2459.5 20322.0 24473 18402.0 6748.0 8377.0\n5    32667    564.1  7781.2  336.86  1538.7 10355.0 25554  8214.0  358.0 8143.1\n6    33261   8334.4 10531.0  548.33  2178.8 16293.0 27137 17795.0 6026.5 6156.0\n   Bed    Emp  EmpR EmpRT Pri_Stu Sec_Stu Household Household_R NOIP Pop_R\n1 1931 336.39 270.5 205.9  19.584  17.819     148.1       135.4   53 346.0\n2 2560 456.78 388.8 246.7  42.097  33.029     240.2       208.7   95 553.2\n3  848 122.78  82.1  61.7   8.723   7.592      81.9        43.7   77  92.4\n4 2038 513.44 426.8 227.1  38.975  33.938     268.5       256.0   96 539.7\n5 1440 307.36 272.2 100.8  23.286  18.943     129.1       157.2   99 246.6\n6 2502 392.05 329.6 193.8  29.245  26.104     190.6       184.7  122 399.2\n    RSCG Pop_T    Agri Service Disp_Inc      RORP    ROREmp lag GDPPC\n1 3957.9 528.3 4524.41   14100    16610 0.6549309 0.8041262  24847.20\n2 4460.5 804.6 6545.35   17727    18925 0.6875466 0.8511756  22724.80\n3 3683.0 251.8 2562.46    7525    19498 0.3669579 0.6686757  24143.25\n4 7110.2 832.5 7562.34   53160    18985 0.6482883 0.8312558  27737.50\n5 3604.9 409.3 3583.91    7031    18604 0.6024921 0.8856065  27270.25\n6 6490.7 600.5 5266.51    6981    19275 0.6647794 0.8407091  21248.80\n                        geometry\n1 POLYGON ((112.0625 29.75523...\n2 POLYGON ((112.2288 29.11684...\n3 POLYGON ((111.8927 29.6013,...\n4 POLYGON ((111.3731 29.94649...\n5 POLYGON ((111.6324 29.76288...\n6 POLYGON ((110.8825 30.11675...\n\n\nPlot GDPPC and GDPPC spatial lag.\n\ngdppc <- qtm(hunan, \"GDPPC\")+\n  tm_layout(legend.text.size = 0.4)\nlag_gdppc <- qtm(hunan, \"lag GDPPC\")+\n  tm_layout(legend.text.size = 0.4)\ntmap_arrange(gdppc, lag_gdppc, asp=1, ncol=2)\n\n\n\n\n\n\nSpatial lag as a sum of neighboring values\n\nb_weights <- lapply(wm_q, function(x) 0*x + 1)\nb_weights2 <- nb2listw(wm_q, \n                       glist = b_weights, \n                       style = \"B\")\nb_weights2\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: B \nWeights constants summary:\n   n   nn  S0  S1    S2\nB 88 7744 448 896 10224\n\n\nUse lag.listw to compute a lag variable from weight and GDPPC.\n\nlag_sum <- list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))\nlag.res <- as.data.frame(lag_sum)\ncolnames(lag.res) <- c(\"NAME_3\", \"lag_sum GDPPC\")\n\nExamine the result.\n\nlag_sum\n\n[[1]]\n [1] \"Anxiang\"       \"Hanshou\"       \"Jinshi\"        \"Li\"           \n [5] \"Linli\"         \"Shimen\"        \"Liuyang\"       \"Ningxiang\"    \n [9] \"Wangcheng\"     \"Anren\"         \"Guidong\"       \"Jiahe\"        \n[13] \"Linwu\"         \"Rucheng\"       \"Yizhang\"       \"Yongxing\"     \n[17] \"Zixing\"        \"Changning\"     \"Hengdong\"      \"Hengnan\"      \n[21] \"Hengshan\"      \"Leiyang\"       \"Qidong\"        \"Chenxi\"       \n[25] \"Zhongfang\"     \"Huitong\"       \"Jingzhou\"      \"Mayang\"       \n[29] \"Tongdao\"       \"Xinhuang\"      \"Xupu\"          \"Yuanling\"     \n[33] \"Zhijiang\"      \"Lengshuijiang\" \"Shuangfeng\"    \"Xinhua\"       \n[37] \"Chengbu\"       \"Dongan\"        \"Dongkou\"       \"Longhui\"      \n[41] \"Shaodong\"      \"Suining\"       \"Wugang\"        \"Xinning\"      \n[45] \"Xinshao\"       \"Shaoshan\"      \"Xiangxiang\"    \"Baojing\"      \n[49] \"Fenghuang\"     \"Guzhang\"       \"Huayuan\"       \"Jishou\"       \n[53] \"Longshan\"      \"Luxi\"          \"Yongshun\"      \"Anhua\"        \n[57] \"Nan\"           \"Yuanjiang\"     \"Jianghua\"      \"Lanshan\"      \n[61] \"Ningyuan\"      \"Shuangpai\"     \"Xintian\"       \"Huarong\"      \n[65] \"Linxiang\"      \"Miluo\"         \"Pingjiang\"     \"Xiangyin\"     \n[69] \"Cili\"          \"Chaling\"       \"Liling\"        \"Yanling\"      \n[73] \"You\"           \"Zhuzhou\"       \"Sangzhi\"       \"Yueyang\"      \n[77] \"Qiyang\"        \"Taojiang\"      \"Shaoyang\"      \"Lianyuan\"     \n[81] \"Hongjiang\"     \"Hengyang\"      \"Guiyang\"       \"Changsha\"     \n[85] \"Taoyuan\"       \"Xiangtan\"      \"Dao\"           \"Jiangyong\"    \n\n[[2]]\n [1] 124236 113624  96573 110950 109081 106244 174988 235079 273907 256221\n[11]  98013 104050 102846  92017 133831 158446 141883 119508 150757 153324\n[21] 113593 129594 142149 100119  82884  74668  43184  99244  46549  20518\n[31] 140576 121601  92069  43258 144567 132119  51694  59024  69349  73780\n[41]  94651 100680  69398  52798 140472 118623 180933  82798  83090  97356\n[51]  59482  77334  38777 111463  74715 174391 150558 122144  68012  84575\n[61] 143045  51394  98279  47671  26360 236917 220631 185290  64640  70046\n[71] 126971 144693 129404 284074 112268 203611 145238 251536 108078 238300\n[81] 108870 108085 262835 248182 244850 404456  67608  33860\n\n\nSpatial lag as a sum of neighboring values calculate the values caused by nearby areas affecting each other on the variable observed.\n\nhunan <- left_join(hunan, lag.res)\n\nJoining, by = \"NAME_3\"\n\n\nPlot both the GDPPC and Spatial Lag Sum GDPPC.\n\ngdppc <- qtm(hunan, \"GDPPC\")+\n  tm_layout(legend.text.size = 0.45)\nlag_sum_gdppc <- qtm(hunan, \"lag_sum GDPPC\")+\n  tm_layout(legend.text.size = 0.45)\ntmap_arrange(gdppc, lag_sum_gdppc, asp=1, ncol=2)\n\n\n\n\n\n\nSpatial window average\n\nwm_q1 <- wm_q\n\nThe spatial window average uses row-standardized weights and includes the diagonal element. To do this in R, we need to go back to the neighbors structure and add the diagonal element before assigning weights. To begin we assign k6 to a new variable because we will directly alter its structure to add the diagonal elements. Then we add the diagonal element.\n\ninclude.self(wm_q1)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 536 \nPercentage nonzero weights: 6.921488 \nAverage number of links: 6.090909 \n\n\nObtain weight.\n\nwm_q1 <- nb2listw(wm_q1)\nwm_q1\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n\n\nCreate the lag variable from our weight structure and GDPPC variable.\n\nlag_w_avg_gpdpc <- lag.listw(wm_q1, \n                             hunan$GDPPC)\nlag_w_avg_gpdpc\n\n [1] 24847.20 22724.80 24143.25 27737.50 27270.25 21248.80 43747.00 33582.71\n [9] 45651.17 32027.62 32671.00 20810.00 25711.50 30672.33 33457.75 31689.20\n[17] 20269.00 23901.60 25126.17 21903.43 22718.60 25918.80 20307.00 20023.80\n[25] 16576.80 18667.00 14394.67 19848.80 15516.33 20518.00 17572.00 15200.12\n[33] 18413.80 14419.33 24094.50 22019.83 12923.50 14756.00 13869.80 12296.67\n[41] 15775.17 14382.86 11566.33 13199.50 23412.00 39541.00 36186.60 16559.60\n[49] 20772.50 19471.20 19827.33 15466.80 12925.67 18577.17 14943.00 24913.00\n[57] 25093.00 24428.80 17003.00 21143.75 20435.00 17131.33 24569.75 23835.50\n[65] 26360.00 47383.40 55157.75 37058.00 21546.67 23348.67 42323.67 28938.60\n[73] 25880.80 47345.67 18711.33 29087.29 20748.29 35933.71 15439.71 29787.50\n[81] 18145.00 21617.00 29203.89 41363.67 22259.09 44939.56 16902.00 16930.00\n\n\nConvert the lag variable list into a data frame.\n\nlag.list.wm_q1 <- list(hunan$NAME_3, lag.listw(wm_q1, hunan$GDPPC))\nlag_wm_q1.res <- as.data.frame(lag.list.wm_q1)\ncolnames(lag_wm_q1.res) <- c(\"NAME_3\", \"lag_window_avg GDPPC\")\n\n\nhunan <- left_join(hunan, lag_wm_q1.res)\n\nJoining, by = \"NAME_3\"\n\n\nPlot lag window average GDPPC map.\n\ngdppc <- qtm(hunan, \"GDPPC\")+\n  tm_layout(legend.text.size = 0.45)\nw_avg_gdppc <- qtm(hunan, \"lag_window_avg GDPPC\")+\n  tm_layout(legend.text.size = 0.45)\ntmap_arrange(gdppc, w_avg_gdppc, asp=1, ncol=2)\n\n\n\n\n\n\nSpatial window sum\nThe spatial window sum is the counter part of the window average, but without using row-standardized weights.\n\nwm_q1 <- wm_q\ninclude.self(wm_q1)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 536 \nPercentage nonzero weights: 6.921488 \nAverage number of links: 6.090909 \n\n\nCompare with wm_q1.\n\nwm_q1\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\n\nAssign binary weight to the neighbor structure.\n\nb_weights <- lapply(wm_q1, function(x) 0*x + 1)\nb_weights[1]\n\n[[1]]\n[1] 1 1 1 1 1\n\n\nExplicitly assign weight value.\n\nb_weights2 <- nb2listw(wm_q1, \n                       glist = b_weights, \n                       style = \"B\")\nb_weights2\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: B \nWeights constants summary:\n   n   nn  S0  S1    S2\nB 88 7744 448 896 10224\n\n\nCompute the lag variable.\n\nw_sum_gdppc <- list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))\nw_sum_gdppc\n\n[[1]]\n [1] \"Anxiang\"       \"Hanshou\"       \"Jinshi\"        \"Li\"           \n [5] \"Linli\"         \"Shimen\"        \"Liuyang\"       \"Ningxiang\"    \n [9] \"Wangcheng\"     \"Anren\"         \"Guidong\"       \"Jiahe\"        \n[13] \"Linwu\"         \"Rucheng\"       \"Yizhang\"       \"Yongxing\"     \n[17] \"Zixing\"        \"Changning\"     \"Hengdong\"      \"Hengnan\"      \n[21] \"Hengshan\"      \"Leiyang\"       \"Qidong\"        \"Chenxi\"       \n[25] \"Zhongfang\"     \"Huitong\"       \"Jingzhou\"      \"Mayang\"       \n[29] \"Tongdao\"       \"Xinhuang\"      \"Xupu\"          \"Yuanling\"     \n[33] \"Zhijiang\"      \"Lengshuijiang\" \"Shuangfeng\"    \"Xinhua\"       \n[37] \"Chengbu\"       \"Dongan\"        \"Dongkou\"       \"Longhui\"      \n[41] \"Shaodong\"      \"Suining\"       \"Wugang\"        \"Xinning\"      \n[45] \"Xinshao\"       \"Shaoshan\"      \"Xiangxiang\"    \"Baojing\"      \n[49] \"Fenghuang\"     \"Guzhang\"       \"Huayuan\"       \"Jishou\"       \n[53] \"Longshan\"      \"Luxi\"          \"Yongshun\"      \"Anhua\"        \n[57] \"Nan\"           \"Yuanjiang\"     \"Jianghua\"      \"Lanshan\"      \n[61] \"Ningyuan\"      \"Shuangpai\"     \"Xintian\"       \"Huarong\"      \n[65] \"Linxiang\"      \"Miluo\"         \"Pingjiang\"     \"Xiangyin\"     \n[69] \"Cili\"          \"Chaling\"       \"Liling\"        \"Yanling\"      \n[73] \"You\"           \"Zhuzhou\"       \"Sangzhi\"       \"Yueyang\"      \n[77] \"Qiyang\"        \"Taojiang\"      \"Shaoyang\"      \"Lianyuan\"     \n[81] \"Hongjiang\"     \"Hengyang\"      \"Guiyang\"       \"Changsha\"     \n[85] \"Taoyuan\"       \"Xiangtan\"      \"Dao\"           \"Jiangyong\"    \n\n[[2]]\n [1] 124236 113624  96573 110950 109081 106244 174988 235079 273907 256221\n[11]  98013 104050 102846  92017 133831 158446 141883 119508 150757 153324\n[21] 113593 129594 142149 100119  82884  74668  43184  99244  46549  20518\n[31] 140576 121601  92069  43258 144567 132119  51694  59024  69349  73780\n[41]  94651 100680  69398  52798 140472 118623 180933  82798  83090  97356\n[51]  59482  77334  38777 111463  74715 174391 150558 122144  68012  84575\n[61] 143045  51394  98279  47671  26360 236917 220631 185290  64640  70046\n[71] 126971 144693 129404 284074 112268 203611 145238 251536 108078 238300\n[81] 108870 108085 262835 248182 244850 404456  67608  33860\n\n\nConvert the lag variable list into a data frame.\n\nw_sum_gdppc.res <- as.data.frame(w_sum_gdppc)\ncolnames(w_sum_gdppc.res) <- c(\"NAME_3\", \"w_sum GDPPC\")\n\n\nhunan <- left_join(hunan, w_sum_gdppc.res)\n\nJoining, by = \"NAME_3\"\n\ngdppc <- qtm(hunan, \"GDPPC\")+\n  tm_layout(legend.text.size = 0.45)\nw_sum_gdppc <- qtm(hunan, \"w_sum GDPPC\")+\n  tm_layout(legend.text.size = 0.45)\ntmap_arrange(gdppc, w_sum_gdppc, asp=1, ncol=2)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex02.html",
    "href": "Hands-on_Ex/Hands-on_Ex02.html",
    "title": "Global and Local Measures of Spatial Autocorrelation",
    "section": "",
    "text": "This exercise provide the steps of computing the Global and Local Measures of Spatial Autocorrelation using spdep package."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex02.html#getting-started",
    "href": "Hands-on_Ex/Hands-on_Ex02.html#getting-started",
    "title": "Global and Local Measures of Spatial Autocorrelation",
    "section": "Getting Started",
    "text": "Getting Started\n\nThe analytical question\nWe may ask, is a character or attribute evenly distributed across areas or regions? If they are not, then is there a sign of spatial clustering, and if yes, where are the clusters? Those questions can be applied to a wide range of domains: development planning of city councils, shop outlet location setting of a fashion chain, examining the habitat clusters of a certain plant species, etc.\nIn this case study, we are interested to examine the spatial pattern of a selected development indicator (i.e. GDP per capita) of Hunan Provice, People Republic of China.\n\n\nThe study area and data\nTwo data sets will be used in this hands-on exercise, they are:\n\nHunan province administrative boundary layer at county level. This is a geospatial data set in ESRI shapefile format.\nHunan_2012.csv: This csv file contains selected Hunan’s local development indicators in 2012.\n\nWe will reuse the data that we exercised in the In-class Exercise 2 - Spatial Weights and Application segment of this website.\n\n\nSetting the analytical tools\nFirst, we load the necessary R packages.\n\npacman::p_load(sf, spdep, tmap, tidyverse)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01.html",
    "href": "Hands-on_Ex/Hands-on_Ex01.html",
    "title": "Geospatial Wrangling and Choropleth Mapping with R",
    "section": "",
    "text": "In this hands-on exercise, I learn how to import and wrangle geospatial data using appropriate R packages.\n\n\n\nThe code chunk below installs and loads sf and tidyverse.\nNotes: Make sure you imported the pacman package before running the code below.\n\npacman::p_load(sf, tidyverse)\n\n\n\n\nBefore importing anything, download the data zip file(s), unzip, and put them into the folder inside the directory of your page. Then create a Quarto document within that folder. The Quarto document and the data files need to be in the same folder, or you need to clarify the path to the data file while running the code below.\n\n\nNotes: You need to save your working R document as an qmd file before you can run the code below.\n\nmpsz <- st_read(dsn = \"data/geospatial\", layer = \"MP14_SUBZONE_WEB_PL\")\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/Hands-on_Ex/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\n\n\n\n\nRun the code chunk below.\n\ncyclingpath <- st_read(dsn = \"data/geospatial\", layer = \"CyclingPath\")\n\nReading layer `CyclingPath' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/Hands-on_Ex/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 1625 features and 2 fields\nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: 12711.19 ymin: 28711.33 xmax: 42626.09 ymax: 48948.15\nProjected CRS: SVY21\n\n\n\n\n\nRun the code chunk below.\n\npreschool <- st_read(\"data/geospatial/pre-schools-location-kml.kml\")\n\nReading layer `PRESCHOOLS_LOCATION' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/Hands-on_Ex/data/geospatial/pre-schools-location-kml.kml' \n  using driver `KML'\nSimple feature collection with 1359 features and 2 fields\nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6824 ymin: 1.248403 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\n\n\n\n\n\n\n\n\nThe type of geometry is multipolygon.\n\nst_geometry(mpsz)\n\nGeometry set for 323 features \nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\nFirst 5 geometries:\n\n\nMULTIPOLYGON (((31495.56 30140.01, 31980.96 296...\n\n\nMULTIPOLYGON (((29092.28 30021.89, 29119.64 300...\n\n\nMULTIPOLYGON (((29932.33 29879.12, 29947.32 298...\n\n\nMULTIPOLYGON (((27131.28 30059.73, 27088.33 297...\n\n\nMULTIPOLYGON (((26451.03 30396.46, 26440.47 303...\n\n\n\n\n\nGlimpse display a sneak peek into the data type and values of the variables. Notice that X_ADDR and Y_ADDR are double type. There are other types like character, integer, and date.\n\nglimpse(mpsz)\n\nRows: 323\nColumns: 16\n$ OBJECTID   <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, …\n$ SUBZONE_NO <int> 1, 1, 3, 8, 3, 7, 9, 2, 13, 7, 12, 6, 1, 5, 1, 1, 3, 2, 2, …\n$ SUBZONE_N  <chr> \"MARINA SOUTH\", \"PEARL'S HILL\", \"BOAT QUAY\", \"HENDERSON HIL…\n$ SUBZONE_C  <chr> \"MSSZ01\", \"OTSZ01\", \"SRSZ03\", \"BMSZ08\", \"BMSZ03\", \"BMSZ07\",…\n$ CA_IND     <chr> \"Y\", \"Y\", \"Y\", \"N\", \"N\", \"N\", \"N\", \"Y\", \"N\", \"N\", \"N\", \"N\",…\n$ PLN_AREA_N <chr> \"MARINA SOUTH\", \"OUTRAM\", \"SINGAPORE RIVER\", \"BUKIT MERAH\",…\n$ PLN_AREA_C <chr> \"MS\", \"OT\", \"SR\", \"BM\", \"BM\", \"BM\", \"BM\", \"SR\", \"QT\", \"QT\",…\n$ REGION_N   <chr> \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENT…\n$ REGION_C   <chr> \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\",…\n$ INC_CRC    <chr> \"5ED7EB253F99252E\", \"8C7149B9EB32EEFC\", \"C35FEFF02B13E0E5\",…\n$ FMEL_UPD_D <date> 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05…\n$ X_ADDR     <dbl> 31595.84, 28679.06, 29654.96, 26782.83, 26201.96, 25358.82,…\n$ Y_ADDR     <dbl> 29220.19, 29782.05, 29974.66, 29933.77, 30005.70, 29991.38,…\n$ SHAPE_Leng <dbl> 5267.381, 3506.107, 1740.926, 3313.625, 2825.594, 4428.913,…\n$ SHAPE_Area <dbl> 1630379.27, 559816.25, 160807.50, 595428.89, 387429.44, 103…\n$ geometry   <MULTIPOLYGON [m]> MULTIPOLYGON (((31495.56 30..., MULTIPOLYGON (…\n\n\n\n\n\nUse n = … to select the number of records to display. Head gives a look at the first few rows of the data frame.\n\nhead(mpsz, n = 5)\n\nSimple feature collection with 5 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 25867.68 ymin: 28369.47 xmax: 32362.39 ymax: 30435.54\nProjected CRS: SVY21\n  OBJECTID SUBZONE_NO      SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N\n1        1          1   MARINA SOUTH    MSSZ01      Y    MARINA SOUTH\n2        2          1   PEARL'S HILL    OTSZ01      Y          OUTRAM\n3        3          3      BOAT QUAY    SRSZ03      Y SINGAPORE RIVER\n4        4          8 HENDERSON HILL    BMSZ08      N     BUKIT MERAH\n5        5          3        REDHILL    BMSZ03      N     BUKIT MERAH\n  PLN_AREA_C       REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1         MS CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84\n2         OT CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06\n3         SR CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96\n4         BM CENTRAL REGION       CR 3775D82C5DDBEFBD 2014-12-05 26782.83\n5         BM CENTRAL REGION       CR 85D9ABEF0A40678F 2014-12-05 26201.96\n    Y_ADDR SHAPE_Leng SHAPE_Area                       geometry\n1 29220.19   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...\n2 29782.05   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...\n3 29974.66   1740.926   160807.5 MULTIPOLYGON (((29932.33 29...\n4 29933.77   3313.625   595428.9 MULTIPOLYGON (((27131.28 30...\n5 30005.70   2825.594   387429.4 MULTIPOLYGON (((26451.03 30...\n\n\n\n\n\n\nWith geospatial data, we can use the plot() function to display them as visual elements. We can use max.plot = … to define the number of plots shown. This data set has 15 plots at the maximum but we only sketch 9 plots here, hence max.plot = 9.\n\nplot(mpsz, max.plot = 9)\n\n\n\n\nWe can choose to plot just one plot using the code chunk below. This is the plot of the sf object, which is the frame of all plots.\n\nplot(st_geometry(mpsz))\n\n\n\n\nOr we can plot and view a specific attribute.\n\nplot(mpsz[\"PLN_AREA_N\"])\n\n\n\n\n\nNotes: plot is only used for a quickly. For high cartographic quality plot, use tmap R package.\n\n\n\n\nWhen we want to project two or more geospatial data sets, it is important to ensure the data sets are projected under the same coordinate system. Projection Transformation is the method of projecting a data frame from one coordinate system to another.\n\n\nIssues to notice: missing coordination or wrongly assigned coordination due to the importing process.\nUsing the code chunk below, we can see the coordinate system of mpsz.\n\nst_crs(mpsz)\n\nCoordinate Reference System:\n  User input: SVY21 \n  wkt:\nPROJCRS[\"SVY21\",\n    BASEGEOGCRS[\"SVY21[WGS84]\",\n        DATUM[\"World Geodetic System 1984\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ID[\"EPSG\",6326]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"Degree\",0.0174532925199433]]],\n    CONVERSION[\"unnamed\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]\n\n\n\nNotice the User input says the data is projected in svy21, but the EPSG code is 9001. This is a wrong EPSG code because the EPSG code for svy21 should be 3414.\n\nWe now assign the correct EPSG code using the code below.\n\nmpsz3414 <- st_set_crs(mpsz, 3414)\n\nWarning: st_crs<- : replacing crs does not reproject data; use st_transform for\nthat\n\n\nR warns us that st_crs does not reproject data. While this is true in case we want to do projection transformation, here we simply want to fix the EPSG code. Therefore, reprojection is not necessary and we can proceed with checking the EPSG of mpsz3414, which shows the correct EPSG code.\n\nst_crs(mpsz3414)\n\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n\n\n\n\n\nNow we inspect the geometry of preschool. It is clear that preschool is projected in the WGS84 coordinate system.\n\nst_geometry(preschool)\n\nGeometry set for 1359 features \nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6824 ymin: 1.248403 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\nFirst 5 geometries:\n\n\nPOINT Z (103.7614 1.308683 0)\n\n\nPOINT Z (103.7536 1.315748 0)\n\n\nPOINT Z (103.7645 1.305078 0)\n\n\nPOINT Z (103.765 1.305239 0)\n\n\nPOINT Z (103.7597 1.315983 0)\n\n\nWe will transform the projection of preschool to svy21 using st_transform.\n\npreschool3414 <- st_transform(preschool, crs = 3414)\n\nNow we can inspect the geometry of preschool3414, which is now projected in svy21 coordinate system.\n\nst_geometry(preschool3414)\n\nGeometry set for 1359 features \nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 11203.01 ymin: 25667.6 xmax: 45404.24 ymax: 49300.88\nz_range:       zmin: 0 zmax: 0\nProjected CRS: SVY21 / Singapore TM\nFirst 5 geometries:\n\n\nPOINT Z (19997.26 32333.17 0)\n\n\nPOINT Z (19126.75 33114.35 0)\n\n\nPOINT Z (20345.12 31934.56 0)\n\n\nPOINT Z (20400.31 31952.36 0)\n\n\nPOINT Z (19810.78 33140.31 0)\n\n\n\nNotes: in Bounding box, the values are greater than 0-360 range of decimal degree commonly used by most of the geographic coordinate systems.\n\n\n\n\n\n\n\nBecause the listings dataset is in the csv format, we use the read.csv() function to import the data into an object called listings, which is a tibble data frame.\n\nlistings <- read.csv(\"data/aspatial/listings.csv\")\n\nTo inspect the data set, instead of using glimpse, now we use list because of the object type.\n\noptions(max.print = 10)\nlist(listings)\n\n[[1]]\n     id name host_id host_name neighbourhood_group neighbourhood latitude\n     longitude room_type price minimum_nights number_of_reviews last_review\n     reviews_per_month calculated_host_listings_count availability_365\n [ reached 'max' / getOption(\"max.print\") -- omitted 4252 rows ]\n\n\nWe can see that listings has 4,252 rows and 16 columns. We are going to use latitude and longitude.\n\nNote that they are in decimal degree format. As a best guess, we will assume that the data is in wgs84 Geographic Coordinate System.\n\n\n\n\nWe now convert listings into a simple feature data frame using st_as_sf().\n\nlistings_sf <- st_as_sf(listings, coords = c(\"longitude\", \"latitude\"), crs = 4326) %>%\n  st_transform(crs = 3414)\n\nNotes\n\n\ncoords argument requires you to provide the column name of the x-coordinates first then followed by the column name of the y-coordinates.\ncrs argument requires you to provide the coordinates system in epsg format. EPSG: 4326 is wgs84 Geographic Coordinate System and EPSG: 3414 is Singapore SVY21 Projected Coordinate System. You can search for other country’s epsg code by referring to epsg.io.\n%>% is used to nest st_transform() to transform the newly created simple feature data frame into svy21 projected coordinates system.\n\n\nAfter the transformation, we can examine the new object listings_sf using glimpse.\n\nglimpse(listings_sf)\n\nRows: 4,252\nColumns: 15\n$ id                             <int> 50646, 71609, 71896, 71903, 275343, 275…\n$ name                           <chr> \"Pleasant Room along Bukit Timah\", \"Ens…\n$ host_id                        <int> 227796, 367042, 367042, 367042, 1439258…\n$ host_name                      <chr> \"Sujatha\", \"Belinda\", \"Belinda\", \"Belin…\n$ neighbourhood_group            <chr> \"Central Region\", \"East Region\", \"East …\n$ neighbourhood                  <chr> \"Bukit Timah\", \"Tampines\", \"Tampines\", …\n$ room_type                      <chr> \"Private room\", \"Private room\", \"Privat…\n$ price                          <int> 80, 178, 81, 81, 52, 40, 72, 41, 49, 49…\n$ minimum_nights                 <int> 90, 90, 90, 90, 14, 14, 90, 8, 14, 14, …\n$ number_of_reviews              <int> 18, 20, 24, 48, 20, 13, 133, 105, 14, 1…\n$ last_review                    <chr> \"2014-07-08\", \"2019-12-28\", \"2014-12-10…\n$ reviews_per_month              <dbl> 0.22, 0.28, 0.33, 0.67, 0.20, 0.16, 1.2…\n$ calculated_host_listings_count <int> 1, 4, 4, 4, 50, 50, 7, 1, 50, 50, 50, 4…\n$ availability_365               <int> 365, 365, 365, 365, 353, 364, 365, 90, …\n$ geometry                       <POINT [m]> POINT (22646.02 35167.9), POINT (…\n\n\n\n\n\n\n\n\nThe scenario\nThe authority is planning to upgrade the exiting cycling path. To do so, they need to acquire 5 metres of reserved land on the both sides of the current cycling path. You are tasked to determine the extend of the land need to be acquired and their total area.\nSolution\nCompute the 5-meter buffers around cycling paths\n\nbuffer_cycling <- st_buffer(cyclingpath, dist = 5, nQuadSegs = 30)\n\nCalculate the area of the buffers as shown in the code chunk below.\n\nbuffer_cycling$AREA <- st_area(buffer_cycling)\n\nLastly, sum() of Base R will be used to derive the total land involved.\n\nsum(buffer_cycling$AREA)\n\n773143.9 [m^2]\n\n\n\n\n\nThe scenario\nA pre-school service group want to find out the numbers of pre-schools in each Planning Subzone.\nThe solution\nThe code chunk below performs two operations at one go. Firstly, identify pre-schools located inside each Planning Subzone by using st_intersects(). Next, length() of Base R is used to calculate numbers of pre-schools that fall inside each planning subzone.\n\nmpsz3414$`PreSch Count` <- lengths(st_intersects(mpsz3414, preschool3414))\n\nNow we check the new PreSch Count field.\n\nsummary(mpsz3414$`PreSch Count`)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  0.000   0.000   2.000   4.207   6.000  37.000 \n\n\nTo list the planning subzone with the most number of pre-school, the top_n() of dplyr package is used as shown in the code chunk below.\n\ntop_n(mpsz3414, 1, `PreSch Count`)\n\nSimple feature collection with 1 feature and 16 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 23449.05 ymin: 46001.23 xmax: 25594.22 ymax: 47996.47\nProjected CRS: SVY21 / Singapore TM\n     OBJECTID SUBZONE_NO SUBZONE_N SUBZONE_C CA_IND PLN_AREA_N PLN_AREA_C\n     REGION_N REGION_C INC_CRC FMEL_UPD_D X_ADDR Y_ADDR SHAPE_Leng SHAPE_Area\n     geometry PreSch Count\n [ reached 'max' / getOption(\"max.print\") -- omitted 1 rows ]\n\n\n\n\n\nFirstly, the code chunk below uses st_area() of sf package to derive the area of each planning subzone.\n\nmpsz3414$Area <- mpsz3414 %>%\n  st_area()\n\nNext, mutate() of dplyr package is used to compute the density by using the code chunk below.\n\nmpsz3414 <- mpsz3414 %>%\n  mutate(`PreSch Density` = `PreSch Count`/Area * 1000000)\n\nResults\n\nsummary(mpsz3414$`PreSch Density`)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  0.000   0.000   2.974   4.076   6.609  29.059 \n\n\n\ntop_n(mpsz3414, 1, `PreSch Density`)\n\nSimple feature collection with 1 feature and 18 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 28896.26 ymin: 28339.16 xmax: 29426.66 ymax: 28685.25\nProjected CRS: SVY21 / Singapore TM\n\n\nWarning in format.data.frame(if (omit) x[seq_len(n0), , drop = FALSE] else x, :\ncorrupt data frame: columns will be truncated or padded with NAs\n\n\n     OBJECTID SUBZONE_NO SUBZONE_N SUBZONE_C CA_IND PLN_AREA_N PLN_AREA_C\n     REGION_N REGION_C INC_CRC FMEL_UPD_D X_ADDR Y_ADDR SHAPE_Leng SHAPE_Area\n     geometry PreSch Count Area PreSch Density\n [ reached 'max' / getOption(\"max.print\") -- omitted 1 rows ]\n\n\n\n\n\n\nFirstly, we will plot a histogram to reveal the distribution of PreSch Density. Conventionally, hist() of R Graphics will be used as shown in the code chunk below.\n\nhist(mpsz3414$`PreSch Density`, main = \"Histogram of School Density\", xlab = \"School Density\")\n\n\n\n\nIn the code chunk below, appropriate ggplot2 functions will be used.\n\nggplot(data=mpsz3414, \n       aes(x= as.numeric(`PreSch Density`)))+\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  labs(title = \"Are pre-school even distributed in Singapore?\",\n       subtitle= \"There are many planning sub-zones with a single pre-school, on the other hand, \\nthere are two planning sub-zones with at least 20 pre-schools\",\n      x = \"Pre-school density (per km sq)\",\n      y = \"Frequency\")\n\n\n\n\n\n\n\nggplot(data = mpsz3414,\n       aes(x = as.numeric(`PreSch Density`), y = as.numeric(`PreSch Count`))) +\n  geom_point() +\n  labs(x = \"Pre-school Density (per km square)\",\n       y = \"Pre-school Count\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01.html#overview-1",
    "href": "Hands-on_Ex/Hands-on_Ex01.html#overview-1",
    "title": "Geospatial Wrangling and Choropleth Mapping with R",
    "section": "Overview",
    "text": "Overview\nChoropleth map is a map showing different colors depending on the value of the attribute that the map is presenting. For example, a map showing population density have different colors for each areas with varying levels of population density."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01.html#getting-started-1",
    "href": "Hands-on_Ex/Hands-on_Ex01.html#getting-started-1",
    "title": "Geospatial Wrangling and Choropleth Mapping with R",
    "section": "Getting Started",
    "text": "Getting Started\nThis exercise will use the tmap R package and four other R packages.\n\nreadr for importing delimited text file,\ntidyr for tidying data,\ndplyr for wrangling data and\nsf for handling geospatial data.\n\nFirst, we load the packages into R Studio.\n\npacman::p_load(sf, tmap, tidyverse)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01.html#importing-data-into-r",
    "href": "Hands-on_Ex/Hands-on_Ex01.html#importing-data-into-r",
    "title": "Geospatial Wrangling and Choropleth Mapping with R",
    "section": "Importing Data into R",
    "text": "Importing Data into R\n\nImporting Geospatial Data into R\nSince we already imported and inspected the MP4_SUBZONE_WEB_PL shapefile as mpsz, we can skip this step.\n\n\nImporting Attribute Data into R\n\npopdata <- read_csv('~/sylvie-le/ISSS624/Hands-on_Ex/data/aspatial/respopagesextod2011to2020.csv')\n\nRows: 984656 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): PA, SZ, AG, Sex, TOD\ndbl (2): Pop, Time\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\n\nData Preparation\n\n\nWe need to prepare a data table with the necessary data points as below.\n\nYOUNG: age group 0 to 4 until age groyup 20 to 24,\nECONOMY ACTIVE: age group 25-29 until age group 60-64,\nAGED: age group 65 and above,\nTOTAL: all age group, and\nDEPENDENCY: the ratio between young and aged against economy active group\n\n\nData Wrangling\nThe functions below is used to wrangle the data as defined above.\n\npopdata2020 <- popdata %>%\n  filter(Time == 2020) %>%\n  group_by(PA, SZ, AG) %>%\n  summarise(`POP` = sum(`Pop`)) %>%\n  ungroup()%>%\n  pivot_wider(names_from=AG, \n              values_from=POP) %>%\n  mutate(YOUNG = rowSums(.[3:6])\n         +rowSums(.[12])) %>%\nmutate(`ECONOMY ACTIVE` = rowSums(.[7:11])+\nrowSums(.[13:15]))%>%\nmutate(`AGED`=rowSums(.[16:21])) %>%\nmutate(`TOTAL`=rowSums(.[3:21])) %>%  \nmutate(`DEPENDENCY` = (`YOUNG` + `AGED`)\n/`ECONOMY ACTIVE`) %>%\n  select(`PA`, `SZ`, `YOUNG`, \n       `ECONOMY ACTIVE`, `AGED`, \n       `TOTAL`, `DEPENDENCY`)\n\n`summarise()` has grouped output by 'PA', 'SZ'. You can override using the\n`.groups` argument.\n\n\n\n\nJoining the attribute data and geospatial data\nBefore we can perform the georelational join, one extra step is required to convert the values in PA and SZ fields to uppercase. This is because the values of PA and SZ fields are made up of upper- and lowercase. On the other, hand the SUBZONE_N and PLN_AREA_N are in uppercase.\nSince funs() was deprecated, we use list() instead.\n\npopdata2020 <- popdata2020 %>%\n  mutate_at(.vars = vars(PA, SZ), \n          .funs = list(toupper)) %>%\n  filter(`ECONOMY ACTIVE` > 0)\n\nAfter that, we conduct a left join of the data using left_join() , to ensure the output to be simple features data frame.\n\nmpsz_pop2020 <- left_join(mpsz, popdata2020,\n                          by = c(\"SUBZONE_N\" = \"SZ\"))\n\nNow we save the new file after creating a new folder called rds in data folder.\n\nwrite_rds(mpsz_pop2020, \"~/sylvie-le/ISSS624/Hands-on_Ex/data/rds/mpszpop2020.rds\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01.html#choropleth-mapping-geospatial-data-using-tmap",
    "href": "Hands-on_Ex/Hands-on_Ex01.html#choropleth-mapping-geospatial-data-using-tmap",
    "title": "Geospatial Wrangling and Choropleth Mapping with R",
    "section": "Choropleth Mapping Geospatial Data Using tmap",
    "text": "Choropleth Mapping Geospatial Data Using tmap\nTwo approaches can be used to prepare thematic map using tmap, they are:\n\nPlotting a thematic map quickly by using qtm().\nPlotting highly customisable thematic map by using tmap elements.\n\n\nMethod 1: Plotting using qtm()\n\ntmap_mode(mode = \"plot\")\n\ntmap mode set to plotting\n\nqtm(mpsz_pop2020, \n    fill = \"DEPENDENCY\")\n\n\n\n\nNotes\n\n\ntmap_mode() with “plot” option is used to produce a static map. For interactive mode, “view” option should be used.\nfill argument is used to map the attribute (i.e. DEPENDENCY)\n\n\n\n\nMethod 2: Creating a choropleth map by using tmap’s elements\nWhile being convenient and short, qtm() does not allow for drawing maps with high cartographic quality. To overcome qtm()’s disadvantage, we can use tmap’s elements.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\",\n          title = \"Dependency ratio\") +\n  tm_layout(main.title = \"Distribution of Dependency Ratio by planning subzone\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar() +\n  tm_grid(alpha =0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\\n and Population data from Department of Statistics DOS\", \n             position = c(\"left\", \"bottom\"))\n\n\n\n\nNext, let’s look at the code and draw the map step by step to understand how each element works.\n\nDrawing a base map\nThe building block of tmap is tm_shape(), which is followed by elements such as tm_fill() and tm_polygons(). We will use tm_polygons() as it allows us to fill the polygons with color as tm_fill() does, and also let us draw the border of the polygons as tm_border().\n\ntm_shape(mpsz_pop2020) +\n  tm_polygons()\n\n\n\n\n\n\nDrawing a choropleth map using tm_polygons()\nNext, we will define how the colors are filled into the map by letting tm_polygons() know the criteria to fill. In this case, the criteria is the variable DEPENDENCY.\n\ntm_shape(mpsz_pop2020)+\n  tm_polygons(\"DEPENDENCY\")\n\n\n\n\nNotes\n\n\nThe default binning to draw the choropleth map is called “pretty”. Refer to sub-section 4.3 for more details.\nThe default color scheme is YlOrRd. Refer to sub-section 4.4 for more details of color schemes.\nBy default, Missing value is filled with gray.\n\n\n\n\nDrawing a choropleth map using tm_fill() and tm_border()\nInstead of using tm_polygons(), we can use tm_fill() and tm_border() instead. The code will be longer but if some day we like to type more, we can opt for this option.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\")\n\n\n\n\nWith just tm_fill(), the map is drawn without the borders between the areas. To add the borders, we combine the code chunk above with tm_borders().\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\") +\n  tm_borders(lwd = 0.1,  alpha = 1)\n\n\n\n\nObserving the map, we see that the border thickness are different that what we achieved with tm_polygons(). This suggests that we can customize border thickness with tm_borders().\nThe argument to customize borders are at below.\n\n\ncol = border colour,\nlwd = border line width. The default is 1, and\nlty = border line type. The default is “solid”.\n\n\n\n\n\nData classification methods of tmap\nData classification is to group a large numbers of observations into ranges or classes. It helps us to better describe the data and present the information we want to highlight, besides other roles.\ntmap provides a total ten data classification methods, namely: fixed, sd, equal, pretty (default), quantile, kmeans, hclust, bclust, fisher, and jenks. Refer to R documentations details on the methods.\nTo define a data classification method, the style argument of tm_fill() or tm_polygons() will be used.\n\nPlotting choropleth maps with built-in classification methods\nUse n = 5 as in the code chunk below to classify the data into 5 classes.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\nThe code below classifies the data using equal classification method.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\nNotice that the distribution of quantile data classification method are more evenly distributed then equal data classification method.\nNext, we will use all of the classification methods and compare the results.\n\nMap Comparison\n\nm1 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"sd\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"SD\")\nm2 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Equal\")\nm3 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"pretty\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Pretty\")\nm4 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Quantile\")\nm5 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"kmeans\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Kmeans\")\nm6 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"hclust\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Hclust\")\nm7 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"bclust\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Bclust\")\nm8 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"fisher\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Fisher\")\nm9 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Jenks\")\n\ntmap_arrange(m1, m2, asp=1, ncol=2)\n\n\n\ntmap_arrange(m3, m4, asp=1, ncol=2)\n\n\n\ntmap_arrange(m5, m6, asp=1, ncol=2)\n\n\n\ntmap_arrange(m7, m8, asp=1, ncol=2)\n\n\n\n\nCommittee Member: 1(1) 2(1) 3(1) 4(1) 5(1) 6(1) 7(1) 8(1) 9(1) 10(1)\nComputing Hierarchical Clustering\n\ntmap_arrange(m9, asp=1, ncol=2)\n\n\n\n\nEach data classification methods provide a different representation of the data. Therefore, we should consider which classification method to best presenting the data, and which classification methods are meaningful to the data. Data presentation can be misleading if we don’t choose carefully.\n\n\n\nPlotting choropleth map with custome break\nFor all the built-in styles, the category breaks are computed internally. In order to override these defaults, the breakpoints can be set explicitly by means of the breaks argument to the tm_fill(). It is important to note that, in tmap the breaks include a minimum and maximum. As a result, in order to end up with n categories, n+1 elements must be specified in the breaks option (the values must be in increasing order).\nBefore we get started, it is always a good practice to get some descriptive statistics on the variable before setting the break points. Code chunk below will be used to compute and display the descriptive statistics of DEPENDENCY field.\n\nsummary(mpsz_pop2020$DEPENDENCY)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n 0.0000  0.6519  0.7025  0.7742  0.7645 19.0000      92 \n\n\nWe set break point at 0.60, 0.70, 0.80, and 0.90 to reflect the quartiles, and include the min and max values as 0 and 100 respectively. Our breaks vector will be c(0, 0.60, 0.70, 0.80, 0.90, 100).\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          breaks = c(0, 0.60, 0.70, 0.80, 0.90, 100)) +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\nColour Scheme\ntmap supports colour ramps either defined by the user or a set of predefined colour ramps from the RColorBrewer package.\n\nUsing ColourBrewer palette\nUsing the palette argument of tm_fill(), we can define the color.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 6,\n          style = \"quantile\",\n          palette = \"Blues\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\nIn this map, the color gets bolder when the value increases. To reverse the color map and make the higher values lighter, we use the prefix - before the color map’s name.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          style = \"quantile\",\n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\nMap Layouts\nMap layout refers to the combination of all map elements like title, legend, scale bar, etc. into a cohensive map.\n\nMap Legend\nWe can customize the legend with multiple arguments using tm_layouts(). A histogram legend can be added using legend.hist. legend.is.portrait determines if the legends are in portrait or landscape mode. Refer to R documentation on tm_fill() for more details of legend settings.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"jenks\", \n          palette = \"Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1) +\n  tm_layout(main.title = \"Distribution of Dependency Ratio by planning subzone \\n(Jenks classification)\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            legend.outside = FALSE,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\nMap style\ntmap_style() is used to set many styles for the map. See Details of tm_layout() for predefined styles.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"classic\")\n\ntmap style set to \"classic\"\n\n\nother available styles are: \"white\", \"gray\", \"natural\", \"cobalt\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"watercolor\" \n\n\n\n\n\n\n\nCartographic Furniture\nBeside map style, tmap also also provides arguments to draw other map furniture such as compass, scale bar and grid lines. Refer to tm_layout()’s documentation for more details on the argument to customize the map.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\",\n          title = \"No. of persons\") +\n  tm_layout(main.title = \"Distribution of Dependency Ratio \\nby planning subzone\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\\n and Population data from Department of Statistics DOS\", \n             position = c(\"left\", \"bottom\"))\n\n\n\n\n\n\n\nDrawing Small Multiple Choropleth Maps\nSmall multiple maps, also referred to as facet maps, are composed of many maps arrange side-by-side, and sometimes stacked vertically.\nIn tmap, small multiple maps can be plotted in three ways:\n\nby assigning multiple values to at least one of the asthetic arguments,\nby defining a group-by variable in tm_facets(), and\nby creating multiple stand-alone maps with tmap_arrange().\n\n\nBy assigning multiple values to at least one of the aesthetic arguments\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(c(\"YOUNG\", \"AGED\"),\n          style = \"equal\", \n          palette = \"Blues\") +\n  tm_layout(legend.position = c(\"right\", \"bottom\")) +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"white\")\n\ntmap style set to \"white\"\n\n\nother available styles are: \"gray\", \"natural\", \"cobalt\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"classic\", \"watercolor\" \n\n\n\n\n\nIn this example, small multiple choropleth maps are created by assigning multiple values to at least one of the aesthetic arguments.\n\ntm_shape(mpsz_pop2020)+ \n  tm_polygons(c(\"DEPENDENCY\",\"AGED\"),\n          style = c(\"equal\", \"quantile\"), \n          palette = list(\"Blues\",\"Greens\")) +\n  tm_layout(legend.position = c(\"right\", \"bottom\"))\n\n\n\n\n\n\nBy defining a group-by variable in tm_facets()\n\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          style = \"quantile\",\n          palette = \"Blues\",\n          thres.poly = 0) + \n  tm_facets(by=\"REGION_N\", \n            free.coords=TRUE, \n            drop.shapes=TRUE) +\n  tm_layout(legend.show = FALSE,\n            title.position = c(\"center\", \"center\"), \n            title.size = 20) +\n  tm_borders(alpha = 0.5)\n\nWarning: The argument drop.shapes has been renamed to drop.units, and is\ntherefore deprecated\n\n\n\n\n\n\n\nBy creating multiple stand-alone maps with tmap_arrange()\n\nyoungmap <- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"YOUNG\", \n              style = \"quantile\", \n              palette = \"Blues\")\n\nagedmap <- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"AGED\", \n              style = \"quantile\", \n              palette = \"Blues\")\n\ntmap_arrange(youngmap, agedmap, asp=1, ncol=2)\n\n\n\n\n\n\n\nMappping Spatial Object Meeting a Selection Criterion\nThis code chunk below filter the areas by the criterion determined below in tm_shape().\n\ntm_shape(mpsz_pop2020[mpsz_pop2020$REGION_N==\"CENTRAL REGION\", ])+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1) +\n  tm_layout(legend.outside = TRUE,\n            legend.height = 0.45, \n            legend.width = 5.0,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n\nWarning in pre_process_gt(x, interactive = interactive, orig_crs =\ngm$shape.orig_crs): legend.width controls the width of the legend within a map.\nPlease use legend.outside.size to control the width of the outside legend"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex02.html#getting-the-data-into-the-r-environment",
    "href": "Hands-on_Ex/Hands-on_Ex02.html#getting-the-data-into-the-r-environment",
    "title": "Global and Local Measures of Spatial Autocorrelation",
    "section": "Getting the Data into the R Environment",
    "text": "Getting the Data into the R Environment\n\nImport shapefile into R environment\nWe import the Hunan shapefile into R using the sf package.\n\nhunan <- st_read(dsn = \"~/sylvie-le/ISSS624/In-class_Ex/In-class_Ex1/dataC/geospatial\", layer = \"Hunan\")\n\nReading layer `Hunan' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/In-class_Ex/In-class_Ex1/dataC/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n\n\n\n\nImport CSV file into R environment\n\nhunan2012 <- read_csv(\"~/sylvie-le/ISSS624/In-class_Ex/In-class_Ex1/dataC/aspatial/Hunan_2012.csv\", show_col_types = FALSE)\n\n\n\nPerform relational join\n\nhunan <- left_join(hunan, hunan2012)\n\nJoining, by = \"County\"\n\n\n\n\nVisualize regional development indicator\nNow we will prepare a choropleth map showing the distribution of GDPPC 2012 in Hunan.\n\nequal <- tm_shape(hunan) +\n  tm_fill(\"GDPPC\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal interval classification\",\n            main.title.size = 1,\n            main.title.position = \"center\",\n            legend.text.size = 0.45)\n\nquantile <- tm_shape(hunan) +\n  tm_fill(\"GDPPC\",\n          n = 5,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal quantile classification\",\n            main.title.size = 1,\n            main.title.position = \"center\",\n            legend.text.size = 0.45)\n\ntmap_arrange(equal, quantile, asp = 1, ncol = 2)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex02.html#global-spatial-autocorrelation",
    "href": "Hands-on_Ex/Hands-on_Ex02.html#global-spatial-autocorrelation",
    "title": "Global and Local Measures of Spatial Autocorrelation",
    "section": "Global Spatial Autocorrelation",
    "text": "Global Spatial Autocorrelation\n\nComputing contiguity spatial weight\nBefore we can compute the global spatial autocorrelation statistics, we need to construct a spatial weights of the study area. The spatial weights is used to define the neighbourhood relationships between the geographical units (i.e. county) in the study area.\n\nwm_q <- poly2nb(hunan, queen = TRUE)\nsummary(wm_q)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n\n\n\n\nRow-standardized weights matrix\n\nrswm_q <- nb2listw(wm_q, style = \"W\", zero.policy = TRUE)\nrswm_q\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n\n\nRefer HERE for an explanation of the code and HERE for documentation on nb2listw().\n\n\nGlobal Spatial Autocorrelation: Moran’s I\n\nMoran’s Test\nWe will perform Moran test using moran.test() from spdep.\n\nmoran.test(hunan$GDPPC,\n           listw = rswm_q,\n           zero.policy = TRUE,\n           na.action = na.omit)\n\n\n    Moran I test under randomisation\n\ndata:  hunan$GDPPC  \nweights: rswm_q    \n\nMoran I statistic standard deviate = 4.7351, p-value = 1.095e-06\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.300749970      -0.011494253       0.004348351 \n\n\nMoran I statistic is approximately 0.3, indicating clustered data. The neighbor observations tend to be similar. p-valu is less than 0.05. Therefore, we reject the null hypothesis H0 of spatial randomness at 95% confidence level.\n\n\nComputing Monte Carlo Moran’s I\nWe will conduct a permutation test for Moran’s I statistic by generating 1,000 simulations.\n\nset.seed(1234) #to prevent the result from changing due to random calculation\nbperm = moran.mc(hunan$GDPPC,\n                 listw = rswm_q,\n                 nsim = 999,\n                 zero.policy = TRUE,\n                 na.action = na.omit)\nbperm\n\n\n    Monte-Carlo simulation of Moran I\n\ndata:  hunan$GDPPC \nweights: rswm_q  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.30075, observed rank = 1000, p-value = 0.001\nalternative hypothesis: greater\n\n\nThe result of 1,000 simulation is similar to the Moran’s I test. p-value is less than 0.05. Therefore, we are confident at 95% level of confidence that the data does not violate Moran’s I assumption of spatial randomness.\n\n\nVisulize Monte Carlo Moran’s I\n\nmean(bperm$res[1:999])\n\n[1] -0.01504572\n\n\n\nvar(bperm$res[1:999])\n\n[1] 0.004371574\n\n\n\nsummary(bperm$res[1:999])\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-0.18339 -0.06168 -0.02125 -0.01505  0.02611  0.27593 \n\n\n\nhist(bperm$res,\n     freq = TRUE,\n     breaks = 20,\n     xlab = \"Simulated Moran's I\")\nabline(v = 0, col = \"red\")\n\n\n\n\nWe can see that I approaches 1, meaning similar values are clustered, corroborated Moran’s I test result.\nWe can use ggplot2 to visualize Monte Carlo Moran’s I. The plot is slightly different because ggplot2 binning algorithm is different from hist binning algorithm.\n\nlibrary(ggplot2)\ndf <- data.frame(bperm$res)\nggplot(df, aes(bperm$res)) +\n  geom_histogram(fill = \"gray\", color = \"black\", closed = \"right\") +\n  scale_x_continuous(breaks = 20) +\n  geom_vline(aes(xintercept = 0), color = \"red\") +\n  labs(title = \"Histogram of bperm$res\", x = \"Simulated Moran's I\", y = \"Frequency\") +\n  theme_bw() +\n  theme(plot.title = element_text(hjust = 0.5))\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\nGlobal Spatial Autocorrelation: Geary’s\nGeary’s C test\n\ngeary.test(hunan$GDPPC, listw = rswm_q)\n\n\n    Geary C test under randomisation\n\ndata:  hunan$GDPPC \nweights: rswm_q \n\nGeary C statistic standard deviate = 3.6108, p-value = 0.0001526\nalternative hypothesis: Expectation greater than statistic\nsample estimates:\nGeary C statistic       Expectation          Variance \n        0.6907223         1.0000000         0.0073364 \n\n\nc-value = 0.69 < 1. Therefore, the data is clustered and neighbor observations tend to be similar. p-value is less than 0.05 and z-score is positive. Therefore, the spatial distribution of high values in the dataset is more spatially clustered than would be expected if underlying spatial processes were truly random.\n\nCompute Monte Carlo Geary’s C\nWe will conduct 1,000 simulations of Geary’s C using geary.mc().\n\nset.seed(1234)\nbperm = geary.mc(hunan$GDPPC,\n                 listw = rswm_q,\n                 nsim = 999)\nbperm\n\n\n    Monte-Carlo simulation of Geary C\n\ndata:  hunan$GDPPC \nweights: rswm_q \nnumber of simulations + 1: 1000 \n\nstatistic = 0.69072, observed rank = 1, p-value = 0.001\nalternative hypothesis: greater\n\n\nThe result of the simulation is also 0.69 with p-value less than 0.05, corroborating the result of Geary’s C test. We can say with 95% confidence that the data does not violate Geary’s C assumption of spatial randomness.\n\n\nVisualizing Monte Carlo Geary’s C\n\nmean(bperm$res)\n\n[1] 1.004089\n\n\n\nvar(bperm$res)\n\n[1] 0.007527444\n\n\n\nsummary(bperm$res)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.6907  0.9501  1.0050  1.0041  1.0594  1.2722 \n\n\n\nhist(bperm$res, freq = TRUE, breaks = 20, xlab = \"Simulated Geary's C\")\nabline(v = 1, col = \"red\")\n\n\n\n\nWe can see that C approaches 0, meaning similar data is clustered."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex02.html#spatial-correlogram",
    "href": "Hands-on_Ex/Hands-on_Ex02.html#spatial-correlogram",
    "title": "Global and Local Measures of Spatial Autocorrelation",
    "section": "Spatial Correlogram",
    "text": "Spatial Correlogram\n\nCompute Moran’s I correlogram\n\nMI_corr <- sp.correlogram(wm_q,\n                          hunan$GDPPC,\n                          order = 6,\n                          method = \"I\",\n                          style = \"W\")\nplot(MI_corr)\n\n\n\n\nBy plotting the output might not allow us to provide complete interpretation. This is because not all autocorrelation values are statistically significant. Hence, it is important for us to examine the full analysis report by printing out the analysis results as in the code chunk below.\n\nprint(MI_corr)\n\nSpatial correlogram for hunan$GDPPC \nmethod: Moran's I\n         estimate expectation   variance standard deviate Pr(I) two sided    \n1 (88)  0.3007500  -0.0114943  0.0043484           4.7351       2.189e-06 ***\n2 (88)  0.2060084  -0.0114943  0.0020962           4.7505       2.029e-06 ***\n3 (88)  0.0668273  -0.0114943  0.0014602           2.0496        0.040400 *  \n4 (88)  0.0299470  -0.0114943  0.0011717           1.2107        0.226015    \n5 (88) -0.1530471  -0.0114943  0.0012440          -4.0134       5.984e-05 ***\n6 (88) -0.1187070  -0.0114943  0.0016791          -2.6164        0.008886 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n\n\nCompute Geary’s C correlogram and plot\n\nCG_corr <- sp.correlogram(wm_q,\n                          hunan$GDPPC,\n                          order = 6,\n                          method = \"C\",\n                          style = \"W\")\nplot(CG_corr)\n\n\n\n\n\nprint(CG_corr)\n\nSpatial correlogram for hunan$GDPPC \nmethod: Geary's C\n        estimate expectation  variance standard deviate Pr(I) two sided    \n1 (88) 0.6907223   1.0000000 0.0073364          -3.6108       0.0003052 ***\n2 (88) 0.7630197   1.0000000 0.0049126          -3.3811       0.0007220 ***\n3 (88) 0.9397299   1.0000000 0.0049005          -0.8610       0.3892612    \n4 (88) 1.0098462   1.0000000 0.0039631           0.1564       0.8757128    \n5 (88) 1.2008204   1.0000000 0.0035568           3.3673       0.0007592 ***\n6 (88) 1.0773386   1.0000000 0.0058042           1.0151       0.3100407    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex02.html#cluster-and-outlier-analysis",
    "href": "Hands-on_Ex/Hands-on_Ex02.html#cluster-and-outlier-analysis",
    "title": "Global and Local Measures of Spatial Autocorrelation",
    "section": "Cluster and Outlier Analysis",
    "text": "Cluster and Outlier Analysis\n\nCompute local Moran’s I\nThe code chunks below are used to compute local Moran’s I of GDPPC2012 at the county level.\n\nfips <- order(hunan$County)\nlocalMI <- localmoran(hunan$GDPPC, rswm_q)\nhead(localMI)\n\n            Ii          E.Ii       Var.Ii        Z.Ii Pr(z != E(Ii))\n1 -0.001468468 -2.815006e-05 4.723841e-04 -0.06626904      0.9471636\n2  0.025878173 -6.061953e-04 1.016664e-02  0.26266425      0.7928094\n3 -0.011987646 -5.366648e-03 1.133362e-01 -0.01966705      0.9843090\n4  0.001022468 -2.404783e-07 5.105969e-06  0.45259801      0.6508382\n5  0.014814881 -6.829362e-05 1.449949e-03  0.39085814      0.6959021\n6 -0.038793829 -3.860263e-04 6.475559e-03 -0.47728835      0.6331568\n\n\nThe code chunk below list the content of the local Moran matrix derived by using printCoefmat().\n\nprintCoefmat(data.frame(localMI[fips,], row.names=hunan$County[fips]), check.names=FALSE)\n\n                       Ii        E.Ii      Var.Ii        Z.Ii Pr.z....E.Ii..\nAnhua         -2.2493e-02 -5.0048e-03  5.8235e-02 -7.2467e-02         0.9422\nAnren         -3.9932e-01 -7.0111e-03  7.0348e-02 -1.4791e+00         0.1391\nAnxiang       -1.4685e-03 -2.8150e-05  4.7238e-04 -6.6269e-02         0.9472\nBaojing        3.4737e-01 -5.0089e-03  8.3636e-02  1.2185e+00         0.2230\nChaling        2.0559e-02 -9.6812e-04  2.7711e-02  1.2932e-01         0.8971\nChangning     -2.9868e-05 -9.0010e-09  1.5105e-07 -7.6828e-02         0.9388\nChangsha       4.9022e+00 -2.1348e-01  2.3194e+00  3.3590e+00         0.0008\nChengbu        7.3725e-01 -1.0534e-02  2.2132e-01  1.5895e+00         0.1119\nChenxi         1.4544e-01 -2.8156e-03  4.7116e-02  6.8299e-01         0.4946\nCili           7.3176e-02 -1.6747e-03  4.7902e-02  3.4200e-01         0.7324\nDao            2.1420e-01 -2.0824e-03  4.4123e-02  1.0297e+00         0.3032\nDongan         1.5210e-01 -6.3485e-04  1.3471e-02  1.3159e+00         0.1882\nDongkou        5.2918e-01 -6.4461e-03  1.0748e-01  1.6338e+00         0.1023\nFenghuang      1.8013e-01 -6.2832e-03  1.3257e-01  5.1198e-01         0.6087\nGuidong       -5.9160e-01 -1.3086e-02  3.7003e-01 -9.5104e-01         0.3416\nGuiyang        1.8240e-01 -3.6908e-03  3.2610e-02  1.0305e+00         0.3028\nGuzhang        2.8466e-01 -8.5054e-03  1.4152e-01  7.7931e-01         0.4358\nHanshou        2.5878e-02 -6.0620e-04  1.0167e-02  2.6266e-01         0.7928\nHengdong       9.9964e-03 -4.9063e-04  6.7742e-03  1.2742e-01         0.8986\nHengnan        2.8064e-02 -3.2160e-04  3.7597e-03  4.6294e-01         0.6434\nHengshan      -5.8201e-03 -3.0437e-05  5.1076e-04 -2.5618e-01         0.7978\nHengyang       6.2997e-02 -1.3046e-03  2.1865e-02  4.3486e-01         0.6637\nHongjiang      1.8790e-01 -2.3019e-03  3.1725e-02  1.0678e+00         0.2856\nHuarong       -1.5389e-02 -1.8667e-03  8.1030e-02 -4.7503e-02         0.9621\nHuayuan        8.3772e-02 -8.5569e-04  2.4495e-02  5.4072e-01         0.5887\nHuitong        2.5997e-01 -5.2447e-03  1.1077e-01  7.9685e-01         0.4255\nJiahe         -1.2431e-01 -3.0550e-03  5.1111e-02 -5.3633e-01         0.5917\nJianghua       2.8651e-01 -3.8280e-03  8.0968e-02  1.0204e+00         0.3076\nJiangyong      2.4337e-01 -2.7082e-03  1.1746e-01  7.1800e-01         0.4728\nJingzhou       1.8270e-01 -8.5106e-04  2.4363e-02  1.1759e+00         0.2396\nJinshi        -1.1988e-02 -5.3666e-03  1.1334e-01 -1.9667e-02         0.9843\nJishou        -2.8680e-01 -2.6305e-03  4.4028e-02 -1.3543e+00         0.1756\nLanshan        6.3334e-02 -9.6365e-04  2.0441e-02  4.4972e-01         0.6529\nLeiyang        1.1581e-02 -1.4948e-04  2.5082e-03  2.3422e-01         0.8148\nLengshuijiang -1.7903e+00 -8.2129e-02  2.1598e+00 -1.1623e+00         0.2451\nLi             1.0225e-03 -2.4048e-07  5.1060e-06  4.5260e-01         0.6508\nLianyuan      -1.4672e-01 -1.8983e-03  1.9145e-02 -1.0467e+00         0.2952\nLiling         1.3774e+00 -1.5097e-02  4.2601e-01  2.1335e+00         0.0329\nLinli          1.4815e-02 -6.8294e-05  1.4499e-03  3.9086e-01         0.6959\nLinwu         -2.4621e-03 -9.0703e-06  1.9258e-04 -1.7676e-01         0.8597\nLinxiang       6.5904e-02 -2.9028e-03  2.5470e-01  1.3634e-01         0.8916\nLiuyang        3.3688e+00 -7.7502e-02  1.5180e+00  2.7972e+00         0.0052\nLonghui        8.0801e-01 -1.1377e-02  1.5538e-01  2.0787e+00         0.0376\nLongshan       7.5663e-01 -1.1100e-02  3.1449e-01  1.3690e+00         0.1710\nLuxi           1.8177e-01 -2.4855e-03  3.4249e-02  9.9561e-01         0.3194\nMayang         2.1852e-01 -5.8773e-03  9.8049e-02  7.1663e-01         0.4736\nMiluo          1.8704e+00 -1.6927e-02  2.7925e-01  3.5715e+00         0.0004\nNan           -9.5789e-03 -4.9497e-04  6.8341e-03 -1.0988e-01         0.9125\nNingxiang      1.5607e+00 -7.3878e-02  8.0012e-01  1.8274e+00         0.0676\nNingyuan       2.0910e-01 -7.0884e-03  8.2306e-02  7.5356e-01         0.4511\nPingjiang     -9.8964e-01 -2.6457e-03  5.6027e-02 -4.1698e+00         0.0000\nQidong         1.1806e-01 -2.1207e-03  2.4747e-02  7.6396e-01         0.4449\nQiyang         6.1966e-02 -7.3374e-04  8.5743e-03  6.7712e-01         0.4983\nRucheng       -3.6992e-01 -8.8999e-03  2.5272e-01 -7.1814e-01         0.4727\nSangzhi        2.5053e-01 -4.9470e-03  6.8000e-02  9.7972e-01         0.3272\nShaodong      -3.2659e-02 -3.6592e-05  5.0546e-04 -1.4510e+00         0.1468\nShaoshan       2.1223e+00 -5.0227e-02  1.3668e+00  1.8583e+00         0.0631\nShaoyang       5.9499e-01 -1.1253e-02  1.3012e-01  1.6807e+00         0.0928\nShimen        -3.8794e-02 -3.8603e-04  6.4756e-03 -4.7729e-01         0.6332\nShuangfeng     9.2835e-03 -2.2867e-03  3.1516e-02  6.5174e-02         0.9480\nShuangpai      8.0591e-02 -3.1366e-04  8.9838e-03  8.5358e-01         0.3933\nSuining        3.7585e-01 -3.5933e-03  4.1870e-02  1.8544e+00         0.0637\nTaojiang      -2.5394e-01 -1.2395e-03  1.4477e-02 -2.1002e+00         0.0357\nTaoyuan        1.4729e-02 -1.2039e-04  8.5103e-04  5.0903e-01         0.6107\nTongdao        4.6482e-01 -6.9870e-03  1.9879e-01  1.0582e+00         0.2900\nWangcheng      4.4220e+00 -1.1067e-01  1.3596e+00  3.8873e+00         0.0001\nWugang         7.1003e-01 -7.8144e-03  1.0710e-01  2.1935e+00         0.0283\nXiangtan       2.4530e-01 -3.6457e-04  3.2319e-03  4.3213e+00         0.0000\nXiangxiang     2.6271e-01 -1.2703e-03  2.1290e-02  1.8092e+00         0.0704\nXiangyin       5.4525e-01 -4.7442e-03  7.9236e-02  1.9539e+00         0.0507\nXinhua         1.1810e-01 -6.2649e-03  8.6001e-02  4.2409e-01         0.6715\nXinhuang       1.5725e-01 -4.1820e-03  3.6648e-01  2.6667e-01         0.7897\nXinning        6.8928e-01 -9.6674e-03  2.0328e-01  1.5502e+00         0.1211\nXinshao        5.7578e-02 -8.5932e-03  1.1769e-01  1.9289e-01         0.8470\nXintian       -7.4050e-03 -5.1493e-03  1.0877e-01 -6.8395e-03         0.9945\nXupu           3.2406e-01 -5.7468e-03  5.7735e-02  1.3726e+00         0.1699\nYanling       -6.9021e-02 -5.9211e-04  9.9306e-03 -6.8667e-01         0.4923\nYizhang       -2.6844e-01 -2.2463e-03  4.7588e-02 -1.2202e+00         0.2224\nYongshun       6.3064e-01 -1.1350e-02  1.8830e-01  1.4795e+00         0.1390\nYongxing       4.3411e-01 -9.0735e-03  1.5088e-01  1.1409e+00         0.2539\nYou            7.8750e-02 -7.2728e-03  1.2116e-01  2.4714e-01         0.8048\nYuanjiang      2.0004e-04 -1.7760e-04  2.9798e-03  6.9181e-03         0.9945\nYuanling       8.7298e-03 -2.2981e-06  2.3221e-05  1.8121e+00         0.0700\nYueyang        4.1189e-02 -1.9768e-04  2.3113e-03  8.6085e-01         0.3893\nZhijiang       1.0476e-01 -7.8123e-04  1.3100e-02  9.2214e-01         0.3565\nZhongfang     -2.2685e-01 -2.1455e-03  3.5927e-02 -1.1855e+00         0.2358\nZhuzhou        3.2864e-01 -5.2432e-04  7.2391e-03  3.8688e+00         0.0001\nZixing        -7.6849e-01 -8.8210e-02  9.4057e-01 -7.0144e-01         0.4830\n\n\n\nMap the local Moran’s I\n\nhunan.localMI <- cbind(hunan,localMI) %>%\n  rename(Pr.Ii = Pr.z....E.Ii..)\n\n\n\nMap the local Moran’s I values\n\ntm_shape(hunan.localMI) +\n  tm_fill(col = \"Ii\", \n          style = \"pretty\",\n          palette = \"RdBu\",\n          title = \"local moran statistics\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.text.size = 0.5)\n\nVariable(s) \"Ii\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n\n\n\n\n\n\n\nMapping local Moran’s I p-values\n\ntm_shape(hunan.localMI) +\n  tm_fill(col = \"Pr.Ii\", \n          breaks=c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),\n          palette=\"-Blues\", \n          title = \"local Moran's I p-values\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.text.size = 0.5)\n\n\n\n\n\n\nMap both local Moran’s I value and p’s value\nFor effective interpretation, it is better to plot both the local Moran’s I values map and its corresponding p-values map next to each other.\n\nlocalMI.map <- tm_shape(hunan.localMI) +\n  tm_fill(col = \"Ii\", \n          style = \"pretty\", \n          title = \"local moran statistics\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(legend.text.size = 0.4, legend.title.size = 0.5)\n\npvalue.map <- tm_shape(hunan.localMI) +\n  tm_fill(col = \"Pr.Ii\", \n          breaks=c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),\n          palette=\"-Blues\", \n          title = \"local Moran's I p-values\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.text.size = 0.4, legend.title.size = 0.5)\n\ntmap_arrange(localMI.map, pvalue.map, asp=1, ncol=2)\n\nVariable(s) \"Ii\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex02.html#create-a-lisa-cluster-map",
    "href": "Hands-on_Ex/Hands-on_Ex02.html#create-a-lisa-cluster-map",
    "title": "Global and Local Measures of Spatial Autocorrelation",
    "section": "Create a LISA Cluster Map",
    "text": "Create a LISA Cluster Map\nThe LISA Cluster Map shows the significant locations color coded by type of spatial autocorrelation. The first step before we can generate the LISA cluster map is to plot the Moran scatterplot.\n\nPlotting Moran’s scatter plot\nThe Moran scatterplot is an illustration of the relationship between the values of the chosen attribute at each location and the average value of the same attribute at neighboring locations.\n\nnci <- moran.plot(hunan$GDPPC, rswm_q,\n                  labels=as.character(hunan$County), \n                  xlab=\"GDPPC 2012\", \n                  ylab=\"Spatially Lag GDPPC 2012\")\n\n\n\n\nNotice that the plot is split in 4 quadrants. The top right corner belongs to areas that have high GDPPC and are surrounded by other areas that have the average level of GDPPC. This are the high-high locations in the lesson slide.\n\n\nPlotting Moran scatter plot with standardised variable\n\nhunan$Z.GDPPC <- scale(hunan$GDPPC) %>% as.vector \n\nThe as.vector() added to the end is to make sure that the data type we get out of this is a vector, that map neatly into out dataframe.\n\nnci2 <- moran.plot(hunan$Z.GDPPC, rswm_q,\n                   labels=as.character(hunan$County),\n                   xlab=\"z-GDPPC 2012\", \n                   ylab=\"Spatially Lag z-GDPPC 2012\")\n\n\n\n\n\n\nPreparing LISA map classes\nStep 1: define the quadrant\n\nquadrant <- vector(mode=\"numeric\",length=nrow(localMI))\n\nStep 2: center the variable of interest around its means\n\nDV <- hunan$GDPPC - mean(hunan$GDPPC)     \n\nStep 3: center the local Moran around the mean\n\nC_mI <- localMI[,1] - mean(localMI[,1])    \n\nStep 4: set a statistical significance level for the local Moran\n\nsignif <- 0.05       \n\nThese four command lines define the high-high, low-low, low-high and high-low categories.\n\nquadrant[DV >0 & C_mI>0] <- 4      \nquadrant[DV <0 & C_mI<0] <- 1      \nquadrant[DV <0 & C_mI>0] <- 2\nquadrant[DV >0 & C_mI<0] <- 3\n\nStep 5: place non-significant Moran in the category 0\n\nquadrant[localMI[,5]>signif] <- 0\n\nWe can combined all the steps into one single code chunk as shown below.\n\nquadrant <- vector(mode=\"numeric\",length=nrow(localMI))\nDV <- hunan$GDPPC - mean(hunan$GDPPC)     \nC_mI <- localMI[,1] - mean(localMI[,1])    \nsignif <- 0.05       \nquadrant[DV >0 & C_mI>0] <- 4      \nquadrant[DV <0 & C_mI<0] <- 1      \nquadrant[DV <0 & C_mI>0] <- 2\nquadrant[DV >0 & C_mI<0] <- 3\nquadrant[localMI[,5]>signif] <- 0\n\n\n\nPlotting LISA map\n\nhunan.localMI$quadrant <- quadrant\ncolors <- c(\"#ffffff\", \"#2c7bb6\", \"#abd9e9\", \"#fdae61\", \"#d7191c\")\nclusters <- c(\"insignificant\", \"low-low\", \"low-high\", \"high-low\", \"high-high\")\n\ntm_shape(hunan.localMI) +\n  tm_fill(col = \"quadrant\", \n          style = \"cat\", \n          palette = colors[c(sort(unique(quadrant)))+1], \n          labels = clusters[c(sort(unique(quadrant)))+1],\n          popup.vars = c(\"\")) +\n  tm_view(set.zoom.limits = c(11,17)) +\n  tm_borders(alpha=0.5) +\n  tm_layout(legend.text.size = 0.5)\n\n\n\n\nFor effective interpretation, it is better to plot both the local Moran’s I values map and its corresponding p-values map next to each other.\n\ngdppc <- qtm(hunan, \"GDPPC\") +\n  tm_layout(legend.text.size = 0.5, legend.title.size = 0.6)\n\nhunan.localMI$quadrant <- quadrant\ncolors <- c(\"#ffffff\", \"#2c7bb6\", \"#abd9e9\", \"#fdae61\", \"#d7191c\")\nclusters <- c(\"insignificant\", \"low-low\", \"low-high\", \"high-low\", \"high-high\")\n\nLISAmap <- tm_shape(hunan.localMI) +\n  tm_fill(col = \"quadrant\", \n          style = \"cat\", \n          palette = colors[c(sort(unique(quadrant)))+1], \n          labels = clusters[c(sort(unique(quadrant)))+1],\n          popup.vars = c(\"\")) +\n  tm_view(set.zoom.limits = c(11,17)) +\n  tm_borders(alpha=0.5) +\n  tm_layout(legend.text.size = 0.5, legend.title.size = 0.6)\n\ntmap_arrange(gdppc, LISAmap, asp=1, ncol=2)\n\n\n\n\nThe red counties signify positive autocorrelation with high-value clusters surrounded by high-value neighbors. Those areas have high values of GDPPC in correlation with nearby counties that also have high GDPPC.\nThe darkblue counties signify positive autocorrelation with low-value clusters surrounded by low-value neighbors. They are the counties with relatively lower value of GDPPC in correlation with nearby counties with low GDPPC. For development planning, they need more investment because while being close to developed areas with generally higher GDPPC, it looks like they are not yet benefiting from the development of the region.\nThe light orange county shows that it is an outlier that has higher value than nearby lower neighbors. Spatial-wise, this county is more developed than its nearby counties and is getting the synergy of nearby counties with higher GDPPC.\nThe light blue counties are outlier with lower GDPPC than their neighbor counties. Being the remote counties far away from the more developed areas, they are the least developed counties that are lagged behind, requiring attention for development investment."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex02.html#hot-spot-and-cold-spot-area-analysis",
    "href": "Hands-on_Ex/Hands-on_Ex02.html#hot-spot-and-cold-spot-area-analysis",
    "title": "Global and Local Measures of Spatial Autocorrelation",
    "section": "Hot Spot and Cold Spot Area Analysis",
    "text": "Hot Spot and Cold Spot Area Analysis\nBeside detecting cluster and outliers, localised spatial statistics can be also used to detect hot spot and/or cold spot areas.\nThe term ‘hot spot’ has been used generically across disciplines to describe a region or value that is higher relative to its surroundings (Lepers et al 2005, Aben et al 2012, Isobe et al 2015).\n\nGetis and Ord’s G-Statistics\nAn alternative spatial statistics to detect spatial anomalies is the Getis and Ord’s G-statistics (Getis and Ord, 1972; Ord and Getis, 1995). It looks at neighbours within a defined proximity to identify where either high or low values clutser spatially. Here, statistically significant hot-spots are recognised as areas of high values where other areas within a neighbourhood range also share high values too.\nThe analysis consists of three steps:\n\nDeriving spatial weight matrix\nComputing Gi statistics\nMapping Gi statistics\n\n\n\nDeriving distance-based weight matrix\n\nDeriving the centroid\nTo get our longitude values we map the st_centroid() function over the geometry column of us.bound and access the longitude value through double bracket notation [[]] and 1. This allows us to get only the longitude, which is the first value in each centroid.\n\nlongitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])\n\nWe do the same for latitude with one key difference. We access the second value per each centroid with [[2]].\n\nlatitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])\n\nUse bin to put longitude and lattitude into the same object.\n\ncoords <- cbind(longitude, latitude)\n\n\n\nDetermine the cut-off distance\n\n#coords <- coordinates(hunan)\nk1 <- knn2nb(knearneigh(coords))\nk1dists <- unlist(nbdists(k1, coords, longlat = TRUE))\nsummary(k1dists)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  24.79   32.57   38.01   39.07   44.52   61.79 \n\n\nThe summary report shows that the largest first nearest neighbour distance is 61.79 km, so using this as the upper threshold gives certainty that all units will have at least one neighbour.\n\n\nComputing fixed distance weight matrix\n\nwm_d62 <- dnearneigh(coords, 0, 62, longlat = TRUE)\nwm_d62\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \n\n\n\nwm62_lw <- nb2listw(wm_d62, style = 'B')\nsummary(wm62_lw)\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \nLink number distribution:\n\n 1  2  3  4  5  6 \n 6 15 14 26 20  7 \n6 least connected regions:\n6 15 30 32 56 65 with 1 link\n7 most connected regions:\n21 28 35 45 50 52 82 with 6 links\n\nWeights style: B \nWeights constants summary:\n   n   nn  S0  S1   S2\nB 88 7744 324 648 5440\n\n\nThe output spatial weights object is called wm62_lw.\n\n\n\nComputing adaptive distance weight matrix\nOne of the characteristics of fixed distance weight matrix is that more densely settled areas (usually the urban areas) tend to have more neighbors and the less densely settled areas (usually the rural counties) tend to have lesser neighbors. Having many neighbors smoothes the neighbor relationship across more neighbors.\n\nknn <- knn2nb(knearneigh(coords, k=8))\nknn\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 704 \nPercentage nonzero weights: 9.090909 \nAverage number of links: 8 \nNon-symmetric neighbours list\n\n\n\nknn_lw <- nb2listw(knn, style = 'B')\nsummary(knn_lw)\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 704 \nPercentage nonzero weights: 9.090909 \nAverage number of links: 8 \nNon-symmetric neighbours list\nLink number distribution:\n\n 8 \n88 \n88 least connected regions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 with 8 links\n88 most connected regions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 with 8 links\n\nWeights style: B \nWeights constants summary:\n   n   nn  S0   S1    S2\nB 88 7744 704 1300 23014"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex02.html#computing-gi-statistics",
    "href": "Hands-on_Ex/Hands-on_Ex02.html#computing-gi-statistics",
    "title": "Global and Local Measures of Spatial Autocorrelation",
    "section": "Computing Gi statistics",
    "text": "Computing Gi statistics\n\nGi statistics using fixed distance\n\nfips <- order(hunan$County)\ngi.fixed <- localG(hunan$GDPPC, wm62_lw)\ngi.fixed\n\n [1]  0.436075843 -0.265505650 -0.073033665  0.413017033  0.273070579\n [6] -0.377510776  2.863898821  2.794350420  5.216125401  0.228236603\n[11]  0.951035346 -0.536334231  0.176761556  1.195564020 -0.033020610\n[16]  1.378081093 -0.585756761 -0.419680565  0.258805141  0.012056111\n[21] -0.145716531 -0.027158687 -0.318615290 -0.748946051 -0.961700582\n[26] -0.796851342 -1.033949773 -0.460979158 -0.885240161 -0.266671512\n[31] -0.886168613 -0.855476971 -0.922143185 -1.162328599  0.735582222\n[36] -0.003358489 -0.967459309 -1.259299080 -1.452256513 -1.540671121\n[41] -1.395011407 -1.681505286 -1.314110709 -0.767944457 -0.192889342\n[46]  2.720804542  1.809191360 -1.218469473 -0.511984469 -0.834546363\n[51] -0.908179070 -1.541081516 -1.192199867 -1.075080164 -1.631075961\n[56] -0.743472246  0.418842387  0.832943753 -0.710289083 -0.449718820\n[61] -0.493238743 -1.083386776  0.042979051  0.008596093  0.136337469\n[66]  2.203411744  2.690329952  4.453703219 -0.340842743 -0.129318589\n[71]  0.737806634 -1.246912658  0.666667559  1.088613505 -0.985792573\n[76]  1.233609606 -0.487196415  1.626174042 -1.060416797  0.425361422\n[81] -0.837897118 -0.314565243  0.371456331  4.424392623 -0.109566928\n[86]  1.364597995 -1.029658605 -0.718000620\nattr(,\"cluster\")\n [1] Low  Low  High High High High High High High Low  Low  High Low  Low  Low \n[16] High High High High Low  High High Low  Low  High Low  Low  Low  Low  Low \n[31] Low  Low  Low  High Low  Low  Low  Low  Low  Low  High Low  Low  Low  Low \n[46] High High Low  Low  Low  Low  High Low  Low  Low  Low  Low  High Low  Low \n[61] Low  Low  Low  High High High Low  High Low  Low  High Low  High High Low \n[76] High Low  Low  Low  Low  Low  Low  High High Low  High Low  Low \nLevels: Low High\nattr(,\"gstari\")\n[1] FALSE\nattr(,\"call\")\nlocalG(x = hunan$GDPPC, listw = wm62_lw)\nattr(,\"class\")\n[1] \"localG\"\n\n\nThe output of localG() is a vector of G or Gstar values, with attributes “gstari” set to TRUE or FALSE, “call” set to the function call, and class “localG”.\nThe Gi statistics is represented as a Z-score. Greater values represent a greater intensity of clustering and the direction (positive or negative) indicates high or low clusters.\nJoin the Gi values to their corresponding hunan sf data frame\n\nhunan.gi <- cbind(hunan, as.matrix(gi.fixed)) %>%\n  rename(gstat_fixed = as.matrix.gi.fixed.)\n\n\n\nMapping Gi values with fixed distance weights\n\ngdppc <- qtm(hunan, \"GDPPC\") +\n  tm_layout(legend.text.size = 0.5, legend.title.size = 0.5)\n\nGimap <-tm_shape(hunan.gi) +\n  tm_fill(col = \"gstat_fixed\", \n          style = \"pretty\",\n          palette=\"-RdBu\",\n          title = \"local Gi\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.text.size = 0.5, legend.title.size = 0.5)\n\ntmap_arrange(gdppc, Gimap, asp=1, ncol=2)\n\nVariable(s) \"gstat_fixed\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n\n\n\n\n\nThe fixed distance weight method reveals the hot spots, which are areas with higher GDPPC values among their neighbors, and cold spots, which have lower GDPPC value among their neighbors. However, due to the varying size of the counties, the fixed distance method shows scattering clusters which is not very useful for development decision.\n\n\nGi statistics using adaptive distance\n\nfips <- order(hunan$County)\ngi.adaptive <- localG(hunan$GDPPC, knn_lw)\nhunan.gi <- cbind(hunan, as.matrix(gi.adaptive)) %>%\n  rename(gstat_adaptive = as.matrix.gi.adaptive.)\n\n\n\nMapping Gi values with adaptive distance weights\n\ngdppc<- qtm(hunan, \"GDPPC\") +\n  tm_layout(legend.text.size = 0.6, legend.title.size = 0.6)\n\nGimap <- tm_shape(hunan.gi) + \n  tm_fill(col = \"gstat_adaptive\", \n          style = \"pretty\", \n          palette=\"-RdBu\", \n          title = \"local Gi\") + \n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.text.size = 0.6, legend.title.size = 0.6)\n\ntmap_arrange(gdppc, \n             Gimap, \n             asp=1, \n             ncol=2)\n\nVariable(s) \"gstat_adaptive\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n\n\n\n\n\nThe adaptive distance weight method shows clear border clusters. For the map on the right, we can see the hot spot areas with higher GDPPC than their neighbors being closer or overlap with high GDPPC counties. From this map, we can also see the ripple effect on GDPPC caused by the higher developed counties to the nearby provinces on the eastern side of Hunan. This map also shows the cold spot areas located on the far west side of Hunan with GDPPC being lower than their neighbors. They are the counties that are lagged behind in terms of GDPPC and may need the attention to development investment."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex2/In-class_Ex2.html",
    "href": "In-class_Ex/In-class_Ex2/In-class_Ex2.html",
    "title": "Birds of a feather flock together: Do functionally similar water points positively co-occur in Nigeria?",
    "section": "",
    "text": "In the code chunk below, p_load() of pacman package is used to install and load the following R packages into R environment:\n\nsf,\ntidyverse,\ntmap,\nspdep, and\nfunModeling will be used for rapid Exploratory Data Analysis\n\n\npacman::p_load(sf, tidyverse, tmap, spdep, funModeling)"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex2/In-class_Ex2.html#importing-geospatial-data",
    "href": "In-class_Ex/In-class_Ex2/In-class_Ex2.html#importing-geospatial-data",
    "title": "Birds of a feather flock together: Do functionally similar water points positively co-occur in Nigeria?",
    "section": "Importing Geospatial Data",
    "text": "Importing Geospatial Data\nIn this in-class data, two geospatial data sets will be used, they are:\n\ngeo_export\nnga_admbnda_adm2_osgof_20190417\n\n\nwp <- st_read(dsn = \"data\",\n              layer = \"geo_export\",\n              crs = 4326) %>%\n  filter(clean_coun == \"Nigeria\")\n\nReading layer `geo_export' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/In-class_Ex/In-class_Ex2/data' \n  using driver `ESRI Shapefile'\nSimple feature collection with 406566 features and 72 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -92.05073 ymin: -27.31495 xmax: 92.32694 ymax: 26.65622\nGeodetic CRS:  WGS 84\n\n\nThings to learn from the code chunk above:\n\nst_read() of sf package is used to import geo_export shapefile into R environment and save the imported geospatial data into simple feature data table.\nfilter() of dplyr package is used to extract water point records of Nigeria.\n\n\nBe warned: Avoid performing transformation if you plan to use st_intersects() of sf package in the later stage of the geoprocessing. This is because st_intersects() only works correctly if the geospatial data are in geographic coordinate system (i.e. wgs84).\nReminder: CRS stands for Coordinate Reference System.\n\nNext, write_rds() of readr package is used to save the extracted sf data table (i.e. wp) into an output file in rds data format. The output file is called wp_nga.rds and it is saved in data sub-folder.\n\nwrite_rds(wp, \"data/wp_nga.rds\")\n\n\nImporting Nigeria LGA boundary data\nNow, we are going to import the LGA boundary data into R environment by using the code chunk below.\n\nnga <- st_read(dsn = \"data\",\n               layer = \"geoBoundaries-NGA-ADM2\",\n               crs = 4326)\n\nReading layer `geoBoundaries-NGA-ADM2' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/In-class_Ex/In-class_Ex2/data' \n  using driver `ESRI Shapefile'\nSimple feature collection with 774 features and 5 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2.668534 ymin: 4.273007 xmax: 14.67882 ymax: 13.89442\nGeodetic CRS:  WGS 84\n\n\nst_read() of sf package is used to import geoBoundaries-NGA-ADM2 shapefile into R environment and save the imported geospatial data into simple feature data table."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex2/In-class_Ex2.html#data-wrangling",
    "href": "In-class_Ex/In-class_Ex2/In-class_Ex2.html#data-wrangling",
    "title": "Birds of a feather flock together: Do functionally similar water points positively co-occur in Nigeria?",
    "section": "Data Wrangling",
    "text": "Data Wrangling\n\nRecoding NA values into string\nIn the code chunk below, replace_na() is used to recode all the NA values in status_cle field into Unknown.\n\nwp_nga <- read_rds(\"data/wp_nga.rds\") %>%\n  mutate(status_cle = replace_na(status_cle, \"Unknown\"))\n\n\n\nEDA\nIn the code chunk below, freq() of funModeling package is used to display the distribution of status_cle field in wp_nga.\n\nfreq(data=wp_nga, \n     input = 'status_cle')\n\n\n\n\n                        status_cle frequency percentage cumulative_perc\n1                       Functional     45883      48.29           48.29\n2                   Non-Functional     29385      30.93           79.22\n3                          Unknown     10656      11.22           90.44\n4      Functional but needs repair      4579       4.82           95.26\n5 Non-Functional due to dry season      2403       2.53           97.79\n6        Functional but not in use      1686       1.77           99.56\n7         Abandoned/Decommissioned       234       0.25           99.81\n8                        Abandoned       175       0.18           99.99\n9 Non functional due to dry season         7       0.01          100.00"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex2/In-class_Ex2.html#extracting-water-point-data",
    "href": "In-class_Ex/In-class_Ex2/In-class_Ex2.html#extracting-water-point-data",
    "title": "Birds of a feather flock together: Do functionally similar water points positively co-occur in Nigeria?",
    "section": "Extracting Water Point Data",
    "text": "Extracting Water Point Data\nIn this section, we will extract the water point records by using classes in status_cle field.\n\nExtracting funtional water point\nIn the code chunk below, filter() of dplyr is used to select functional water points.\n\nwpt_functional <- wp_nga %>%\n  filter(status_cle %in%\n           c(\"Functional\", \n             \"Functional but not in use\",\n             \"Functional but needs repair\"))\n\n\nfreq(data=wpt_functional, \n     input = 'status_cle')\n\n\n\n\n                   status_cle frequency percentage cumulative_perc\n1                  Functional     45883      87.99           87.99\n2 Functional but needs repair      4579       8.78           96.77\n3   Functional but not in use      1686       3.23          100.00\n\n\n\n\nExtracting non-functional water point\nIn the code chunk below, filter() of dplyr is used to select non-functional water points.\n\nwpt_nonfunctional <- wp_nga %>%\n  filter(status_cle %in%\n           c(\"Abandoned/Decommissioned\", \n             \"Abandoned\",\n             \"Non-Functional\",\n             \"Non functional due to dry season\",\n             \"Non-Functional due to dry season\"))\n\n\nfreq(data=wpt_nonfunctional, \n     input = 'status_cle')\n\n\n\n\n                        status_cle frequency percentage cumulative_perc\n1                   Non-Functional     29385      91.25           91.25\n2 Non-Functional due to dry season      2403       7.46           98.71\n3         Abandoned/Decommissioned       234       0.73           99.44\n4                        Abandoned       175       0.54           99.98\n5 Non functional due to dry season         7       0.02          100.00\n\n\n\n\nExtracting water point with Unknown class\nIn the code chunk below, filter() of dplyr is used to select water points with unknown status.\n\nwpt_unknown <- wp_nga %>%\n  filter(status_cle == \"Unknown\")"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex2/In-class_Ex2.html#performing-point-in-polygon-count",
    "href": "In-class_Ex/In-class_Ex2/In-class_Ex2.html#performing-point-in-polygon-count",
    "title": "Birds of a feather flock together: Do functionally similar water points positively co-occur in Nigeria?",
    "section": "Performing Point-in-Polygon Count",
    "text": "Performing Point-in-Polygon Count\n\nnga_wp <- nga %>% \n  mutate(`total wpt` = lengths(\n    st_intersects(nga, wp_nga))) %>%\n  mutate(`wpt functional` = lengths(\n    st_intersects(nga, wpt_functional))) %>%\n  mutate(`wpt non-functional` = lengths(\n    st_intersects(nga, wpt_nonfunctional))) %>%\n  mutate(`wpt unknown` = lengths(\n    st_intersects(nga, wpt_unknown)))"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex2/In-class_Ex2.html#saving-the-analytical-data-table",
    "href": "In-class_Ex/In-class_Ex2/In-class_Ex2.html#saving-the-analytical-data-table",
    "title": "Birds of a feather flock together: Do functionally similar water points positively co-occur in Nigeria?",
    "section": "Saving the Analytical Data Table",
    "text": "Saving the Analytical Data Table\n\nnga_wp <- nga_wp %>%\n  mutate(pct_functional = `wpt functional`/`total wpt`) %>%\n  mutate(`pct_non-functional` = `wpt non-functional`/`total wpt`)\n\nThings to learn from the code chunk above:\n\nmutate() of dplyr package is used to derive two fields namely pct_functional and pct_non-functional.\n\nNow, you have the tidy sf data table subsequent analysis. We will save the sf data table into rds format.\n\nwrite_rds(nga_wp, \"data/nga_wp.rds\")\n\nBefore you end this section, please remember to delete away all the raw data. Notice that the only data file left is nga_wp.rds and it’s file size is aroung 2.1MB."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex2/In-class_Ex2.html#visualising-the-spatial-dsitribution-of-water-points",
    "href": "In-class_Ex/In-class_Ex2/In-class_Ex2.html#visualising-the-spatial-dsitribution-of-water-points",
    "title": "Birds of a feather flock together: Do functionally similar water points positively co-occur in Nigeria?",
    "section": "Visualising the spatial dsitribution of water points",
    "text": "Visualising the spatial dsitribution of water points\n\nnga_wp <- read_rds(\"data/nga_wp.rds\")\ntotal <- qtm(nga_wp, \"total wpt\") + tm_layout(legend.text.size = 0.4, legend.title.size = 0.5)\nwp_functional <- qtm(nga_wp, \"wpt functional\") + tm_layout(legend.text.size = 0.4, legend.title.size = 0.5)\nwp_nonfunctional <- qtm(nga_wp, \"wpt non-functional\") + tm_layout(legend.text.size = 0.4, legend.title.size = 0.5)\nunknown <- qtm(nga_wp, \"wpt unknown\") + tm_layout(legend.text.size = 0.4, legend.title.size = 0.5)\n\ntmap_arrange(total, wp_functional, wp_nonfunctional, unknown, nrow = 2, ncol=2)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html",
    "title": "Take-home Exercise 1: How Functional are the Water Points in Nigeria?",
    "section": "",
    "text": "Water is a critical asset of all communities and nations. It is the core neccessity to sustain the life of both humans and livestock. Lack of access to potable water can lead to serious health hazards and even conflicts between communities and states. According to a 2022 report by World Bank, about 70 million Nigerians do not have access to drinkable water. Access to piped water has decreased from 39% in 1990 to only 11% in 2021. This phenomenon contributes to a surge in violence in Nigeria when communities Fulani herders ad farmers fight over water supplies.\nWhy is there a water crisis in Nigeria? To gain a perspective on the answer, we will examine the quality and distribution of water supply points in Nigeria.\n\n\n\nThe objective of this exercise is to apply appropriate global and local measures of spatial association techniques to reveals the spatial patterns of non-functional water points in Nigeria."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#setup",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#setup",
    "title": "Take-home Exercise 1: How Functional are the Water Points in Nigeria?",
    "section": "Setup",
    "text": "Setup\n\nData\n\nAspatial Data\nThe aspatial data of water points quality, status and other relevant information is taken from WPdx Global Data Repositories - WPdx+ version. The data set is downloaded in Shapefile format.\n\n\nGeospatial Data\nThe geospatial data of Nigeria administrative regions is downloaded from Geoboundaries. The data level of ADM2, published in 2020, will be used.\n\n\n\nR Packages Used\n\nsf: used for importing, managing, and processing geospatial data\ntidyverse: a collection of packages for data science tasks. It contains the sub-packages dplyr, ggplot2, forcats, tibble, readr, stringr, tidyr, purrr\ntmap: used for creating thematic maps, such as choropleth and bubble maps\nspdep: used for calculating spatial dependence - weighting schemes and statistics\nfunModeling: used for EDA and data preparation\n\nWe load the packages into our working environment using the code below.\n\n\nShow code\npacman::p_load(sf, tidyverse, tmap, spdep, funModeling)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#data-wrangling",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#data-wrangling",
    "title": "Take-home Exercise 1: How Functional are the Water Points in Nigeria?",
    "section": "Data Wrangling",
    "text": "Data Wrangling\n\nGeospatial Data\n\nImport the water point geospatial data\nThe data from WPdx Global Data Repositories comes in four files in dbf, prj, shp, shx formats. The files are renamed into geo_export for a more convenient reference.\nUsing st_read() from the sf package, we import the aspatial data into our working environment. The data is imported as a simple feature data table.\n\nwp <- st_read(dsn = \"data\", layer = \"geo_export\")\n\nReading layer `geo_export' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/Take-home_Ex/Take-home_Ex1/data' \n  using driver `ESRI Shapefile'\nSimple feature collection with 406566 features and 72 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -92.05073 ymin: -27.31495 xmax: 92.32694 ymax: 26.65622\nGeodetic CRS:  WGS84(DD)\n\n\n\n\nCheck the content of water point simple feature data frame\nFirst, we use st_geometry() to check the geometry list column of wp. There are 406,566 observations under the WGS84 coordinate reference system (CRS).\n\nst_geometry(wp)\n\nGeometry set for 406566 features \nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -92.05073 ymin: -27.31495 xmax: 92.32694 ymax: 26.65622\nGeodetic CRS:  WGS84(DD)\nFirst 5 geometries:\n\n\nSince the shapefile is in WGS84 CRS, we will assign crs = 4326 to wp. 4326 is the code of WGS84 in EPSG code. The task is conducted using st_set_crs().\n\nwp <- st_set_crs(wp, 4326)\n\nNext, we will examine the attributes in the data table using glimpse() from dplyr.\n\nglimpse(wp)\n\nRows: 406,566\nColumns: 73\n$ row_id      <dbl> 651816, 584864, 509399, 21983, 660321, 666619, 657081, 669…\n$ source      <chr> \"Water For People\", \"Global Environment and Technology Fou…\n$ lat_deg     <dbl> -15.726464200, 6.723120000, 8.001933333, 8.084948140, 0.18…\n$ lon_deg     <dbl> 35.05067, -1.58151, -11.28760, -10.12595, 30.44659, 30.352…\n$ date_repor  <date> 2018-06-11, 2017-10-25, 2010-12-31, 2015-12-04, 2019-03-1…\n$ time_repor  <chr> \"00:00:00.000\", \"00:00:00.000\", \"00:00:00.000\", \"00:00:00.…\n$ status_id   <chr> \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Y…\n$ water_sour  <chr> NA, NA, NA, NA, \"Piped Water\", \"Piped Water\", NA, NA, NA, …\n$ water_so_2  <chr> NA, NA, NA, NA, \"Piped Water\", \"Piped Water\", NA, NA, NA, …\n$ water_te_2  <chr> \"Kiosk\", \"Tapstand\", \"Tapstand\", \"Tapstand\", NA, NA, \"Taps…\n$ X_water_tec <chr> \"Tapstand\", \"Tapstand\", \"Tapstand\", \"Tapstand\", NA, NA, \"T…\n$ facility_t  <chr> \"Improved\", \"Improved\", \"Improved\", \"Improved\", \"Improved\"…\n$ clean_coun  <chr> \"Malawi\", \"Ghana\", \"Sierra Leone\", \"Liberia\", \"Uganda\", \"U…\n$ clean_adm1  <chr> \"Blantyre\", \"Ashanti\", \"Eastern\", \"Lofa\", \"Western\", \"West…\n$ clean_adm2  <chr> \"Blantyre City\", \"Asokore Mampong Municipal\", \"Kenema\", \"K…\n$ clean_adm3  <chr> \"n.a. (2465)\", NA, \"Kando Leppeama\", \"Lucasu\", \"Kibale\", \"…\n$ clean_adm4  <chr> NA, NA, NA, NA, \"Kamwenge Town Council\", \"Buhanda\", \"Mahyo…\n$ install_ye  <dbl> NA, 2017, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ installer   <chr> NA, NA, \"Water Aid\", NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ rehab_year  <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ rehabilita  <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ manageme_2  <chr> NA, NA, NA, \"School Management\", NA, NA, NA, NA, NA, NA, N…\n$ status_cle  <chr> NA, NA, \"Functional\", NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ pay         <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ fecal_coli  <chr> NA, NA, NA, NA, \"Present\", \"Present\", \"Present\", NA, NA, \"…\n$ fecal_co_2  <chr> NA, \"0\", NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ subjective  <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ activity_i  <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ scheme_id   <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ wpdx_id     <chr> \"5GPQ73F2+C77\", \"6CRWPCF9+69X\", \"6CWC2P26+QXC\", \"6CWF3VMF+…\n$ notes       <chr> NA, NA, \"Poor?Jenneh?Kandu Leppiema??\", NA, NA, NA, NA, NA…\n$ orig_lnk    <chr> NA, NA, NA, \"https://wash-liberia.org/raw-water-point-data…\n$ photo_lnk   <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ country_id  <chr> \"MW\", \"GH\", \"SL\", \"LR\", \"UG\", \"UG\", \"UG\", \"UG\", \"UG\", \"UG\"…\n$ data_lnk    <chr> \"https://catalog.waterpointdata.org/datasets/wfp-2017-2020…\n$ distance_t  <dbl> 7034.8250, 3677.9101, 17540.3622, 21602.1376, 31948.1224, …\n$ distance_2  <dbl> 3431.81039, 3944.70081, 4052.93329, 37030.19501, 593.69582…\n$ distance_3  <dbl> 421.90674, 690.13048, 104.43156, 14456.72395, 149.01742, 1…\n$ distance_4  <dbl> 8321.854, 5362.011, 17003.136, 52727.389, 40206.411, 38061…\n$ distance_5  <dbl> 22044.5149, 7550.3392, 15474.4428, 31606.4649, 35770.4357,…\n$ water_poin  <chr> \"{\\\"2018-06-11\\\": {\\\"source\\\": \\\"Water For People\\\", \\\"sta…\n$ rehab_prio  <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ served_pop  <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ local_popu  <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ crucialnes  <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ pressure    <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ usage_cap   <dbl> 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250…\n$ is_urban    <chr> \"True\", \"True\", \"False\", \"False\", \"False\", \"False\", \"False…\n$ days_since  <dbl> 1562, 1791, 4281, 2482, 1286, 1281, 1660, 6222, 1663, 1280…\n$ staleness_  <dbl> 61.11805, 56.86178, 25.93887, 45.73258, 66.67340, 66.77856…\n$ is_latest   <chr> \"T\", \"T\", \"T\", \"T\", \"T\", \"T\", \"T\", \"T\", \"T\", \"T\", \"T\", \"T\"…\n$ location_i  <dbl> 355848, 349148, 98255, 285679, 362508, 362657, 351144, 777…\n$ cluster_si  <dbl> 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ clean_co_2  <chr> \"MWI\", \"GHA\", \"SLE\", \"LBR\", \"UGA\", \"UGA\", \"UGA\", \"UGA\", \"U…\n$ country_na  <chr> \"Malawi\", \"Ghana\", \"Sierra Leone\", \"Liberia\", \"Uganda\", \"U…\n$ water_so_3  <chr> NA, NA, \"Gravity stand-post\", \"Public standpipe\", NA, NA, …\n$ water_tech  <chr> \"Communal water kiosk\", \"Standpost\", NA, NA, \"Pumped piped…\n$ status      <chr> \"1\", NA, \"Functional\", NA, \"1\", \"0\", \"1\", \"1\", \"1\", \"1\", N…\n$ adm2        <chr> \"Kameza\", NA, \"Kenema\", NA, \"Kibale\", \"Kitagwenda\", \"Kitag…\n$ adm3        <chr> NA, NA, NA, NA, \"Kamwenge T/Council\", \"Buhanda\", \"Mahyoro\"…\n$ management  <chr> NA, NA, NA, \"Institutional Management - School\", NA, NA, N…\n$ adm1        <chr> \"Blantyre\", NA, \"Eastern\", \"Lofa\", \"Kamwenge\", \"Kamwenge\",…\n$ lat_deg_or  <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ lat_lon_de  <chr> \"(-15.7264642?, 35.0506729?)\", \"(6.72312?, -1.58151?)\", \"(…\n$ lon_deg_or  <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ public_dat  <chr> \"https://catalog.waterpointdata.org/datafiles/wfp-2017-202…\n$ converted   <chr> NA, NA, \"#install_year, #notes\", \"#status\", NA, NA, NA, NA…\n$ count       <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ date_creat  <date> 2022-02-18, 2020-07-29, 2020-07-30, 2020-09-11, 2022-02-1…\n$ time_creat  <chr> \"05:36:33.000\", \"19:21:47.000\", \"08:35:45.000\", \"11:22:31.…\n$ date_updat  <date> 2022-02-18, 2020-07-29, 2020-07-30, 2020-09-11, 2022-02-1…\n$ time_updat  <chr> \"05:36:33.000\", \"19:21:47.000\", \"08:35:45.000\", \"11:22:31.…\n$ geometry    <POINT [°]> POINT (35.05067 -15.72646), POINT (-1.58151 6.72312)…"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#importing-data",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#importing-data",
    "title": "Take-home Exercise 1: How Functional are the Water Points in Nigeria?",
    "section": "Importing Data",
    "text": "Importing Data\n\nImporting Nigeria water point geospatial data\nThe data from WPdx Global Data Repositories comes in four files in dbf, prj, shp, shx formats. The files are renamed into geo_export for a more convenient reference.\nUsing st_read() from the sf package, we import the aspatial data into our working environment. The data is imported as a simple feature data table.\n\n\nShow code\nwp <- st_read(dsn = \"data\", layer = \"geo_export\")\n\n\nReading layer `geo_export' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/Take-home_Ex/Take-home_Ex1/data' \n  using driver `ESRI Shapefile'\nSimple feature collection with 406566 features and 72 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -92.05073 ymin: -27.31495 xmax: 92.32694 ymax: 26.65622\nGeodetic CRS:  WGS84(DD)\n\n\n\n\nImporting Nigeria ADM2 aspatial data\nThe data from Geoboundaries comes in six files in dbf, geojson, prj, shp, shx, topojson formats. The files are renamed to NGA-ADM2 for easier reference. To import these files as a simple feature data table, we also use st_read().\n\n\nShow code\nnga <- st_read(dsn = \"data\", layer = \"NGA-ADM2\")\n\n\nReading layer `NGA-ADM2' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/Take-home_Ex/Take-home_Ex1/data' \n  using driver `ESRI Shapefile'\nSimple feature collection with 774 features and 5 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2.668534 ymin: 4.273007 xmax: 14.67882 ymax: 13.89442\nGeodetic CRS:  WGS 84"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#exploratory-data-analysis-and-data-wrangling",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#exploratory-data-analysis-and-data-wrangling",
    "title": "Take-home Exercise 1: How Functional are the Water Points in Nigeria?",
    "section": "Exploratory Data Analysis and Data Wrangling",
    "text": "Exploratory Data Analysis and Data Wrangling\nThe goals of this step include:\n\nExamine the data structure and format, ensure consistent format between geospatial and aspatial data.\nStudy the content of the data tables and filter out data that are not related to water points in Nigeria.\nExplore data type and data validity relating to the functionality of water points in Nigeria, transform the data where necessary.\n\n\nwp geospatial data\n\nChecking the CRS of geospatial data\nFirst, we use st_geometry() to check the geometry list column of wp. There are 406,566 observations under the WGS84 coordinate reference system (CRS). Let’s take notes that the geometry type is point 🔑\n\n\nShow code\nst_geometry(wp)\n\n\nGeometry set for 406566 features \nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -92.05073 ymin: -27.31495 xmax: 92.32694 ymax: 26.65622\nGeodetic CRS:  WGS84(DD)\nFirst 5 geometries:\n\n\nSince the shapefile is in WGS84 CRS, we will assign crs = 4326 to wp. 4326 is the code of WGS84 in EPSG code. The task is conducted using st_set_crs().\n\n\nShow code\nwp <- st_set_crs(wp, 4326)\n\n\n\n\nFiltering relevant information\nNext, we will examine the attributes in the data table using glimpse() from dplyr.\n\n\nShow code\nglimpse(wp)\n\n\nRows: 406,566\nColumns: 73\n$ row_id      <dbl> 651816, 584864, 509399, 21983, 660321, 666619, 657081, 669…\n$ source      <chr> \"Water For People\", \"Global Environment and Technology Fou…\n$ lat_deg     <dbl> -15.726464200, 6.723120000, 8.001933333, 8.084948140, 0.18…\n$ lon_deg     <dbl> 35.05067, -1.58151, -11.28760, -10.12595, 30.44659, 30.352…\n$ date_repor  <date> 2018-06-11, 2017-10-25, 2010-12-31, 2015-12-04, 2019-03-1…\n$ time_repor  <chr> \"00:00:00.000\", \"00:00:00.000\", \"00:00:00.000\", \"00:00:00.…\n$ status_id   <chr> \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Y…\n$ water_sour  <chr> NA, NA, NA, NA, \"Piped Water\", \"Piped Water\", NA, NA, NA, …\n$ water_so_2  <chr> NA, NA, NA, NA, \"Piped Water\", \"Piped Water\", NA, NA, NA, …\n$ water_te_2  <chr> \"Kiosk\", \"Tapstand\", \"Tapstand\", \"Tapstand\", NA, NA, \"Taps…\n$ X_water_tec <chr> \"Tapstand\", \"Tapstand\", \"Tapstand\", \"Tapstand\", NA, NA, \"T…\n$ facility_t  <chr> \"Improved\", \"Improved\", \"Improved\", \"Improved\", \"Improved\"…\n$ clean_coun  <chr> \"Malawi\", \"Ghana\", \"Sierra Leone\", \"Liberia\", \"Uganda\", \"U…\n$ clean_adm1  <chr> \"Blantyre\", \"Ashanti\", \"Eastern\", \"Lofa\", \"Western\", \"West…\n$ clean_adm2  <chr> \"Blantyre City\", \"Asokore Mampong Municipal\", \"Kenema\", \"K…\n$ clean_adm3  <chr> \"n.a. (2465)\", NA, \"Kando Leppeama\", \"Lucasu\", \"Kibale\", \"…\n$ clean_adm4  <chr> NA, NA, NA, NA, \"Kamwenge Town Council\", \"Buhanda\", \"Mahyo…\n$ install_ye  <dbl> NA, 2017, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ installer   <chr> NA, NA, \"Water Aid\", NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ rehab_year  <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ rehabilita  <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ manageme_2  <chr> NA, NA, NA, \"School Management\", NA, NA, NA, NA, NA, NA, N…\n$ status_cle  <chr> NA, NA, \"Functional\", NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ pay         <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ fecal_coli  <chr> NA, NA, NA, NA, \"Present\", \"Present\", \"Present\", NA, NA, \"…\n$ fecal_co_2  <chr> NA, \"0\", NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ subjective  <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ activity_i  <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ scheme_id   <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ wpdx_id     <chr> \"5GPQ73F2+C77\", \"6CRWPCF9+69X\", \"6CWC2P26+QXC\", \"6CWF3VMF+…\n$ notes       <chr> NA, NA, \"Poor?Jenneh?Kandu Leppiema??\", NA, NA, NA, NA, NA…\n$ orig_lnk    <chr> NA, NA, NA, \"https://wash-liberia.org/raw-water-point-data…\n$ photo_lnk   <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ country_id  <chr> \"MW\", \"GH\", \"SL\", \"LR\", \"UG\", \"UG\", \"UG\", \"UG\", \"UG\", \"UG\"…\n$ data_lnk    <chr> \"https://catalog.waterpointdata.org/datasets/wfp-2017-2020…\n$ distance_t  <dbl> 7034.8250, 3677.9101, 17540.3622, 21602.1376, 31948.1224, …\n$ distance_2  <dbl> 3431.81039, 3944.70081, 4052.93329, 37030.19501, 593.69582…\n$ distance_3  <dbl> 421.90674, 690.13048, 104.43156, 14456.72395, 149.01742, 1…\n$ distance_4  <dbl> 8321.854, 5362.011, 17003.136, 52727.389, 40206.411, 38061…\n$ distance_5  <dbl> 22044.5149, 7550.3392, 15474.4428, 31606.4649, 35770.4357,…\n$ water_poin  <chr> \"{\\\"2018-06-11\\\": {\\\"source\\\": \\\"Water For People\\\", \\\"sta…\n$ rehab_prio  <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ served_pop  <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ local_popu  <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ crucialnes  <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ pressure    <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ usage_cap   <dbl> 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250…\n$ is_urban    <chr> \"True\", \"True\", \"False\", \"False\", \"False\", \"False\", \"False…\n$ days_since  <dbl> 1562, 1791, 4281, 2482, 1286, 1281, 1660, 6222, 1663, 1280…\n$ staleness_  <dbl> 61.11805, 56.86178, 25.93887, 45.73258, 66.67340, 66.77856…\n$ is_latest   <chr> \"T\", \"T\", \"T\", \"T\", \"T\", \"T\", \"T\", \"T\", \"T\", \"T\", \"T\", \"T\"…\n$ location_i  <dbl> 355848, 349148, 98255, 285679, 362508, 362657, 351144, 777…\n$ cluster_si  <dbl> 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ clean_co_2  <chr> \"MWI\", \"GHA\", \"SLE\", \"LBR\", \"UGA\", \"UGA\", \"UGA\", \"UGA\", \"U…\n$ country_na  <chr> \"Malawi\", \"Ghana\", \"Sierra Leone\", \"Liberia\", \"Uganda\", \"U…\n$ water_so_3  <chr> NA, NA, \"Gravity stand-post\", \"Public standpipe\", NA, NA, …\n$ water_tech  <chr> \"Communal water kiosk\", \"Standpost\", NA, NA, \"Pumped piped…\n$ status      <chr> \"1\", NA, \"Functional\", NA, \"1\", \"0\", \"1\", \"1\", \"1\", \"1\", N…\n$ adm2        <chr> \"Kameza\", NA, \"Kenema\", NA, \"Kibale\", \"Kitagwenda\", \"Kitag…\n$ adm3        <chr> NA, NA, NA, NA, \"Kamwenge T/Council\", \"Buhanda\", \"Mahyoro\"…\n$ management  <chr> NA, NA, NA, \"Institutional Management - School\", NA, NA, N…\n$ adm1        <chr> \"Blantyre\", NA, \"Eastern\", \"Lofa\", \"Kamwenge\", \"Kamwenge\",…\n$ lat_deg_or  <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ lat_lon_de  <chr> \"(-15.7264642?, 35.0506729?)\", \"(6.72312?, -1.58151?)\", \"(…\n$ lon_deg_or  <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ public_dat  <chr> \"https://catalog.waterpointdata.org/datafiles/wfp-2017-202…\n$ converted   <chr> NA, NA, \"#install_year, #notes\", \"#status\", NA, NA, NA, NA…\n$ count       <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ date_creat  <date> 2022-02-18, 2020-07-29, 2020-07-30, 2020-09-11, 2022-02-1…\n$ time_creat  <chr> \"05:36:33.000\", \"19:21:47.000\", \"08:35:45.000\", \"11:22:31.…\n$ date_updat  <date> 2022-02-18, 2020-07-29, 2020-07-30, 2020-09-11, 2022-02-1…\n$ time_updat  <chr> \"05:36:33.000\", \"19:21:47.000\", \"08:35:45.000\", \"11:22:31.…\n$ geometry    <POINT [°]> POINT (35.05067 -15.72646), POINT (-1.58151 6.72312)…\n\n\nWe notice that in the clean_coun column, there are many countries name such as Malawi, Ghana, Sierra Leone, etc. This means that the wp data set contains the information of other countries besides Nigeria. filter() of the package dplyr is used to get the data that only belongs to Nigeria.\n\n\nShow code\nwp <- wp %>% filter(clean_coun == \"Nigeria\")\n\n\nNow we will examine the filtered wp data set using head() of Base R. The function reveals that wp now only contains Nigeria-relevant data.\n\n\nShow code\nhead(wp, n = 5)\n\n\nSimple feature collection with 5 features and 72 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 3.597668 ymin: 6.48694 xmax: 7.92972 ymax: 7.98\nGeodetic CRS:  WGS 84\n  row_id                                       source  lat_deg  lon_deg\n1 429068                                        GRID3 7.980000 5.120000\n2 222071 Federal Ministry of Water Resources, Nigeria 6.964532 3.597668\n3 160612                                     WaterAid 6.486940 7.929720\n4 160669                                     WaterAid 6.727570 7.648670\n5 160642                                     WaterAid 6.779900 7.664850\n  date_repor   time_repor status_id water_sour water_so_2      water_te_2\n1 2018-08-29 00:00:00.000   Unknown       <NA>       <NA>        Tapstand\n2 2015-08-16 00:00:00.000       Yes   Borehole       Well Mechanized Pump\n3 2020-12-04 00:00:00.000       Yes   Borehole       Well       Hand Pump\n4 2020-12-04 00:00:00.000       Yes   Borehole       Well            <NA>\n5 2020-12-04 00:00:00.000       Yes   Borehole       Well       Hand Pump\n      X_water_tec facility_t clean_coun clean_adm1    clean_adm2 clean_adm3\n1        Tapstand   Improved    Nigeria      Ekiti          Moba       <NA>\n2 Mechanized Pump   Improved    Nigeria       Ogun Obafemi-Owode       <NA>\n3       Hand Pump   Improved    Nigeria     Ebonyi       Ohaukwu       <NA>\n4            <NA>   Improved    Nigeria      Enugu       Isi-Uzo       <NA>\n5       Hand Pump   Improved    Nigeria      Enugu       Isi-Uzo       <NA>\n  clean_adm4 install_ye installer rehab_year rehabilita manageme_2 status_cle\n1       <NA>         NA      <NA>         NA       <NA>       <NA>       <NA>\n2       <NA>         NA      <NA>         NA       <NA>      Other Functional\n3       <NA>         NA      <NA>         NA       <NA>       <NA>       <NA>\n4       <NA>         NA      <NA>         NA       <NA>       <NA>       <NA>\n5       <NA>         NA      <NA>         NA       <NA>       <NA>       <NA>\n   pay fecal_coli fecal_co_2         subjective\n1 <NA>       <NA>       <NA>               <NA>\n2   No       <NA>       <NA> Acceptable quality\n3 <NA>       <NA>       <NA>               <NA>\n4 <NA>       <NA>       <NA>               <NA>\n5 <NA>       <NA>       <NA>               <NA>\n                            activity_i scheme_id      wpdx_id     notes\n1 1a117ba2-5256-4801-874c-f7611a4499dd      <NA> 6FV7X4JC+222 Tap Water\n2                                 <NA>      <NA> 6FR5XH7X+R37     Ajura\n3                                 <NA>      <NA> 6FR9FWPH+QVH      <NA>\n4                                 <NA>      <NA> 6FR9PJHX+2FF      <NA>\n5                                 <NA>      <NA> 6FR9QMH7+XW9      <NA>\n                                                                              orig_lnk\n1 https://nigeria.africageoportal.com/datasets/GRID3::grid3-nigeria-water-points/about\n2                                                                                 <NA>\n3                                                                                 <NA>\n4                                                                                 <NA>\n5                                                                                 <NA>\n  photo_lnk country_id\n1      <NA>         NG\n2      <NA>         NG\n3      <NA>         NG\n4      <NA>         NG\n5      <NA>         NG\n                                                                                          data_lnk\n1                  https://catalog.waterpointdata.org/datasets/grid3-nigeria-water-points-61ae7cd9\n2 https://catalog.waterpointdata.org/datasets/federal-ministry-of-water-resources-nigeria-5efb3667\n3                                https://catalog.waterpointdata.org/datasets/rain-nigeria-5fe0f6d7\n4                                https://catalog.waterpointdata.org/datasets/rain-nigeria-5fe0f6d7\n5                                https://catalog.waterpointdata.org/datasets/rain-nigeria-5fe0f6d7\n  distance_t  distance_2 distance_3 distance_4 distance_5\n1   767.3742   921.79187  3146.7332   41049.94    959.365\n2 13364.9005    48.87743  4167.5191   13898.65   9405.783\n3  9492.7619  4333.34280   693.2112   27381.92  72060.118\n4  9319.0815 23276.33227   307.7162   34823.61  31665.447\n5  5437.7141 18783.56566   134.6121   40785.89  31240.904\n                                                                                                                                                               water_poin\n1                                                                             {\"2018-08-29\": {\"source\": \"GRID3\", \"status_id\": \"Unknown\", \"water_tech_clean\": \"Tapstand\"}}\n2 {\"2015-08-16\": {\"source\": \"Federal Ministry of Water Resources, Nigeria\", \"status_id\": \"Yes\", \"water_source_clean\": \"Borehole\", \"water_tech_clean\": \"Mechanized Pump\"}}\n3                                           {\"2020-12-04\": {\"source\": \"WaterAid\", \"status_id\": \"Yes\", \"water_source_clean\": \"Borehole\", \"water_tech_clean\": \"Hand Pump\"}}\n4                                                                            {\"2020-12-04\": {\"source\": \"WaterAid\", \"status_id\": \"Yes\", \"water_source_clean\": \"Borehole\"}}\n5                                           {\"2020-12-04\": {\"source\": \"WaterAid\", \"status_id\": \"Yes\", \"water_source_clean\": \"Borehole\", \"water_tech_clean\": \"Hand Pump\"}}\n  rehab_prio served_pop local_popu crucialnes pressure usage_cap is_urban\n1         NA         NA         NA         NA       NA       250     True\n2         NA        140        887  0.1578354 0.140000      1000    False\n3         NA          0          0         NA       NA       300    False\n4         NA        492        492  1.0000000 1.640000       300    False\n5         NA        868       1919  0.4523189 2.893333       300    False\n  days_since staleness_ is_latest location_i cluster_si clean_co_2 country_na\n1       1483   62.65911         T     358773          1        NGA    Nigeria\n2       2592   44.17405         T     264633          1        NGA    Nigeria\n3        655   81.34550         T     397972          1        NGA    Nigeria\n4        655   81.34550         T     397984          1        NGA    Nigeria\n5        655   81.34550         T     397982          1        NGA    Nigeria\n                      water_so_3 water_tech                  status\n1                            Tap       <NA>                    <NA>\n2 Improved Tube well or borehole  Motorised Functional (and in use)\n3  Borehole fitted with Handpump       <NA>                    <NA>\n4      Gen. set powered borehole       <NA>                    <NA>\n5  Borehole fitted with Handpump       <NA>                    <NA>\n           adm2 adm3 management  adm1 lat_deg_or               lat_lon_de\n1          <NA> <NA>       <NA>  <NA>         NA           (7.98?, 5.12?)\n2 Obafemi-Owode <NA>      Other  Ogun         NA (6.9645317?, 3.5976683?)\n3          <NA> <NA>       <NA> Enugu         NA     (6.48694?, 7.92972?)\n4          <NA> <NA>       <NA> Enugu         NA     (6.72757?, 7.64867?)\n5          <NA> <NA>       <NA> Enugu         NA      (6.7799?, 7.66485?)\n  lon_deg_or\n1         NA\n2         NA\n3         NA\n4         NA\n5         NA\n                                                                                              public_dat\n1                   https://catalog.waterpointdata.org/datafiles/grid3-nigeria-water-points-61ae7cd9.csv\n2 https://catalog.waterpointdata.org/datafiles/federal-ministry-of-water-resources-nigeria-5efb3667.xlsx\n3                                https://catalog.waterpointdata.org/datafiles/rain-nigeria-5fe0f6d7.xlsx\n4                                https://catalog.waterpointdata.org/datafiles/rain-nigeria-5fe0f6d7.xlsx\n5                                https://catalog.waterpointdata.org/datafiles/rain-nigeria-5fe0f6d7.xlsx\n                                              converted count date_creat\n1                                                  <NA>     1 2021-12-06\n2 #status_id, #water_source, #pay, #status, #management     1 2020-06-30\n3                                                  <NA>     1 2020-12-21\n4                                                  <NA>     1 2020-12-21\n5                                                  <NA>     1 2020-12-21\n    time_creat date_updat   time_updat                  geometry\n1 21:12:57.000 2021-12-06 21:12:57.000         POINT (5.12 7.98)\n2 12:56:07.000 2020-06-30 12:56:07.000 POINT (3.597668 6.964532)\n3 19:26:15.000 2020-12-21 19:26:15.000   POINT (7.92972 6.48694)\n4 19:26:15.000 2020-12-21 19:26:15.000   POINT (7.64867 6.72757)\n5 19:26:15.000 2020-12-21 19:26:15.000    POINT (7.66485 6.7799)\n\n\nNow we will write the filtered data table into a new rds file named wp_nga using the write_rds() function from the sf package.\n\n\nShow code\nwrite_rds(wp, \"data/wp_nga.rds\")\n\n\nFrom this point on, we will work on the wp_nga file.\n\n\nExploring the water point status data\nFrom the result of the code above, we notice that column status_cle has NA values. Since our goal is to examine the functionality of the water points, the data in status_cle should be transformed to remove the NA values. One way to do it is to recode the NA values to “Unknown”. replace_na() from the tidyr package is used to do the mentioned task.\nTo preserve the existing variables while adding new ones, mutate() from the dplyr package is used.\nAll changes are written into the wp_nga file using read_rds().\n\n\nShow code\nwp_nga <- read_rds(\"data/wp_nga.rds\") %>%\n  mutate(status_cle = replace_na(status_cle, \"Unknown\"))\n\n\nLet’s look at the distribution of status_cle. We will use freq() from the funModeling package for this task.\n\n\nShow code\nfreq(data=wp_nga, \n     input = 'status_cle')\n\n\n\n\n\n                        status_cle frequency percentage cumulative_perc\n1                       Functional     45883      48.29           48.29\n2                   Non-Functional     29385      30.93           79.22\n3                          Unknown     10656      11.22           90.44\n4      Functional but needs repair      4579       4.82           95.26\n5 Non-Functional due to dry season      2403       2.53           97.79\n6        Functional but not in use      1686       1.77           99.56\n7         Abandoned/Decommissioned       234       0.25           99.81\n8                        Abandoned       175       0.18           99.99\n9 Non functional due to dry season         7       0.01          100.00\n\n\nWe can see that there are two variables that carry the same meaning: Non-Functional due to dry season and Non functional due to dry season. We will use replace() from dplyr to do this task.\n\n\nShow code\nwp_nga <- read_rds(\"data/wp_nga.rds\") %>%\n  mutate(status_cle = replace(status_cle, status_cle == \"Non functional due to dry season\", \"Non-Functional due to dry season\")) %>%\n  mutate(status_cle = replace_na(status_cle, \"Unknown\"))\n\n\nLet’s re-examine the distribution of status_cle.\n\n\nShow code\nfreq(data=wp_nga, \n     input = 'status_cle')\n\n\n\n\n\n                        status_cle frequency percentage cumulative_perc\n1                       Functional     45883      48.29           48.29\n2                   Non-Functional     29385      30.93           79.22\n3                          Unknown     10656      11.22           90.44\n4      Functional but needs repair      4579       4.82           95.26\n5 Non-Functional due to dry season      2410       2.54           97.80\n6        Functional but not in use      1686       1.77           99.57\n7         Abandoned/Decommissioned       234       0.25           99.82\n8                        Abandoned       175       0.18          100.00\n\n\n\n\nExtracting non-functional water point data\nNon-functional water points are defined as those which are not functional or abandoned. Using filter() from the dplyr package, we will save the non-functional water point data into a simple feature data table named wpt_nonfunctional.\n\n\nShow code\nwpt_nonfunctional <- wp_nga %>%\n  filter(status_cle %in%\n           c(\"Abandoned/Decommissioned\", \n             \"Abandoned\",\n             \"Non-Functional\",\n             \"Non-Functional due to dry season\"))\n\n\nNow we can inspect the distribution of non-functional water points by type using freq().\n\n\nShow code\nfreq(data = wpt_nonfunctional, input = \"status_cle\")\n\n\n\n\n\n                        status_cle frequency percentage cumulative_perc\n1                   Non-Functional     29385      91.25           91.25\n2 Non-Functional due to dry season      2410       7.48           98.73\n3         Abandoned/Decommissioned       234       0.73           99.46\n4                        Abandoned       175       0.54          100.00\n\n\n\n\n\nnga aspatial data\n\nChecking the CRS of aspatial data\nWe will check the CRS of nga using st_geometry().\n\n\nShow code\nst_geometry(nga)\n\n\nGeometry set for 774 features \nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2.668534 ymin: 4.273007 xmax: 14.67882 ymax: 13.89442\nGeodetic CRS:  WGS 84\nFirst 5 geometries:\n\n\nAs the CRS of nga is WGS84, we will assign crs = 4326 using st_set_crs().\n\n\nShow code\nnga <- st_set_crs(nga, 4326)\n\n\nNext, we plot the geometry using plot() of Base R. As our data is the regions of Nigeria by administrative division management level 2, the map below depicts the 774 Local Government Areas of Nigeria.\nFrom the map, it is noticeable that the size of government areas varies significantly. Let’s keep this in mind for further analysis 💪\n\n\nShow code\nplot(st_geometry(nga))\n\n\n\n\n\n\n\n\nPerforming Point-in-Polygon Count\nBecause the geometry type of our geospatial data is point, we need to compute the number of points inside each polygon. The functions below will be used for that task.\n\nmutate(): preserves the existing variables while adding new variables, from dplyr package\nst_intersects(): spatial intersect predicate for stars and sfc object, from stars package, a sub-package of tmap.\nlengths(): get the length of each element of a list or atomic vector as an integer or numeric vector, from Base R.\n\nAfter the aggregation, the output will in in polygon geometry shape.\n\n\nShow code\nnga_wp <- nga %>%\n  mutate(`total wpt` = lengths(\n    st_intersects(nga, wp_nga))) %>% \n  mutate(`wpt non-functional` = lengths(\n    st_intersects(nga, wpt_nonfunctional)))\n\n\n\n\nSaving the analytical data table\nBefore saving the data table, we will compute the percentage of non-functional water points over the total number of water points in Nigeria.\n\n\nShow code\nnga_wp <- nga_wp %>% \n  mutate(`pct_non-functional` = `wpt non-functional`/`total wpt`)\n\n\nNow, we will save the sf data table nga_wp into a new rds file.\n\n\nShow code\nwrite_rds(nga_wp, \"data/nga_wp.rds\")"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#visualizing-the-data",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#visualizing-the-data",
    "title": "Take-home Exercise 1: How Functional are the Water Points in Nigeria?",
    "section": "Visualizing the Data",
    "text": "Visualizing the Data\nFirst, let’s reload the nga_wp.rds file into our working environment.\n\n\nShow code\nnga_wp <- read_rds(\"data/nga_wp.rds\")\n\n\n\nDisplaying non-functional water points with choropleth map\nTo create the plots, we will use the tm_shape() and tm_fill() functions from tmap package. In addition, tm_borders() and tm_layout() will be used to customize the style of the map. Below are the functionality of the functions.\n\ntm_shape: creates a tmap element that specifies the spatial data object.\ntm_fill: creates a tmap element that draws the polygons.\ntm_borders: creates a tmap element that defines the border of the polygons.\ntm_layout: specifies the map layout\n\n\n\nShow code\nwp_pretty <- tm_shape(nga_wp) + \n  tm_fill(\"wpt non-functional\",\n          title = \"Water Point Count\") +\n  tm_layout(main.title = \"Pretty Classification\",\n            main.title.position = \"center\",\n            main.title.size = 2,\n            legend.height = 0.25,\n            legend.width = 0.3,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n\nwp_quantile <- tm_shape(nga_wp) + \n  tm_fill(\"wpt non-functional\",\n          title = \"Water Point Count\",\n          style = \"quantile\") +\n  tm_layout(main.title = \"Quantile Classification\",\n            main.title.position = \"center\",\n            main.title.size = 2,\n            legend.height = 0.25,\n            legend.width = 0.3,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n\nwp_equal <- tm_shape(nga_wp) + \n  tm_fill(\"wpt non-functional\",\n          title = \"Water Point Count\",\n          style = \"equal\") +\n  tm_layout(main.title = \"Equal Classification\",\n            main.title.position = \"center\",\n            main.title.size = 2,\n            legend.height = 0.25,\n            legend.width = 0.3,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n\nwp_jenks <- tm_shape(nga_wp) + \n  tm_fill(\"wpt non-functional\",\n          title = \"Water Point Count\",\n          style = \"jenks\") +\n  tm_layout(main.title = \"Jenks Classification\",\n            main.title.position = \"center\",\n            main.title.size = 2,\n            legend.height = 0.25,\n            legend.width = 0.3,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n\n\n\n\nShow code\nwp_equal\n\n\n\n\n\nShow code\nwp_pretty\n\n\n\n\n\nShow code\nwp_jenks\n\n\n\n\n\nShow code\nwp_quantile\n\n\n\n\n\nFrom the maps above, we can see that different interval classification produces different map views.\npretty and equal methods divide the values into groups of equally-spaced values, so they can smooth out the distribution of non-functional water points.\nThe Jenks method produces well-balanced intervals. By definition, the Jenks method defines intervals so that they have the smallest in-class variance. This makes the Jenks method more suitable for high-variance data sets like nga_wp.\nThe quantile method produces a rather dire situation with a large area of land having the highest numbers of non-functional water points. However, the range of the highest quantile is relatively huge comparing to other quantiles, suggesting high variance data. We can say that the quantile method exaggerates the disfunctionality of water points in Nigeria due to outliers.\n\nDisplaying data distribution with histogram\nTo confirm the distribution of the data, we will use a histogram. From the histogram, it is clear that the data is highly skewed toward the right.\n\n\nShow code\nhist(nga_wp$`wpt non-functional`, xlab = \"Non-functional Water Point Count\",\n     main = \"Histogram of non-functional water points\")"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#global-spatial-autocorrelation",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#global-spatial-autocorrelation",
    "title": "Take-home Exercise 1: How Functional are the Water Points in Nigeria?",
    "section": "Global Spatial Autocorrelation",
    "text": "Global Spatial Autocorrelation\nBased on the maps above, we see that there are some areas with a higher number of non-functional water points than others. Is there a pattern for the distribution of the non-functional water points or do they just occur randomly? To answer that question, we will explore the global spatial autocorrelation of non-functional water points in Nigeria.\n\nComputing Spatial Weights\nLet’s consider four spatial weight methods.\n\nPolygon Contiguity: this method defines the neighbor based on contiguity and is effective when the polygons are similar in size and distribution, and when spatial relationships are a function of polygon proximity. In this case, the size of the government areas of Nigeria have significantly varying sizes. Therefore, polygon contiguity is not a good fit.\nFixed Distance: this method is effective for polygon data with large variation in polygon size (very large polygons at the edge of the study area, and very small polygons at the center of the study areas). On the map, we can see that Nigeria has very small government areas in the south, while bigger areas are scattered in the rest of the country, together with smaller areas in between. Therefore, the Fixed Distance method is not a good fit.\nInverse Distance: this method is appropriate for with continuous data or to model the process where the closer the features are, the more likely they are going to interact/affect the other. The downside of this approach is that it considers every feature is potentially a neighbor of every other feature. Therefore, the method is computationally costly. Since our data set has up to 774 observations, this method is not appropriate considering the capability of our personal computer.\nAdaptive Distance (K Nearest Neighbor): this method is effective when the values associate with the features are skewed. Because our data is skewed to the right, this method is a good fit.\n\n\nConverting data into projected coordinate system\nBecause Adaptive Distance spatial weight method is distance-based spatial weight method, the data needs to be converted into projected coordinate system. The EPSG code we will convert the data into is EPSG:26391, used for Nigeria West Belt. We will use st_transform() from the sf package for the task.\n\n\nShow code\nnga_wp <- st_transform(nga_wp, crs = 26391)\n\n\n\n\nComputing Adaptive Weight Matrix\nAs a rule of thumb, when computing adaptive weight matrix, we should ensure that each feature has at least 8 neighbors. To do the task, the functions below are called:\n\nknn2nb(): converts a knn object returned by knearneigh into a neighbors list of class nb with a list of integer vectors containing neighbor region number ids.\nknearneigh(): returns a matrix with the indices of points belonging to the set of the k nearest neighbours of each other.\nmap_dbl(): returns an atomic vector of the indicative type.\nst_centroid(): calculates and retrieve the centroid of the feature.\ncbind(): merges two data frames/vectors/matrices together\n\n\n\nShow code\n#Calculate the longitude and latitude\nlongitude <- map_dbl(nga_wp$geometry, ~st_centroid(.x)[[1]])\nlatitude <- map_dbl(nga_wp$geometry, ~st_centroid(.x)[[2]])\ncoords <- cbind(longitude, latitude)\nwp_k8 <- knn2nb(knearneigh(coords, k = 8))\n\n\nDisplaying the content of wp_k8 matrix using str(). Each feature has 8 neighbors.\n\n\nShow code\nstr(wp_k8)\n\n\nList of 774\n $ : int [1:8] 2 321 364 548 597 624 721 725\n $ : int [1:8] 1 321 548 597 624 721 725 726\n $ : int [1:8] 241 250 261 447 492 507 509 526\n $ : int [1:8] 12 20 257 263 446 454 466 690\n $ : int [1:8] 203 208 286 288 331 334 539 738\n $ : int [1:8] 170 217 218 337 379 553 577 601\n $ : int [1:8] 8 176 214 281 283 306 544 555\n $ : int [1:8] 7 214 281 306 327 544 555 651\n $ : int [1:8] 18 19 218 337 574 576 601 757\n $ : int [1:8] 25 216 325 364 365 528 552 632\n $ : int [1:8] 26 27 43 68 191 524 565 762\n $ : int [1:8] 135 263 417 429 446 454 690 695\n $ : int [1:8] 31 37 211 320 393 570 583 584\n $ : int [1:8] 170 363 379 546 563 577 581 589\n $ : int [1:8] 22 49 82 177 297 306 580 623\n $ : int [1:8] 30 187 188 296 328 357 360 635\n $ : int [1:8] 35 275 295 378 460 591 638 639\n $ : int [1:8] 9 19 218 376 574 576 601 757\n $ : int [1:8] 9 18 56 103 376 574 576 601\n $ : int [1:8] 4 106 125 239 263 419 454 466\n $ : int [1:8] 60 61 162 269 520 578 596 626\n $ : int [1:8] 49 297 326 443 515 623 682 693\n $ : int [1:8] 54 291 292 536 537 614 618 619\n $ : int [1:8] 84 123 437 476 527 652 673 761\n $ : int [1:8] 10 181 216 314 325 366 552 730\n $ : int [1:8] 11 27 68 191 336 439 562 762\n $ : int [1:8] 11 26 191 439 562 565 663 762\n $ : int [1:8] 29 178 299 300 301 358 369 598\n $ : int [1:8] 172 173 178 182 358 378 460 591\n $ : int [1:8] 16 39 41 186 192 329 357 360\n $ : int [1:8] 13 37 211 289 561 570 583 584\n $ : int [1:8] 51 62 461 462 515 623 682 693\n $ : int [1:8] 47 166 227 238 242 655 743 750\n $ : int [1:8] 42 104 136 137 213 553 559 757\n $ : int [1:8] 17 275 276 277 278 279 295 460\n $ : int [1:8] 50 107 247 408 432 455 681 759\n $ : int [1:8] 38 40 211 212 570 583 584 629\n $ : int [1:8] 30 39 40 41 186 192 320 570\n $ : int [1:8] 30 38 40 41 186 192 320 329\n $ : int [1:8] 37 38 39 41 186 192 320 570\n $ : int [1:8] 30 38 39 40 186 192 360 634\n $ : int [1:8] 86 136 137 499 587 613 718 734\n $ : int [1:8] 11 68 157 524 549 565 590 645\n $ : int [1:8] 16 45 192 290 303 328 360 634\n $ : int [1:8] 44 187 290 303 328 341 360 599\n $ : int [1:8] 387 417 429 438 459 521 668 742\n $ : int [1:8] 33 111 166 234 238 691 698 750\n $ : int [1:8] 65 113 265 386 407 428 482 701\n $ : int [1:8] 22 32 297 326 515 623 682 693\n $ : int [1:8] 36 98 107 247 409 416 432 681\n $ : int [1:8] 32 62 461 462 515 580 623 693\n $ : int [1:8] 53 78 165 293 532 602 603 636\n $ : int [1:8] 52 78 80 165 280 602 621 636\n $ : int [1:8] 23 79 293 294 532 536 537 618\n $ : int [1:8] 122 169 246 333 430 571 605 697\n $ : int [1:8] 77 368 376 533 534 576 601 728\n $ : int [1:8] 53 58 199 312 322 323 621 622\n $ : int [1:8] 57 322 323 564 602 603 621 622\n $ : int [1:8] 88 128 129 259 493 700 714 748\n $ : int [1:8] 61 158 563 578 589 592 596 626\n $ : int [1:8] 21 60 269 578 589 592 596 626\n $ : int [1:8] 32 51 461 462 515 623 682 693\n $ : int [1:8] 90 237 384 416 467 497 765 772\n $ : int [1:8] 48 65 74 113 131 265 386 407\n $ : int [1:8] 48 64 74 113 265 407 683 701\n $ : int [1:8] 19 103 104 288 331 338 351 574\n $ : int [1:8] 347 348 560 566 567 609 640 694\n $ : int [1:8] 11 43 157 190 191 549 590 645\n $ : int [1:8] 140 146 248 274 473 500 512 513\n $ : int [1:8] 71 298 299 301 341 343 344 610\n $ : int [1:8] 70 172 173 298 299 343 344 625\n $ : int [1:8] 17 361 566 567 568 609 638 639\n $ : int [1:8] 72 361 374 377 404 607 665 666\n $ : int [1:8] 65 109 113 251 265 683 741 754\n $ : int [1:8] 110 272 398 422 433 485 501 768\n $ : int [1:8] 254 287 427 459 470 547 647 677\n $ : int [1:8] 56 195 533 534 579 618 619 728\n $ : int [1:8] 52 54 79 80 165 215 532 636\n $ : int [1:8] 54 78 165 293 532 579 618 636\n $ : int [1:8] 52 53 78 165 215 280 636 739\n $ : int [1:8] 99 145 227 233 426 483 689 760\n $ : int [1:8] 15 32 49 51 177 352 580 623\n $ : int [1:8] 132 258 383 414 433 529 767 768\n $ : int [1:8] 24 131 148 386 437 482 673 692\n $ : int [1:8] 105 156 267 394 654 675 707 712\n $ : int [1:8] 42 136 137 499 587 613 718 734\n $ : int [1:8] 149 151 221 226 399 410 486 657\n $ : int [1:8] 59 116 128 150 489 648 700 714\n $ : int [1:8] 260 408 463 542 674 676 681 759\n $ : int [1:8] 63 163 236 237 384 452 710 765\n $ : int [1:8] 160 271 388 406 473 475 492 525\n $ : int [1:8] 95 119 390 391 392 423 487 656\n $ : int [1:8] 73 354 374 402 594 607 665 666\n $ : int [1:8] 13 31 60 158 436 561 596 709\n $ : int [1:8] 92 390 391 392 405 423 469 656\n $ : int [1:8] 97 139 389 403 420 451 488 653\n $ : int [1:8] 96 168 389 420 451 653 662 773\n $ : int [1:8] 50 117 153 231 409 432 696 708\n $ : int [1:8] 81 145 426 483 667 689 760 769\n  [list output truncated]\n - attr(*, \"region.id\")= chr [1:774] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language knearneigh(x = coords, k = 8)\n - attr(*, \"sym\")= logi FALSE\n - attr(*, \"type\")= chr \"knn\"\n - attr(*, \"knn-k\")= num 8\n - attr(*, \"class\")= chr \"nb\"\n\n\nNow we can plot the adaptive spatial weight matrix.\n\n\nShow code\nplot(nga_wp$geometry, border = \"lightgrey\", main = \"K Nearest Neighbor Matrix\")\nplot(wp_k8, coords, pch = 19, cex = 0.2, add = TRUE, col = \"red\")\n\n\n\n\n\n\n\nRow standardized weight matrix\nWe will compute a row standardized weight matrix based on wp_k8 by using nb2listw() from spdep package. Since the data has 774 observations, which is a high number, style = \"B\" is used for a more robust analysis.\n\n\nShow code\nwp_rsw <- nb2listw(wp_k8, style = \"B\", zero.policy = TRUE)\nwp_rsw\n\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 774 \nNumber of nonzero links: 6192 \nPercentage nonzero weights: 1.033592 \nAverage number of links: 8 \nNon-symmetric neighbours list\n\nWeights style: B \nWeights constants summary:\n    n     nn   S0    S1     S2\nB 774 599076 6192 11154 201940\n\n\n\n\n\nGlobal Spatial Autocorrelation: Moran’s I\n\nMoran’s I test\nTo perform the Moran’s I test, we will use moran.test() from spdep package.\n\n\nShow code\nmoran.test(nga_wp$`wpt non-functional`, listw = wp_rsw, zero.policy = TRUE, na.action = na.omit)\n\n\n\n    Moran I test under randomisation\n\ndata:  nga_wp$`wpt non-functional`  \nweights: wp_rsw    \n\nMoran I statistic standard deviate = 22.72, p-value < 2.2e-16\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n     0.3830962455     -0.0012936611      0.0002862476 \n\n\nBecause the p-value of the test is less than 0.05, we reject the null hypothesis that the non-functional water points are spatially random at 95% confident interval. As the Moran statistic is 0.383, greater than 0, we can say that the non-functional water point observations are clustered.\n\n\nMonte Carlo Moran’s I\nTo compute 1,000 simulations of Monte Carlo Moran’s I, we will use moran.mc() from spdep package.\n\n\nShow code\nset.seed(1234)\nmc_moran = moran.mc(nga_wp$`wpt non-functional`,\n                    listw = wp_rsw,\n                    nsim = 999,\n                    zero.policy = TRUE,\n                    na.action = na.omit)\nmc_moran\n\n\n\n    Monte-Carlo simulation of Moran I\n\ndata:  nga_wp$`wpt non-functional` \nweights: wp_rsw  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.3831, observed rank = 1000, p-value = 0.001\nalternative hypothesis: greater\n\n\nAs p-value is 0.001 and less than 0.05, we reject the null hypothesis of spatial randomness among the non-functional water point observations. The statistic of the Moran’s I simulations is 0.3831, greater than 0, corroborating the test result that similar non-functional water point observations are clustered.\n\n\nVisualzing Monte Carlo Moran’s I\n\n\nShow code\nsummary(mc_moran$res)\n\n\n      Min.    1st Qu.     Median       Mean    3rd Qu.       Max. \n-0.0577464 -0.0127344 -0.0011002 -0.0002353  0.0109820  0.3830962 \n\n\n\n\nShow code\nhist(mc_moran$res,\n     freq = TRUE,\n     breaks = 20,\n     xlab = \"Simulated Moran's I\",\n     main = \"Histogram of Moran's I Simulation\")\nabline(v = 0, col = \"red\")\n\n\n\n\n\nWe can see that the min of the Moran’s I value is less than 0, while the max value is 0.38. The Moran’s I data is approaching 1, inferring similar values are clustered. In layman terms, government areas with similar number of non-functional water points tend to be closer together and form some clusters.\n\n\n\nGlobal Spatial Autocorrelation: Geary’s C\nThe following section will focus on Geary’s C test and Geary’s C Monte Carlo simulation using the functions from spdep package.\n\nGeary’s C Test\n\n\nShow code\ngeary.test(nga_wp$`wpt non-functional`, listw = wp_rsw)\n\n\n\n    Geary C test under randomisation\n\ndata:  nga_wp$`wpt non-functional` \nweights: wp_rsw \n\nGeary C statistic standard deviate = 19.419, p-value < 2.2e-16\nalternative hypothesis: Expectation greater than statistic\nsample estimates:\nGeary C statistic       Expectation          Variance \n     0.6045301723      1.0000000000      0.0004147472 \n\n\nBecause p-value is 0.001 and less than 0.05, we reject the null hypothesis of spatial randomness among the non-functional water point observations with 95% confident interval. The statistic of the Geary’s C simulations is 0.605, less than 1, we can say that the data tend to cluster among similar observations.\n\n\nMonte Carlo Geary’s C\nWe will compute 1000 simulations of Geary’s C using geary.mc().\n\n\nShow code\nset.seed(1234)\nmc_geary = geary.mc(nga_wp$`wpt non-functional`, listw = wp_rsw, nsim = 999)\nmc_geary\n\n\n\n    Monte-Carlo simulation of Geary C\n\ndata:  nga_wp$`wpt non-functional` \nweights: wp_rsw \nnumber of simulations + 1: 1000 \n\nstatistic = 0.60453, observed rank = 1, p-value = 0.001\nalternative hypothesis: greater\n\n\nThe result of the simulation corroborates the previous Geary’s C test with p-value less than 0.05 and Geary’s C statistic less than 1.\n\n\nVisualizing Monte Carlo Geary’s C\n\n\nShow code\nsummary(mc_geary$res)\n\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.6045  0.9857  0.9995  0.9987  1.0128  1.0690 \n\n\n\n\nShow code\nhist(mc_geary$res,\n     freq = TRUE,\n     breaks = 20,\n     main = \"Histogram of Geary's C Simulation\",\n     xlab = \"Simulated Geary's C\")\nabline(v = 1, col = \"red\")\n\n\n\n\n\nWe can see that the min Geary’s C is less than 1, while the max is greater than 1. The Geary’s C data is approaching 0, meaning similar values are clustered. This result again is similar to Moran’s I. We have areas with similar number of non-functional water points clustering together."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#spatial-correlogram-with-morans-i",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#spatial-correlogram-with-morans-i",
    "title": "Take-home Exercise 1: How Functional are the Water Points in Nigeria?",
    "section": "Spatial Correlogram with Moran’s I",
    "text": "Spatial Correlogram with Moran’s I\nWe will use sp.correlogram() from spdep package to compute a 6-lag spatial correlogram of non-functional water points.\n\n\nShow code\nMI_corr <- sp.correlogram(wp_k8, \n                          nga_wp$`wpt non-functional`, \n                          order=10, \n                          method=\"I\", \n                          style=\"W\")\nplot(MI_corr, main = \"Moran's I Correlogram of Non-functional Water Points\")\n\n\n\n\n\n\n\nShow code\nprint(MI_corr)\n\n\nSpatial correlogram for nga_wp$`wpt non-functional` \nmethod: Moran's I\n            estimate expectation    variance standard deviate Pr(I) two sided\n1 (774)   3.8310e-01 -1.2937e-03  2.8625e-04          22.7196       < 2.2e-16\n2 (774)   2.4978e-01 -1.2937e-03  1.4428e-04          20.9027       < 2.2e-16\n3 (774)   1.7519e-01 -1.2937e-03  9.8557e-05          17.7769       < 2.2e-16\n4 (774)   1.1512e-01 -1.2937e-03  7.3007e-05          13.6241       < 2.2e-16\n5 (774)   7.3384e-02 -1.2937e-03  5.7171e-05           9.8765       < 2.2e-16\n6 (774)   3.3259e-02 -1.2937e-03  4.7493e-05           5.0137       5.338e-07\n7 (774)   2.3599e-03 -1.2937e-03  4.1538e-05           0.5669       0.5708000\n8 (774)  -2.3438e-02 -1.2937e-03  3.7172e-05          -3.6322       0.0002811\n9 (774)  -5.8066e-02 -1.2937e-03  3.4217e-05          -9.7054       < 2.2e-16\n10 (774) -9.0732e-02 -1.2937e-03  3.2640e-05         -15.6549       < 2.2e-16\n            \n1 (774)  ***\n2 (774)  ***\n3 (774)  ***\n4 (774)  ***\n5 (774)  ***\n6 (774)  ***\n7 (774)     \n8 (774)  ***\n9 (774)  ***\n10 (774) ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nThe higher the lag value, the lower the estimation of Moran’s I value. From lag 8, the values start to be dispersed with Moran’s I estimation less than 0. Except for lag 7, we can reject the null hypothesis of spatial randomness for other lag values."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#cluster-and-outlier-analysis",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#cluster-and-outlier-analysis",
    "title": "Take-home Exercise 1: How Functional are the Water Points in Nigeria?",
    "section": "Cluster and Outlier Analysis",
    "text": "Cluster and Outlier Analysis\nIn this segment, we will examine the existence of clusters in the spatial arrangement of non-functional water points. The statistical method we will use is Local Indicators of Spatial Association, or LISA for short.\n\nComputing local Moran’s I\nTo compute local Moran's I, the localmoran() function of spdep will be used. We will display the local Moran matrix using printCoefmat().\n\n\nShow code\nfips <- order(nga_wp$shapeName)\nlocalMI <- localmoran(nga_wp$`wpt non-functional`, wp_rsw)\nhead(localMI)\n\n\n           Ii          E.Ii       Var.Ii       Z.Ii Pr(z != E(Ii))\n1 -0.64557011 -7.996194e-03 6.1268059630 -0.2575808    0.796730455\n2 -0.18338854 -3.273970e-04 0.2510973197 -0.3653214    0.714871500\n3 10.06559878 -1.302147e-02 9.9709777352  3.1917746    0.001414017\n4 -0.25538147 -4.342004e-04 0.3330057298 -0.4417988    0.658634818\n5  0.73333147 -2.072772e-03 1.5893664318  0.5833297    0.559671349\n6  0.06300119 -1.230756e-06 0.0009439673  2.0505897    0.040306916\n\n\n\n\nMapping the local Moran’s I\nBefore mapping the local Moran’s I, we will append the local Moran’s dataframe localMI into nga_wp using cbind().\n\n\nShow code\nnga_wp.LMI <- cbind(nga_wp, localMI) %>% \n  rename(Pr.Ii = Pr.z....E.Ii..)\n\n\nNow we can map the local Moran’s I statistics and their p-values.\n\n\nShow code\nlocalMI.map <- tm_shape(nga_wp.LMI) +\n  tm_fill(col = \"Ii\",\n          style = \"pretty\",\n          title = \"Local Moran Stats\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.height = 0.25,\n            legend.width = 0.3)\n\npvalueMI <- tm_shape(nga_wp.LMI) +\n  tm_fill(col = \"Pr.Ii\",\n          breaks = c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),\n          palette = \"-Blues\",\n          title = \"Local Moran p-value\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.height = 0.25,\n            legend.width = 0.3)\n\ntmap_arrange(localMI.map, pvalueMI, asp = 1, ncol = 2)\n\n\n\n\n\nWhere p-values are less than 0.05, we can reject the null hypothesis of local spatial randomness. The areas with darker color on the p-value map is where the observations of non-functional water points are not distributed randomly."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#lisa-cluster-map",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#lisa-cluster-map",
    "title": "Take-home Exercise 1: How Functional are the Water Points in Nigeria?",
    "section": "LISA Cluster Map",
    "text": "LISA Cluster Map\n\nPlotting Moran scatterplots\nWith Moran scatterplot, we can see the relationship between the value of the chosen attribute at each location and the average value of the same attribute at neighboring locations. The Moran scatterplot is drawn using moran.plot() from spdep package.\nTwo scatterplots will be drawn. One with non-standardized variable and the other one with standardized variable.\nFirst, we will use scale to standardize the variables.\n\n\nShow code\nnga_wp$Z.wptnon <- scale(nga_wp$`wpt non-functional`) %>% \n  as.vector\n\n\nThe two scatterplots are drafted as below.\n\n\nShow code\nnci <- moran.plot(nga_wp$`wpt non-functional`, wp_rsw,\n                  labels = FALSE, \n                  xlab = \"Non-functional Water Points\", \n                  ylab = \"Spatially Lag Non-functional Water Points\")\n\n\n\n\n\nShow code\nnci2 <- moran.plot(nga_wp$Z.wptnon, wp_rsw,\n                   labels = FALSE,\n                   xlab = \"z-Nonfunctional Water Points\",\n                   ylab = \"Spatially Lag z-Nonfunctional Water Points\")\n\n\n\n\n\nWe can see that there are many observations in the high-high and low-high regions. We also have some observations in the high-low region. Let’s use the choropleth map to see more!\n\n\nPlotting LISA map\nBefore drawing the map, we need to prepare the data so that the observations are grouped into the four classes (quadrants) as displayed in the scatterplots.\n\n\nShow code\nquadrant <- vector(mode = \"numeric\", length = nrow(localMI))\nnga_wp$lag_wptnon <- lag.listw(wp_rsw, nga_wp$`wpt non-functional`)\nDV <- nga_wp$lag_wptnon - mean(nga_wp$lag_wptnon)\nLM_I <- localMI[,1] - mean(localMI[,1])\nsignif <- 0.5\nquadrant[DV <0 & LM_I>0] <- 1\nquadrant[DV >0 & LM_I<0] <- 2\nquadrant[DV <0 & LM_I<0] <- 3  \nquadrant[DV >0 & LM_I>0] <- 4\nquadrant[localMI[,5]>signif] <- 0\n\n\nBelow is the LISA map in comparison with the aggregate map of non-functional water point count. For the aggregate map, we will display wp_jenks, which is based on Jenks classification.\n\n\nShow code\nnga_wp.LMI$quadrant <- quadrant\ncolors <- c(\"#ffffff\", \"#2c7bb6\", \"#abd9e9\", \"#fdae61\", \"#d7191c\")\nclusters <- c(\"insignificant\", \"low-low\", \"low-high\", \"high-low\", \"high-high\")\n\nLISAmap <- tm_shape(nga_wp.LMI) +\n  tm_fill(col = \"quadrant\", \n          style = \"cat\", \n          palette = colors[c(sort(unique(quadrant)))+1], \n          labels = clusters[c(sort(unique(quadrant)))+1],\n          popup.vars = c(\"\")) +\n  tm_view(set.zoom.limits = c(11,17)) +\n  tm_borders(alpha=0.5) +\n  tm_layout(main.title = \"LISA Map\",\n            main.title.size = 1,\n            main.title.position = \"center\",\n            legend.height = 0.25,\n            legend.width = 0.3)\n\nwp_jenks1 <- wp_jenks + tm_layout(main.title = \"Aggregated Map (Jenks)\",\n                                  main.title.size = 1,\n                                  frame = TRUE)\n\ntmap_arrange(wp_jenks1, LISAmap, \n             asp=1, ncol=2)\n\n\n\n\n\nThe LISA map highlight the areas where spatial autocorrelation is statistically significant. The red polygons depict clusters of government areas that have a high number of non-functional water points. They are surrounded by clusters of low number of non-functional water points. The blue polygons are clusters of areas with low number of non-functional water points. Except for the east regions, those areas are surrounded by clusters of areas with more non-functional water points, which are shown in orange.\nBy comparing the LISA map with the aggregated map, we can see that the LISA map highlights the pattern of non-functional water points distribution better, especially when we want to compare how area clusters are different from their neighbors.\nInterestingly enough, the low-low areas in the north east overlap with the states that have lower population density. The small orange dot in the east is Maiduguri, the largest city in north-eastern Nigeria. In contrast, Lagos, the largest city of Nigeria lying on the south western coast, belongs to the low-low category. This Lagos pattern repeats in the northern city of Kano, Nigeria’s second largest city."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#hot-spot-and-cold-spot-analysis",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#hot-spot-and-cold-spot-analysis",
    "title": "Take-home Exercise 1: How Functional are the Water Points in Nigeria?",
    "section": "Hot Spot and Cold Spot Analysis",
    "text": "Hot Spot and Cold Spot Analysis\nAn alternative to detect spatial anomalies besides Moran’s I LISA is Getis and Ord’s G-statistics. This method is distance-based as it looks into areas within a predefined proximity and identifies if high/low values cluster spatially. Statistically areas of high values are considered hot spots, while areas with low values are considered cold spots.\n\nComputing Gi statistics\nBefore we can map the hot-and-cold-spot map, let’s calculate the Gi statistics using the adaptive distance weight method. The functions used are localG() from spdep. localG() calculates the spatial statistic G, returning a Z-value vector. The higher the Z-value, the higher the clustering intensity. Positive and negative Z-score means high an low clusters, respectively.\nAfter the Z-value vector is calculated, we convert it into an r matrix, then use cbind() to append it to nga_wp. We also rename as.matrix.gi.adaptive. to gstat_adaptive for easier reference.\n\n\nShow code\nfips <- order(nga_wp$shapeName)\ngi.adaptive <- localG(nga_wp$`wpt non-functional`, wp_rsw)\nwp_gi <- cbind(nga_wp, as.matrix(gi.adaptive)) %>% \n  rename(gstat_adaptive = as.matrix.gi.adaptive.)\n\n\n\n\nMapping Gi values\n\n\nShow code\nGimap <- tm_shape(wp_gi) + \n  tm_fill(col = \"gstat_adaptive\", \n          style = \"pretty\", \n          palette=\"-RdBu\", \n          title = \"local Gi\") + \n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Gi Map\",\n            main.title.size = 1,\n            main.title.position = \"center\",\n            legend.height = 0.25,\n            legend.width = 0.3)\n\ntmap_arrange(wp_jenks1, Gimap, asp = 1, ncol = 2)\n\n\n\n\n\nWith GI map, we can see the intensity of the cluster values. The Gi map have some hot spots that overlap with the areas containing high number of non-functional water points on the aggregate map. What is interesting is that Gi map shows the “temperature” of those areas in relations with their neighbors."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#comparing-lisa-and-gi-maps",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#comparing-lisa-and-gi-maps",
    "title": "Take-home Exercise 1: How Functional are the Water Points in Nigeria?",
    "section": "Comparing LISA and Gi Maps",
    "text": "Comparing LISA and Gi Maps\n\n\nShow code\ntmap_arrange(LISAmap, Gimap, asp = 1, ncol = 2)\n\n\n\n\n\nThere are some difference in how each method define clusters of similarly high number of non-functional water points by area. However, there are also overlaps between the two maps. LISA map is more effective when we want to display the contrast between the clusters and how they allocate, while Gi map can be used to depict the intensity of the cluster and values."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#conclusion-and-improvement",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#conclusion-and-improvement",
    "title": "Take-home Exercise 1: How Functional are the Water Points in Nigeria?",
    "section": "Conclusion and Improvement",
    "text": "Conclusion and Improvement\nBased on the LISA and Gi map, there is a consistent pattern of areas with high values of non-functional water points. Those areas with high number of water point malfunctions often cluster together, suggesting the effect of unknown factors affecting the quality of water points.\nThe blue areas regions lead to two hypothesis:\n\nThe blue areas in the south overlap with the Niger Delta. Do the presence of rivers and subsequent infrastructures affect the quality and maintenance of water points?\nThe blue areas in the north east overlap with the states that have low population density. Could it be that low population density leading to less water points installation or less usage, which leading to them malfunction less?\n\nMore data can be collected to determine the correlation of other variable with non-functional water points. There are many potential to continue on identifying the factors that affect water point functionality. Who knows, maybe we will find some solutions to improve Nigerians’ access to fresh water 💧"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex03.html",
    "href": "Hands-on_Ex/Hands-on_Ex03.html",
    "title": "Geographical Segmentation with Spatially Constrained Clustering Techniques",
    "section": "",
    "text": "Grouping areas based on their proximity and attributes is necessary for business decisions. By doing so, we can derive areas with similar attributes to focus or apply different strategies. For some examples, refer to this article.\nIn this exercise, we will practice how to delineate homogeneous region by using geographically referenced multivariate data. There are two major analysis, namely:\n\nhierarchical cluster analysis; and\nspatially constrained cluster analysis."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex03.html#getting-started",
    "href": "Hands-on_Ex/Hands-on_Ex03.html#getting-started",
    "title": "Geographical Segmentation with Spatially Constrained Clustering Techniques",
    "section": "Getting Started",
    "text": "Getting Started\n\nThe analytical question\nIn this hands-on exercise, we are interested to delineate Shan State, Myanmar into homogeneous regions by using multiple Information and Communication technology (ICT) measures, namely: Radio, Television, Land line phone, Mobile phone, Computer, and Internet at home.\n\n\nThe data\nTwo data sets will be used in this exercise:\n\nMyanmar Township Boundaries: a ESRI shapefile consisting of Myanmar townships’ boundary. The data is captured in polygon feature.\nShan-ICT.csv: this is the data captured from the 2014 Population and Housing Census of Myanmar.\n\n\n\nInstalling and loading R packages\nThe R packages needed for this exercise are as follows:\n\nSpatial data handling\n\nsf, rgdal and spdep\n\nAttribute data handling\n\ntidyverse, especially readr, ggplot2 and dplyr\n\nChoropleth mapping\n\ntmap\n\nMultivariate data visualisation and analysis\n\ncorrplot, ggpubr, and heatmaply\n\nCluster analysis\n\ncluster\nClustGeo\n\n\n\npacman::p_load(sf, rgdal, spdep, tidyverse,\n               tmap, corrplot, ggpubr, heatmaply,\n               factoextra, cluster, ClustGeo, NbClust, psych)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex03.html#data-import-and-preparation",
    "href": "Hands-on_Ex/Hands-on_Ex03.html#data-import-and-preparation",
    "title": "Geographical Segmentation with Spatially Constrained Clustering Techniques",
    "section": "Data Import and Preparation",
    "text": "Data Import and Preparation\n\nImporting geospatial data into R environment\nWe will use st_read() to import the shapefile of Myanmar township’s boundary. Using filter(), we will only import the data with ST values of Shan (East), Shan (North), Shan (South). They are the areas belonging to the Shan state in Myanmar.\n\nshan_sf <- st_read(dsn = \"data3/geospatial\", layer = \"myanmar_township_boundaries\") %>% \n  filter(ST %in% c(\"Shan (East)\", \"Shan (North)\", \"Shan (South)\"))\n\nReading layer `myanmar_township_boundaries' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/Hands-on_Ex/data3/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 330 features and 14 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 92.17275 ymin: 9.671252 xmax: 101.1699 ymax: 28.54554\nGeodetic CRS:  WGS 84\n\n\nshan_sf is a simple feature data.frame file. Let’s view the content of the file. Notice that sf.data.frame is conformed to Hardy Wickham’s tidy framework. Therefore, glimpse() can also be used to reveal the few first fields of the data frame.\n\nshan_sf\n\nSimple feature collection with 55 features and 14 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 96.15107 ymin: 19.29932 xmax: 101.1699 ymax: 24.15907\nGeodetic CRS:  WGS 84\nFirst 10 features:\n   OBJECTID           ST ST_PCODE       DT   DT_PCODE        TS  TS_PCODE\n1       163 Shan (North)   MMR015  Mongmit MMR015D008   Mongmit MMR015017\n2       203 Shan (South)   MMR014 Taunggyi MMR014D001   Pindaya MMR014006\n3       240 Shan (South)   MMR014 Taunggyi MMR014D001   Ywangan MMR014007\n4       106 Shan (South)   MMR014 Taunggyi MMR014D001  Pinlaung MMR014009\n5        72 Shan (North)   MMR015  Mongmit MMR015D008    Mabein MMR015018\n6        40 Shan (South)   MMR014 Taunggyi MMR014D001     Kalaw MMR014005\n7       194 Shan (South)   MMR014 Taunggyi MMR014D001     Pekon MMR014010\n8       159 Shan (South)   MMR014 Taunggyi MMR014D001  Lawksawk MMR014008\n9        61 Shan (North)   MMR015  Kyaukme MMR015D003 Nawnghkio MMR015013\n10      124 Shan (North)   MMR015  Kyaukme MMR015D003   Kyaukme MMR015012\n                 ST_2            LABEL2 SELF_ADMIN ST_RG T_NAME_WIN T_NAME_M3\n1  Shan State (North)    Mongmit\\n61072       <NA> State   rdk;rdwf      မိုးမိတ်\n2  Shan State (South)    Pindaya\\n77769       Danu State     yif;w,     ပင်းတယ\n3  Shan State (South)    Ywangan\\n76933       Danu State      &GmiH       ရွာငံ\n4  Shan State (South)  Pinlaung\\n162537       Pa-O State  yifavmif;   ပင်လောင်း\n5  Shan State (North)     Mabein\\n35718       <NA> State     rbdrf;      မဘိမ်း\n6  Shan State (South)     Kalaw\\n163138       <NA> State       uavm      ကလော\n7  Shan State (South)      Pekon\\n94226       <NA> State     z,fcHk       ဖယ်ခုံ\n8  Shan State (South)          Lawksawk       <NA> State   &yfapmuf    ရပ်စောက်\n9  Shan State (North) Nawnghkio\\n128357       <NA> State  aemifcsdK    နောင်ချို\n10 Shan State (North)   Kyaukme\\n172874       <NA> State   ausmufrJ    ကျောက်မဲ\n       AREA                       geometry\n1  2703.611 MULTIPOLYGON (((96.96001 23...\n2   629.025 MULTIPOLYGON (((96.7731 21....\n3  2984.377 MULTIPOLYGON (((96.78483 21...\n4  3396.963 MULTIPOLYGON (((96.49518 20...\n5  5034.413 MULTIPOLYGON (((96.66306 24...\n6  1456.624 MULTIPOLYGON (((96.49518 20...\n7  2073.513 MULTIPOLYGON (((97.14738 19...\n8  5145.659 MULTIPOLYGON (((96.94981 22...\n9  3271.537 MULTIPOLYGON (((96.75648 22...\n10 3920.869 MULTIPOLYGON (((96.95498 22...\n\n\n\nglimpse(shan_sf)\n\nRows: 55\nColumns: 15\n$ OBJECTID   <dbl> 163, 203, 240, 106, 72, 40, 194, 159, 61, 124, 71, 155, 101…\n$ ST         <chr> \"Shan (North)\", \"Shan (South)\", \"Shan (South)\", \"Shan (Sout…\n$ ST_PCODE   <chr> \"MMR015\", \"MMR014\", \"MMR014\", \"MMR014\", \"MMR015\", \"MMR014\",…\n$ DT         <chr> \"Mongmit\", \"Taunggyi\", \"Taunggyi\", \"Taunggyi\", \"Mongmit\", \"…\n$ DT_PCODE   <chr> \"MMR015D008\", \"MMR014D001\", \"MMR014D001\", \"MMR014D001\", \"MM…\n$ TS         <chr> \"Mongmit\", \"Pindaya\", \"Ywangan\", \"Pinlaung\", \"Mabein\", \"Kal…\n$ TS_PCODE   <chr> \"MMR015017\", \"MMR014006\", \"MMR014007\", \"MMR014009\", \"MMR015…\n$ ST_2       <chr> \"Shan State (North)\", \"Shan State (South)\", \"Shan State (So…\n$ LABEL2     <chr> \"Mongmit\\n61072\", \"Pindaya\\n77769\", \"Ywangan\\n76933\", \"Pinl…\n$ SELF_ADMIN <chr> NA, \"Danu\", \"Danu\", \"Pa-O\", NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ST_RG      <chr> \"State\", \"State\", \"State\", \"State\", \"State\", \"State\", \"Stat…\n$ T_NAME_WIN <chr> \"rdk;rdwf\", \"yif;w,\", \"&GmiH\", \"yifavmif;\", \"rbdrf;\", \"uavm…\n$ T_NAME_M3  <chr> \"မိုးမိတ်\", \"ပင်းတယ\", \"ရွာငံ\", \"ပင်လောင်း\", \"မဘိမ်း\", \"ကလော\", \"ဖယ်ခုံ\", \"…\n$ AREA       <dbl> 2703.611, 629.025, 2984.377, 3396.963, 5034.413, 1456.624, …\n$ geometry   <MULTIPOLYGON [°]> MULTIPOLYGON (((96.96001 23..., MULTIPOLYGON (…\n\n\n\n\nImporting aspatial data into R environment\n\nict <- read.csv(\"data3/aspatial/Shan-ICT.csv\")\n\nThe imported InfoComm variables are extracted from The 2014 Myanmar Population and Housing Census Myanmar. The attribute data set is called ict. It is saved in R's * tibble data.frame* format.\nLet’s view the summary of ict.\n\nsummary(ict)\n\n District.Pcode     District.Name      Township.Pcode     Township.Name     \n Length:55          Length:55          Length:55          Length:55         \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n Total.households     Radio         Television    Land.line.phone \n Min.   : 3318    Min.   :  115   Min.   :  728   Min.   :  20.0  \n 1st Qu.: 8711    1st Qu.: 1260   1st Qu.: 3744   1st Qu.: 266.5  \n Median :13685    Median : 2497   Median : 6117   Median : 695.0  \n Mean   :18369    Mean   : 4487   Mean   :10183   Mean   : 929.9  \n 3rd Qu.:23471    3rd Qu.: 6192   3rd Qu.:13906   3rd Qu.:1082.5  \n Max.   :82604    Max.   :30176   Max.   :62388   Max.   :6736.0  \n  Mobile.phone      Computer      Internet.at.home\n Min.   :  150   Min.   :  20.0   Min.   :   8.0  \n 1st Qu.: 2037   1st Qu.: 121.0   1st Qu.:  88.0  \n Median : 3559   Median : 244.0   Median : 316.0  \n Mean   : 6470   Mean   : 575.5   Mean   : 760.2  \n 3rd Qu.: 7177   3rd Qu.: 507.0   3rd Qu.: 630.5  \n Max.   :48461   Max.   :6705.0   Max.   :9746.0  \n\n\nNotice that there are 55 fields in this data set, matching the 55 areas in shan_sf.\n\n\nDeriving new variables using dplyr package\nThe unit of measurement of the values are number of household. Using these values directly will be bias by the underlying total number of households. In general, the townships with relatively higher total number of households will also have higher number of households owning radio, TV, etc.\nIn order to overcome this problem, we will derive the penetration rate of each ICT variable by using the code chunk below.\n\nict_derived <- ict %>%\n  mutate(`RADIO_PR` = `Radio`/`Total.households`*1000) %>%\n  mutate(`TV_PR` = `Television`/`Total.households`*1000) %>%\n  mutate(`LLPHONE_PR` = `Land.line.phone`/`Total.households`*1000) %>%\n  mutate(`MPHONE_PR` = `Mobile.phone`/`Total.households`*1000) %>%\n  mutate(`COMPUTER_PR` = `Computer`/`Total.households`*1000) %>%\n  mutate(`INTERNET_PR` = `Internet.at.home`/`Total.households`*1000) %>%\n  rename(`DT_PCODE` =`District.Pcode`,`DT`=`District.Name`,\n         `TS_PCODE`=`Township.Pcode`, `TS`=`Township.Name`,\n         `TT_HOUSEHOLDS`=`Total.households`,\n         `RADIO`=`Radio`, `TV`=`Television`, \n         `LLPHONE`=`Land.line.phone`, `MPHONE`=`Mobile.phone`,\n         `COMPUTER`=`Computer`, `INTERNET`=`Internet.at.home`) \n\nLet’s review the summary of ict_derived.\n\nsummary(ict_derived)\n\n   DT_PCODE              DT              TS_PCODE              TS           \n Length:55          Length:55          Length:55          Length:55         \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n TT_HOUSEHOLDS       RADIO             TV           LLPHONE      \n Min.   : 3318   Min.   :  115   Min.   :  728   Min.   :  20.0  \n 1st Qu.: 8711   1st Qu.: 1260   1st Qu.: 3744   1st Qu.: 266.5  \n Median :13685   Median : 2497   Median : 6117   Median : 695.0  \n Mean   :18369   Mean   : 4487   Mean   :10183   Mean   : 929.9  \n 3rd Qu.:23471   3rd Qu.: 6192   3rd Qu.:13906   3rd Qu.:1082.5  \n Max.   :82604   Max.   :30176   Max.   :62388   Max.   :6736.0  \n     MPHONE         COMPUTER         INTERNET         RADIO_PR     \n Min.   :  150   Min.   :  20.0   Min.   :   8.0   Min.   : 21.05  \n 1st Qu.: 2037   1st Qu.: 121.0   1st Qu.:  88.0   1st Qu.:138.95  \n Median : 3559   Median : 244.0   Median : 316.0   Median :210.95  \n Mean   : 6470   Mean   : 575.5   Mean   : 760.2   Mean   :215.68  \n 3rd Qu.: 7177   3rd Qu.: 507.0   3rd Qu.: 630.5   3rd Qu.:268.07  \n Max.   :48461   Max.   :6705.0   Max.   :9746.0   Max.   :484.52  \n     TV_PR         LLPHONE_PR       MPHONE_PR       COMPUTER_PR    \n Min.   :116.0   Min.   :  2.78   Min.   : 36.42   Min.   : 3.278  \n 1st Qu.:450.2   1st Qu.: 22.84   1st Qu.:190.14   1st Qu.:11.832  \n Median :517.2   Median : 37.59   Median :305.27   Median :18.970  \n Mean   :509.5   Mean   : 51.09   Mean   :314.05   Mean   :24.393  \n 3rd Qu.:606.4   3rd Qu.: 69.72   3rd Qu.:428.43   3rd Qu.:29.897  \n Max.   :842.5   Max.   :181.49   Max.   :735.43   Max.   :92.402  \n  INTERNET_PR     \n Min.   :  1.041  \n 1st Qu.:  8.617  \n Median : 22.829  \n Mean   : 30.644  \n 3rd Qu.: 41.281  \n Max.   :117.985"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex03.html#eda",
    "href": "Hands-on_Ex/Hands-on_Ex03.html#eda",
    "title": "Geographical Segmentation with Spatially Constrained Clustering Techniques",
    "section": "EDA",
    "text": "EDA\n\nEDA using statistical graphics\nWe will use histogram and boxplot to examine the distribution and outliers of the variables.\n\nradiohist <- ggplot(data=ict_derived, \n       aes(x=`RADIO`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\nradiobox <- ggplot(data=ict_derived, \n       aes(x=`RADIO`)) +\n  geom_boxplot(color=\"black\", \n               fill=\"light blue\")\nggarrange(radiohist, radiobox, nrow = 2, ncol = 1)\n\n\n\n\nNext, we will also plot the distribution of the radio percentage RADIO_PR.\n\nradio <- ggplot(data=ict_derived, \n       aes(x=`RADIO_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\nradioprbox <- ggplot(data=ict_derived, \n       aes(x=`RADIO_PR`)) +\n  geom_boxplot(color=\"black\", \n               fill=\"light blue\")\nggarrange(radio, radioprbox, nrow = 2, ncol = 1)\n\n\n\n\nThe distribution of RADIO is skewed to the right with 3 outliers, while the distribution of RADIO_PR is less right-skewed and has less outlier.\nNow, let’s look at the distribution of other newly derived variables.\n\ntv <- ggplot(data=ict_derived, \n       aes(x=`TV_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\nllphone <- ggplot(data=ict_derived, \n       aes(x=`LLPHONE_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\nmphone <- ggplot(data=ict_derived, \n       aes(x=`MPHONE_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\ncomputer <- ggplot(data=ict_derived, \n       aes(x=`COMPUTER_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\ninternet <- ggplot(data=ict_derived, \n       aes(x=`INTERNET_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\")\nggarrange(radio, tv, llphone, mphone, computer, internet,\n          nrow = 2, ncol = 3)\n\n\n\n\n\n\nEDA using choropleth map\n\nJoining geospatial data with aspatial data\nTo prepare the choropleth map, we need to combine both geospatial and aspatial data together. The function used for that task is left_join() of dplyr package. The shan_sf simple feature data.frame will be used as the base data object and the ict_derived data.frame will be used as the join table.\n\nshan_sf <- left_join(shan_sf, \n                     ict_derived, \n                     by=c(\"TS_PCODE\"=\"TS_PCODE\"))\n\n\n\nPreparing a choropleth map\nLet’s have a quick look at the distribution of radio penetration RADIO_PR of Shan State at township level.\n\nqtm(shan_sf, \"RADIO_PR\")\n\n\n\n\nIn order to reveal the distribution shown in the choropleth map above are bias to the underlying total number of households at the townships, we will create two choropleth maps, one for the total number of households (i.e. TT_HOUSEHOLDS.map) and one for the total number of household with Radio (RADIO.map) by using the code chunk below.\n\nTT_HOUSEHOLDS.map <- tm_shape(shan_sf) + \n  tm_fill(col = \"TT_HOUSEHOLDS\",\n          n = 5,\n          style = \"jenks\", \n          title = \"Total households\") + \n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.width = 0.3,\n            legend.height = 0.3,\n            legend.text.size = 0.5)\n\nRADIO.map <- tm_shape(shan_sf) + \n  tm_fill(col = \"RADIO\",\n          n = 5,\n          style = \"jenks\",\n          title = \"Number Radio \") + \n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.width = 0.3,\n            legend.height = 0.3,\n            legend.text.size = 0.5)\n\ntmap_arrange(TT_HOUSEHOLDS.map, RADIO.map,\n             asp=NA, ncol=2)\n\n\n\n\nWe can see that where the total number of households is high, the number of households with radio is high too.\nNow let us plot the choropleth maps showing the dsitribution of total number of households and Radio penetration rate by using the code chunk below.\n\ntm_shape(shan_sf) +\n    tm_polygons(c(\"TT_HOUSEHOLDS\", \"RADIO_PR\"),\n                style=\"jenks\") +\n    tm_facets(sync = TRUE, ncol = 2) +\n  tm_legend(legend.position = c(\"right\", \"bottom\"))+\n  tm_layout(outer.margins=0, asp=0)\n\n\n\n\nWith radio penetration RADIO_PR, the radio distribution is no longer correlate with total household distribution."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex03.html#correlation-analysis",
    "href": "Hands-on_Ex/Hands-on_Ex03.html#correlation-analysis",
    "title": "Geographical Segmentation with Spatially Constrained Clustering Techniques",
    "section": "Correlation Analysis",
    "text": "Correlation Analysis\nBefore we perform cluster analysis, it is important for us to ensure that the cluster variables are not highly correlated.\nIn this section, you will learn how to use corrplot.mixed() function of corrplot package to visualise and analyse the correlation of the input variables.\n\ncluster_vars.cor = cor(ict_derived[,12:17])\ncorrplot.mixed(cluster_vars.cor,\n         lower = \"ellipse\", \n               upper = \"number\",\n               tl.pos = \"lt\",\n               diag = \"l\",\n               tl.col = \"black\")\n\n\n\n\nThe correlation plot above shows that COMPUTER_PR and INTERNET_PR are highly correlated. This suggest that only one of them should be used in the cluster analysis instead of both."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex03.html#hierarchy-cluster-analysis",
    "href": "Hands-on_Ex/Hands-on_Ex03.html#hierarchy-cluster-analysis",
    "title": "Geographical Segmentation with Spatially Constrained Clustering Techniques",
    "section": "Hierarchy Cluster Analysis",
    "text": "Hierarchy Cluster Analysis\n\nExtrating clustering variables\n\ncluster_vars <- shan_sf %>%\n  st_set_geometry(NULL) %>%\n  select(\"TS.x\", \"RADIO_PR\", \"TV_PR\", \"LLPHONE_PR\", \"MPHONE_PR\", \"COMPUTER_PR\")\nhead(cluster_vars,10)\n\n        TS.x RADIO_PR    TV_PR LLPHONE_PR MPHONE_PR COMPUTER_PR\n1    Mongmit 286.1852 554.1313   35.30618  260.6944    12.15939\n2    Pindaya 417.4647 505.1300   19.83584  162.3917    12.88190\n3    Ywangan 484.5215 260.5734   11.93591  120.2856     4.41465\n4   Pinlaung 231.6499 541.7189   28.54454  249.4903    13.76255\n5     Mabein 449.4903 708.6423   72.75255  392.6089    16.45042\n6      Kalaw 280.7624 611.6204   42.06478  408.7951    29.63160\n7      Pekon 318.6118 535.8494   39.83270  214.8476    18.97032\n8   Lawksawk 387.1017 630.0035   31.51366  320.5686    21.76677\n9  Nawnghkio 349.3359 547.9456   38.44960  323.0201    15.76465\n10   Kyaukme 210.9548 601.1773   39.58267  372.4930    30.94709\n\n\nNotice that the final clustering variables list does not include variable INTERNET_PR because it is highly correlated with variable COMPUTER_PR.\nNext, we need to change the rows by township name instead of row number by using the code chunk below.\n\nrow.names(cluster_vars) <- cluster_vars$\"TS.x\"\nhead(cluster_vars,10)\n\n               TS.x RADIO_PR    TV_PR LLPHONE_PR MPHONE_PR COMPUTER_PR\nMongmit     Mongmit 286.1852 554.1313   35.30618  260.6944    12.15939\nPindaya     Pindaya 417.4647 505.1300   19.83584  162.3917    12.88190\nYwangan     Ywangan 484.5215 260.5734   11.93591  120.2856     4.41465\nPinlaung   Pinlaung 231.6499 541.7189   28.54454  249.4903    13.76255\nMabein       Mabein 449.4903 708.6423   72.75255  392.6089    16.45042\nKalaw         Kalaw 280.7624 611.6204   42.06478  408.7951    29.63160\nPekon         Pekon 318.6118 535.8494   39.83270  214.8476    18.97032\nLawksawk   Lawksawk 387.1017 630.0035   31.51366  320.5686    21.76677\nNawnghkio Nawnghkio 349.3359 547.9456   38.44960  323.0201    15.76465\nKyaukme     Kyaukme 210.9548 601.1773   39.58267  372.4930    30.94709\n\n\nNow we will delete the TS.x column by using select and assign the data table without TS.x to shan_ict.\n\nshan_ict <- select(cluster_vars, c(2:6))\nhead(shan_ict, 10)\n\n          RADIO_PR    TV_PR LLPHONE_PR MPHONE_PR COMPUTER_PR\nMongmit   286.1852 554.1313   35.30618  260.6944    12.15939\nPindaya   417.4647 505.1300   19.83584  162.3917    12.88190\nYwangan   484.5215 260.5734   11.93591  120.2856     4.41465\nPinlaung  231.6499 541.7189   28.54454  249.4903    13.76255\nMabein    449.4903 708.6423   72.75255  392.6089    16.45042\nKalaw     280.7624 611.6204   42.06478  408.7951    29.63160\nPekon     318.6118 535.8494   39.83270  214.8476    18.97032\nLawksawk  387.1017 630.0035   31.51366  320.5686    21.76677\nNawnghkio 349.3359 547.9456   38.44960  323.0201    15.76465\nKyaukme   210.9548 601.1773   39.58267  372.4930    30.94709\n\n\n\n\nData Standardization\nIn general, multiple variables will be used in cluster analysis. It is not unusual their values range are different. In order to avoid the cluster analysis result is biased to clustering variables with large values, it is useful to standardise the input variables before performing cluster analysis.\n\nMin-Max standardization\nnormalize() of heatmaply package is used to stadardisation the clustering variables by using Min-Max method. Notice that the values range of the Min-max standardised clustering variables are 0-1 now.\n\nshan_ict.std <- normalize(shan_ict)\nsummary(shan_ict.std)\n\n    RADIO_PR          TV_PR          LLPHONE_PR       MPHONE_PR     \n Min.   :0.0000   Min.   :0.0000   Min.   :0.0000   Min.   :0.0000  \n 1st Qu.:0.2544   1st Qu.:0.4600   1st Qu.:0.1123   1st Qu.:0.2199  \n Median :0.4097   Median :0.5523   Median :0.1948   Median :0.3846  \n Mean   :0.4199   Mean   :0.5416   Mean   :0.2703   Mean   :0.3972  \n 3rd Qu.:0.5330   3rd Qu.:0.6750   3rd Qu.:0.3746   3rd Qu.:0.5608  \n Max.   :1.0000   Max.   :1.0000   Max.   :1.0000   Max.   :1.0000  \n  COMPUTER_PR     \n Min.   :0.00000  \n 1st Qu.:0.09598  \n Median :0.17607  \n Mean   :0.23692  \n 3rd Qu.:0.29868  \n Max.   :1.00000  \n\n\n\n\nZ-score standardization\nZ-score standardization can be performed easily by using scale() of Base R. Notice the mean and standard deviation of the Z-score standardized clustering variables are 0 and 1 respectively. describe() of psych package is used here instead of summary() of Base R because the earlier provides standard deviation.\n\nshan_ict.z <- scale(shan_ict)\ndescribe(shan_ict.z)\n\n            vars  n mean sd median trimmed  mad   min  max range  skew kurtosis\nRADIO_PR       1 55    0  1  -0.04   -0.06 0.94 -1.85 2.55  4.40  0.48    -0.27\nTV_PR          2 55    0  1   0.05    0.04 0.78 -2.47 2.09  4.56 -0.38    -0.23\nLLPHONE_PR     3 55    0  1  -0.33   -0.15 0.68 -1.19 3.20  4.39  1.37     1.49\nMPHONE_PR      4 55    0  1  -0.05   -0.06 1.01 -1.58 2.40  3.98  0.48    -0.34\nCOMPUTER_PR    5 55    0  1  -0.26   -0.18 0.64 -1.03 3.31  4.34  1.80     2.96\n              se\nRADIO_PR    0.13\nTV_PR       0.13\nLLPHONE_PR  0.13\nMPHONE_PR   0.13\nCOMPUTER_PR 0.13\n\n\nWarning: Z-score standardisation method should only be used if we would assume all variables come from some normal distribution.\nIn this case, the histograms of LLPHONE_PR, MPHONE_PR and COMPUTER_PR are right-skewed, so it is unlikely that the distribution of those variables is normal. For further analysis, we can also conduct distribution fit test to find out.\n\n\nVisualising the standardized clustering variables\nBeside reviewing the summary statistics of the standardized clustering variables, it is also a good practice to visualize their distribution graphical.\n\nr <- ggplot(data=ict_derived, \n             aes(x= `RADIO_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  ggtitle(\"Raw Value\")\n\nshan_ict_s_df <- as.data.frame(shan_ict.std)\ns <- ggplot(data=shan_ict_s_df, \n       aes(x=`RADIO_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  ggtitle(\"Min-Max\")\n\nshan_ict_z_df <- as.data.frame(shan_ict.z)\nz <- ggplot(data=shan_ict_z_df, \n       aes(x=`RADIO_PR`)) +\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  ggtitle(\"Z-score\")\n\nggarrange(r, s, z,\n          ncol = 3,\n          nrow = 1)\n\n\n\n\nNotice that the overall distribution of the clustering variables will change after the data standardization. Hence, it is advisible NOT to perform data standardization if the values range of the clustering variables are not very large.\n\n\n\nComputing proximity matrix\nIn R, many packages provide functions to calculate distance matrix. We will compute the proximity matrix by using dist() of R.\ndist() supports six distance proximity calculations, they are: euclidean, maximum, manhattan, canberra, binary and minkowski. The default is euclidean proximity matrix.\n\nproxmat <- dist(shan_ict, method = 'euclidean')\nproxmat\n\n             Mongmit   Pindaya   Ywangan  Pinlaung    Mabein     Kalaw\nPindaya    171.86828                                                  \nYwangan    381.88259 257.31610                                        \nPinlaung    57.46286 208.63519 400.05492                              \nMabein     263.37099 313.45776 529.14689 312.66966                    \nKalaw      160.05997 302.51785 499.53297 181.96406 198.14085          \nPekon       59.61977 117.91580 336.50410  94.61225 282.26877 211.91531\nLawksawk   140.11550 204.32952 432.16535 192.57320 130.36525 140.01101\nNawnghkio   89.07103 180.64047 377.87702 139.27495 204.63154 127.74787\nKyaukme    144.02475 311.01487 505.89191 139.67966 264.88283  79.42225\nMuse       563.01629 704.11252 899.44137 571.58335 453.27410 412.46033\nLaihka     141.87227 298.61288 491.83321 101.10150 345.00222 197.34633\nMongnai    115.86190 258.49346 422.71934  64.52387 358.86053 200.34668\nMawkmai    434.92968 437.99577 397.03752 398.11227 693.24602 562.59200\nKutkai      97.61092 212.81775 360.11861  78.07733 340.55064 204.93018\nMongton    192.67961 283.35574 361.23257 163.42143 425.16902 267.87522\nMongyai    256.72744 287.41816 333.12853 220.56339 516.40426 386.74701\nMongkaing  503.61965 481.71125 364.98429 476.29056 747.17454 625.24500\nLashio     251.29457 398.98167 602.17475 262.51735 231.28227 106.69059\nMongpan    193.32063 335.72896 483.68125 192.78316 301.52942 114.69105\nMatman     401.25041 354.39039 255.22031 382.40610 637.53975 537.63884\nTachileik  529.63213 635.51774 807.44220 555.01039 365.32538 373.64459\nNarphan    406.15714 474.50209 452.95769 371.26895 630.34312 463.53759\nMongkhet   349.45980 391.74783 408.97731 305.86058 610.30557 465.52013\nHsipaw     118.18050 245.98884 388.63147  76.55260 366.42787 212.36711\nMonghsat   214.20854 314.71506 432.98028 160.44703 470.48135 317.96188\nMongmao    242.54541 402.21719 542.85957 217.58854 384.91867 195.18913\nNansang    104.91839 275.44246 472.77637  85.49572 287.92364 124.30500\nLaukkaing  568.27732 726.85355 908.82520 563.81750 520.67373 427.77791\nPangsang   272.67383 428.24958 556.82263 244.47146 418.54016 224.03998\nNamtu      179.62251 225.40822 444.66868 170.04533 366.16094 307.27427\nMonghpyak  177.76325 221.30579 367.44835 222.20020 212.69450 167.08436\nKonkyan    403.39082 500.86933 528.12533 365.44693 613.51206 444.75859\nMongping   265.12574 310.64850 337.94020 229.75261 518.16310 375.64739\nHopong     136.93111 223.06050 352.85844  98.14855 398.00917 264.16294\nNyaungshwe  99.38590 216.52463 407.11649 138.12050 210.21337  95.66782\nHsihseng   131.49728 172.00796 342.91035 111.61846 381.20187 287.11074\nMongla     384.30076 549.42389 728.16301 372.59678 406.09124 260.26411\nHseni      189.37188 337.98982 534.44679 204.47572 213.61240  38.52842\nKunlong    224.12169 355.47066 531.63089 194.76257 396.61508 273.01375\nHopang     281.05362 443.26362 596.19312 265.96924 368.55167 185.14704\nNamhkan    386.02794 543.81859 714.43173 382.78835 379.56035 246.39577\nKengtung   246.45691 385.68322 573.23173 263.48638 219.47071  88.29335\nLangkho    164.26299 323.28133 507.78892 168.44228 253.84371  67.19580\nMonghsu    109.15790 198.35391 340.42789  80.86834 367.19820 237.34578\nTaunggyi   399.84278 503.75471 697.98323 429.54386 226.24011 252.26066\nPangwaun   381.51246 512.13162 580.13146 356.37963 523.44632 338.35194\nKyethi     202.92551 175.54012 287.29358 189.47065 442.07679 360.17247\nLoilen     145.48666 293.61143 469.51621  91.56527 375.06406 217.19877\nManton     430.64070 402.42888 306.16379 405.83081 674.01120 560.16577\nMongyang   309.51302 475.93982 630.71590 286.03834 411.88352 233.56349\nKunhing    173.50424 318.23811 449.67218 141.58836 375.82140 197.63683\nMongyawng  214.21738 332.92193 570.56521 235.55497 193.49994 173.43078\nTangyan    195.92520 208.43740 324.77002 169.50567 448.59948 348.06617\nNamhsan    237.78494 228.41073 286.16305 214.33352 488.33873 385.88676\n               Pekon  Lawksawk Nawnghkio   Kyaukme      Muse    Laihka\nPindaya                                                               \nYwangan                                                               \nPinlaung                                                              \nMabein                                                                \nKalaw                                                                 \nPekon                                                                 \nLawksawk   157.51129                                                  \nNawnghkio  113.15370  90.82891                                        \nKyaukme    202.12206 186.29066 157.04230                              \nMuse       614.56144 510.13288 533.68806 434.75768                    \nLaihka     182.23667 246.74469 211.88187 128.24979 526.65211          \nMongnai    151.60031 241.71260 182.21245 142.45669 571.97975 100.53457\nMawkmai    416.00669 567.52693 495.15047 512.02846 926.93007 429.96554\nKutkai     114.98048 224.64646 147.44053 170.93318 592.90743 144.67198\nMongton    208.14888 311.07742 225.81118 229.28509 634.71074 212.07320\nMongyai    242.52301 391.26989 319.57938 339.27780 763.91399 264.13364\nMongkaing  480.23965 625.18712 546.69447 586.05094 995.66496 522.96309\nLashio     303.80011 220.75270 230.55346 129.95255 313.15288 238.64533\nMongpan    243.30037 228.54223 172.84425 110.37831 447.49969 210.76951\nMatman     368.25761 515.39711 444.05061 505.52285 929.11283 443.25453\nTachileik  573.39528 441.82621 470.45533 429.15493 221.19950 549.08985\nNarphan    416.84901 523.69580 435.59661 420.30003 770.40234 392.32592\nMongkhet   342.08722 487.41102 414.10280 409.03553 816.44931 324.97428\nHsipaw     145.37542 249.35081 176.09570 163.95741 591.03355 128.42987\nMonghsat   225.64279 352.31496 289.83220 253.25370 663.76026 158.93517\nMongmao    293.70625 314.64777 257.76465 146.09228 451.82530 185.99082\nNansang    160.37607 188.78869 151.13185  60.32773 489.35308  78.78999\nLaukkaing  624.82399 548.83928 552.65554 428.74978 149.26996 507.39700\nPangsang   321.81214 345.91486 287.10769 175.35273 460.24292 214.19291\nNamtu      165.02707 260.95300 257.52713 270.87277 659.16927 185.86794\nMonghpyak  190.93173 142.31691  93.03711 217.64419 539.43485 293.22640\nKonkyan    421.48797 520.31264 439.34272 393.79911 704.86973 351.75354\nMongping   259.68288 396.47081 316.14719 330.28984 744.44948 272.82761\nHopong     138.86577 274.91604 204.88286 218.84211 648.68011 157.48857\nNyaungshwe 139.31874 104.17830  43.26545 126.50414 505.88581 201.71653\nHsihseng   105.30573 257.11202 209.88026 250.27059 677.66886 175.89761\nMongla     441.20998 393.18472 381.40808 241.58966 256.80556 315.93218\nHseni      243.98001 171.50398 164.05304  81.20593 381.30567 204.49010\nKunlong    249.36301 318.30406 285.04608 215.63037 547.24297 122.68682\nHopang     336.38582 321.16462 279.84188 154.91633 377.44407 230.78652\nNamhkan    442.77120 379.41126 367.33575 247.81990 238.67060 342.43665\nKengtung   297.67761 209.38215 208.29647 136.23356 330.08211 258.23950\nLangkho    219.21623 190.30257 156.51662  51.67279 413.64173 160.94435\nMonghsu    113.84636 242.04063 170.09168 200.77712 633.21624 163.28926\nTaunggyi   440.66133 304.96838 344.79200 312.60547 250.81471 425.36916\nPangwaun   423.81347 453.02765 381.67478 308.31407 541.97887 351.78203\nKyethi     162.43575 317.74604 267.21607 328.14177 757.16745 255.83275\nLoilen     181.94596 265.29318 219.26405 146.92675 560.43400  59.69478\nManton     403.82131 551.13000 475.77296 522.86003 941.49778 458.30232\nMongyang   363.58788 363.37684 323.32123 188.59489 389.59919 229.71502\nKunhing    213.46379 278.68953 206.15773 145.00266 533.00162 142.03682\nMongyawng  248.43910 179.07229 220.61209 181.55295 422.37358 211.99976\nTangyan    167.79937 323.14701 269.07880 306.78359 736.93741 224.29176\nNamhsan    207.16559 362.84062 299.74967 347.85944 778.52971 273.79672\n             Mongnai   Mawkmai    Kutkai   Mongton   Mongyai Mongkaing\nPindaya                                                               \nYwangan                                                               \nPinlaung                                                              \nMabein                                                                \nKalaw                                                                 \nPekon                                                                 \nLawksawk                                                              \nNawnghkio                                                             \nKyaukme                                                               \nMuse                                                                  \nLaihka                                                                \nMongnai                                                               \nMawkmai    374.50873                                                  \nKutkai      91.15307 364.95519                                        \nMongton    131.67061 313.35220 107.06341                              \nMongyai    203.23607 178.70499 188.94166 159.79790                    \nMongkaing  456.00842 133.29995 428.96133 365.50032 262.84016          \nLashio     270.86983 638.60773 289.82513 347.11584 466.36472 708.65819\nMongpan    178.09554 509.99632 185.18173 200.31803 346.39710 563.56780\nMatman     376.33870 147.83545 340.86349 303.04574 186.95158 135.51424\nTachileik  563.95232 919.38755 568.99109 608.76740 750.29555 967.14087\nNarphan    329.31700 273.75350 314.27683 215.97925 248.82845 285.65085\nMongkhet   275.76855 115.58388 273.91673 223.22828 104.98924 222.60577\nHsipaw      52.68195 351.34601  51.46282  90.69766 177.33790 423.77868\nMonghsat   125.25968 275.09705 154.32012 150.98053 127.35225 375.60376\nMongmao    188.29603 485.52853 204.69232 206.57001 335.61300 552.31959\nNansang     92.79567 462.41938 130.04549 199.58124 288.55962 542.16609\nLaukkaing  551.56800 882.51110 580.38112 604.66190 732.68347 954.11795\nPangsang   204.25746 484.14757 228.33583 210.77938 343.30638 548.40662\nNamtu      209.35473 427.95451 225.28268 308.71751 278.02761 525.04057\nMonghpyak  253.26470 536.71695 206.61627 258.04282 370.01575 568.21089\nKonkyan    328.82831 339.01411 310.60810 248.25265 287.87384 380.92091\nMongping   202.99615 194.31049 182.75266 119.86993  65.38727 257.18572\nHopong      91.53795 302.84362  73.45899 106.21031 124.62791 379.37916\nNyaungshwe 169.63695 502.99026 152.15482 219.72196 327.13541 557.32112\nHsihseng   142.36728 329.29477 128.21054 194.64317 162.27126 411.59788\nMongla     354.10985 686.88950 388.40984 411.06668 535.28615 761.48327\nHseni      216.81639 582.53670 229.37894 286.75945 408.23212 648.04408\nKunlong    202.92529 446.53763 204.54010 270.02165 299.36066 539.91284\nHopang     243.00945 561.24281 263.31986 273.50305 408.73288 626.17673\nNamhkan    370.05669 706.47792 392.48568 414.53594 550.62819 771.39688\nKengtung   272.28711 632.54638 279.19573 329.38387 460.39706 692.74693\nLangkho    174.67678 531.08019 180.51419 236.70878 358.95672 597.42714\nMonghsu     84.11238 332.07962  62.60859 107.04894 154.86049 400.71816\nTaunggyi   448.55282 810.74692 450.33382 508.40925 635.94105 866.21117\nPangwaun   312.13429 500.68857 321.80465 257.50434 394.07696 536.95736\nKyethi     210.50453 278.85535 184.23422 222.52947 137.79420 352.06533\nLoilen      58.41263 388.73386 131.56529 176.16001 224.79239 482.18190\nManton     391.54062 109.08779 361.82684 310.20581 195.59882  81.75337\nMongyang   260.39387 558.83162 285.33223 295.60023 414.31237 631.91325\nKunhing    110.55197 398.43973 108.84990 114.03609 238.99570 465.03971\nMongyawng  275.77546 620.04321 281.03383 375.22688 445.78964 700.98284\nTangyan    180.37471 262.66006 166.61820 198.88460 109.08506 348.56123\nNamhsan    218.10003 215.19289 191.32762 196.76188  77.35900 288.66231\n              Lashio   Mongpan    Matman Tachileik   Narphan  Mongkhet\nPindaya                                                               \nYwangan                                                               \nPinlaung                                                              \nMabein                                                                \nKalaw                                                                 \nPekon                                                                 \nLawksawk                                                              \nNawnghkio                                                             \nKyaukme                                                               \nMuse                                                                  \nLaihka                                                                \nMongnai                                                               \nMawkmai                                                               \nKutkai                                                                \nMongton                                                               \nMongyai                                                               \nMongkaing                                                             \nLashio                                                                \nMongpan    172.33279                                                  \nMatman     628.11049 494.81014                                        \nTachileik  311.95286 411.03849 890.12935                              \nNarphan    525.63854 371.13393 312.05193 760.29566                    \nMongkhet   534.44463 412.17123 203.02855 820.50164 217.28718          \nHsipaw     290.86435 179.52054 344.45451 576.18780 295.40170 253.80950\nMonghsat   377.86793 283.30992 313.59911 677.09508 278.21548 167.98445\nMongmao    214.23677 131.59966 501.59903 472.95568 331.42618 375.35820\nNansang    184.47950 144.77393 458.06573 486.77266 398.13308 360.99219\nLaukkaing  334.65738 435.58047 903.72094 325.06329 708.82887 769.06406\nPangsang   236.72516 140.23910 506.29940 481.31907 316.30314 375.58139\nNamtu      365.88437 352.91394 416.65397 659.56458 494.36143 355.99713\nMonghpyak  262.09281 187.85699 470.46845 444.04411 448.40651 462.63265\nKonkyan    485.51312 365.87588 392.40306 730.92980 158.82353 254.24424\nMongping   454.52548 318.47482 201.65224 727.08969 188.64567 113.80917\nHopong     345.31042 239.43845 291.84351 632.45718 294.40441 212.99485\nNyaungshwe 201.58191 137.29734 460.91883 445.81335 427.94086 417.08639\nHsihseng   369.00833 295.87811 304.02806 658.87060 377.52977 256.70338\nMongla     179.95877 253.20001 708.17595 347.33155 531.46949 574.40292\nHseni       79.41836 120.66550 564.64051 354.90063 474.12297 481.88406\nKunlong    295.23103 288.03320 468.27436 595.70536 413.07823 341.68641\nHopang     170.63913 135.62913 573.55355 403.82035 397.85908 451.51070\nNamhkan    173.27153 240.34131 715.42102 295.91660 536.85519 596.19944\nKengtung    59.85893 142.21554 613.01033 295.90429 505.40025 531.35998\nLangkho    115.18145  94.98486 518.86151 402.33622 420.65204 428.08061\nMonghsu    325.71557 216.25326 308.13805 605.02113 311.92379 247.73318\nTaunggyi   195.14541 319.81385 778.45810 150.84117 684.20905 712.80752\nPangwaun   362.45608 232.52209 523.43600 540.60474 264.64997 407.02947\nKyethi     447.10266 358.89620 233.83079 728.87329 374.90376 233.25039\nLoilen     268.92310 207.25000 406.56282 573.75476 354.79137 284.76895\nManton     646.66493 507.96808  59.52318 910.23039 280.26395 181.33894\nMongyang   209.33700 194.93467 585.61776 448.79027 401.39475 445.40621\nKunhing    255.10832 137.85278 403.66587 532.26397 281.62645 292.49814\nMongyawng  172.70139 275.15989 601.80824 432.10118 572.76394 522.91815\nTangyan    429.84475 340.39128 242.78233 719.84066 348.84991 201.49393\nNamhsan    472.04024 364.77086 180.09747 754.03913 316.54695 170.90848\n              Hsipaw  Monghsat   Mongmao   Nansang Laukkaing  Pangsang\nPindaya                                                               \nYwangan                                                               \nPinlaung                                                              \nMabein                                                                \nKalaw                                                                 \nPekon                                                                 \nLawksawk                                                              \nNawnghkio                                                             \nKyaukme                                                               \nMuse                                                                  \nLaihka                                                                \nMongnai                                                               \nMawkmai                                                               \nKutkai                                                                \nMongton                                                               \nMongyai                                                               \nMongkaing                                                             \nLashio                                                                \nMongpan                                                               \nMatman                                                                \nTachileik                                                             \nNarphan                                                               \nMongkhet                                                              \nHsipaw                                                                \nMonghsat   121.78922                                                  \nMongmao    185.99483 247.17708                                        \nNansang    120.24428 201.92690 164.99494                              \nLaukkaing  569.06099 626.44910 404.00848 480.60074                    \nPangsang   205.04337 256.37933  57.60801 193.36162 408.04016          \nNamtu      229.44658 231.78673 365.03882 217.61884 664.06286 392.97391\nMonghpyak  237.67919 356.84917 291.88846 227.52638 565.84279 315.11651\nKonkyan    296.74316 268.25060 281.87425 374.70456 635.92043 274.81900\nMongping   168.92101 140.95392 305.57166 287.36626 708.13447 308.33123\nHopong      62.86179 100.45714 244.16253 167.66291 628.48557 261.51075\nNyaungshwe 169.92664 286.37238 230.45003 131.18943 520.24345 257.77823\nHsihseng   136.54610 153.49551 311.98001 193.53779 670.74564 335.52974\nMongla     373.47509 429.00536 216.24705 289.45119 202.55831 217.88123\nHseni      231.48538 331.22632 184.67099 136.45492 391.74585 214.66375\nKunlong    205.10051 202.31862 224.43391 183.01388 521.88657 258.49342\nHopang     248.72536 317.64824  78.29342 196.47091 331.67199  92.57672\nNamhkan    382.79302 455.10875 223.32205 302.89487 196.46063 231.38484\nKengtung   284.08582 383.72138 207.58055 193.67980 351.48520 229.85484\nLangkho    183.05109 279.52329 134.50170  99.39859 410.41270 167.65920\nMonghsu     58.55724 137.24737 242.43599 153.59962 619.01766 260.52971\nTaunggyi   462.31183 562.88102 387.33906 365.04897 345.98041 405.59730\nPangwaun   298.12447 343.53898 187.40057 326.12960 470.63605 157.48757\nKyethi     195.17677 190.50609 377.89657 273.02385 749.99415 396.89963\nLoilen      98.04789 118.65144 190.26490  94.23028 535.57527 207.94433\nManton     359.60008 317.15603 503.79786 476.55544 907.38406 504.75214\nMongyang   267.10497 312.64797  91.06281 218.49285 326.19219 108.37735\nKunhing     90.77517 165.38834 103.91040 128.20940 500.41640 123.18870\nMongyawng  294.70967 364.40429 296.40789 191.11990 454.80044 336.16703\nTangyan    167.69794 144.59626 347.14183 249.70235 722.40954 364.76893\nNamhsan    194.47928 169.56962 371.71448 294.16284 760.45960 385.65526\n               Namtu Monghpyak   Konkyan  Mongping    Hopong Nyaungshwe\nPindaya                                                                \nYwangan                                                                \nPinlaung                                                               \nMabein                                                                 \nKalaw                                                                  \nPekon                                                                  \nLawksawk                                                               \nNawnghkio                                                              \nKyaukme                                                                \nMuse                                                                   \nLaihka                                                                 \nMongnai                                                                \nMawkmai                                                                \nKutkai                                                                 \nMongton                                                                \nMongyai                                                                \nMongkaing                                                              \nLashio                                                                 \nMongpan                                                                \nMatman                                                                 \nTachileik                                                              \nNarphan                                                                \nMongkhet                                                               \nHsipaw                                                                 \nMonghsat                                                               \nMongmao                                                                \nNansang                                                                \nLaukkaing                                                              \nPangsang                                                               \nNamtu                                                                  \nMonghpyak  346.57799                                                   \nKonkyan    478.37690 463.39594                                         \nMongping   321.66441 354.76537 242.02901                               \nHopong     206.82668 267.95563 304.49287 134.00139                     \nNyaungshwe 271.41464 103.97300 432.35040 319.32583 209.32532           \nHsihseng   131.89940 285.37627 383.49700 199.64389  91.65458  225.80242\nMongla     483.49434 408.03397 468.09747 512.61580 432.31105  347.60273\nHseni      327.41448 200.26876 448.84563 395.58453 286.41193  130.86310\nKunlong    233.60474 357.44661 329.11433 309.05385 219.06817  285.13095\nHopang     408.24516 304.26577 348.18522 379.27212 309.77356  247.19891\nNamhkan    506.32466 379.50202 481.59596 523.74815 444.13246  333.32428\nKengtung   385.33554 221.47613 474.82621 442.80821 340.47382  177.75714\nLangkho    305.03473 200.27496 386.95022 343.96455 239.63685  128.26577\nMonghsu    209.64684 232.17823 331.72187 158.90478  43.40665  173.82799\nTaunggyi   518.72748 334.17439 650.56905 621.53039 513.76415  325.09619\nPangwaun   517.03554 381.95144 263.97576 340.37881 346.00673  352.92324\nKyethi     186.90932 328.16234 400.10989 187.43974 136.49038  288.06872\nLoilen     194.24075 296.99681 334.19820 231.99959 124.74445  206.40432\nManton     448.58230 502.20840 366.66876 200.48082 310.58885  488.79874\nMongyang   413.26052 358.17599 329.39338 387.80686 323.35704  294.29500\nKunhing    296.43996 250.74435 253.74202 212.59619 145.15617  189.97131\nMongyawng  262.24331 285.56475 522.38580 455.59190 326.59925  218.12104\nTangyan    178.69483 335.26416 367.46064 161.67411 106.82328  284.14692\nNamhsan    240.95555 352.70492 352.20115 130.23777 132.70541  315.91750\n            Hsihseng    Mongla     Hseni   Kunlong    Hopang   Namhkan\nPindaya                                                               \nYwangan                                                               \nPinlaung                                                              \nMabein                                                                \nKalaw                                                                 \nPekon                                                                 \nLawksawk                                                              \nNawnghkio                                                             \nKyaukme                                                               \nMuse                                                                  \nLaihka                                                                \nMongnai                                                               \nMawkmai                                                               \nKutkai                                                                \nMongton                                                               \nMongyai                                                               \nMongkaing                                                             \nLashio                                                                \nMongpan                                                               \nMatman                                                                \nTachileik                                                             \nNarphan                                                               \nMongkhet                                                              \nHsipaw                                                                \nMonghsat                                                              \nMongmao                                                               \nNansang                                                               \nLaukkaing                                                             \nPangsang                                                              \nNamtu                                                                 \nMonghpyak                                                             \nKonkyan                                                               \nMongping                                                              \nHopong                                                                \nNyaungshwe                                                            \nHsihseng                                                              \nMongla     478.66210                                                  \nHseni      312.74375 226.82048                                        \nKunlong    231.85967 346.46200 276.19175                              \nHopang     370.01334 147.02444 162.80878 271.34451                    \nNamhkan    492.09476  77.21355 212.11323 375.73885 146.18632          \nKengtung   370.72441 202.45004  66.12817 317.14187 164.29921 175.63015\nLangkho    276.27441 229.01675  66.66133 224.52741 134.24847 224.40029\nMonghsu     97.82470 424.51868 262.28462 239.89665 301.84458 431.32637\nTaunggyi   528.14240 297.09863 238.19389 471.29032 329.95252 257.29147\nPangwaun   433.06326 319.18643 330.70182 392.45403 206.98364 310.44067\nKyethi      84.04049 556.02500 388.33498 298.55859 440.48114 567.86202\nLoilen     158.84853 338.67408 227.10984 166.53599 242.89326 364.90647\nManton     334.87758 712.51416 584.63341 479.76855 577.52046 721.86149\nMongyang   382.59743 146.66661 210.19929 247.22785  69.25859 167.72448\nKunhing    220.15490 306.47566 206.47448 193.77551 172.96164 314.92119\nMongyawng  309.51462 315.57550 173.86004 240.39800 290.51360 321.21112\nTangyan     70.27241 526.80849 373.07575 268.07983 412.22167 542.64078\nNamhsan    125.74240 564.02740 411.96125 310.40560 440.51555 576.42717\n            Kengtung   Langkho   Monghsu  Taunggyi  Pangwaun    Kyethi\nPindaya                                                               \nYwangan                                                               \nPinlaung                                                              \nMabein                                                                \nKalaw                                                                 \nPekon                                                                 \nLawksawk                                                              \nNawnghkio                                                             \nKyaukme                                                               \nMuse                                                                  \nLaihka                                                                \nMongnai                                                               \nMawkmai                                                               \nKutkai                                                                \nMongton                                                               \nMongyai                                                               \nMongkaing                                                             \nLashio                                                                \nMongpan                                                               \nMatman                                                                \nTachileik                                                             \nNarphan                                                               \nMongkhet                                                              \nHsipaw                                                                \nMonghsat                                                              \nMongmao                                                               \nNansang                                                               \nLaukkaing                                                             \nPangsang                                                              \nNamtu                                                                 \nMonghpyak                                                             \nKonkyan                                                               \nMongping                                                              \nHopong                                                                \nNyaungshwe                                                            \nHsihseng                                                              \nMongla                                                                \nHseni                                                                 \nKunlong                                                               \nHopang                                                                \nNamhkan                                                               \nKengtung                                                              \nLangkho    107.16213                                                  \nMonghsu    316.91914 221.84918                                        \nTaunggyi   186.28225 288.27478 486.91951                              \nPangwaun   337.48335 295.38434 343.38498 497.61245                    \nKyethi     444.26274 350.91512 146.61572 599.57407 476.62610          \nLoilen     282.22935 184.10672 131.55208 455.91617 331.69981 232.32965\nManton     631.99123 535.95620 330.76503 803.08034 510.79265 272.03299\nMongyang   217.08047 175.35413 323.95988 374.58247 225.25026 453.86726\nKunhing    245.95083 146.38284 146.78891 429.98509 229.09986 278.95182\nMongyawng  203.87199 186.11584 312.85089 287.73864 475.33116 387.71518\nTangyan    429.95076 332.02048 127.42203 592.65262 447.05580  47.79331\nNamhsan    466.20497 368.20978 153.22576 631.49232 448.58030  68.67929\n              Loilen    Manton  Mongyang   Kunhing Mongyawng   Tangyan\nPindaya                                                               \nYwangan                                                               \nPinlaung                                                              \nMabein                                                                \nKalaw                                                                 \nPekon                                                                 \nLawksawk                                                              \nNawnghkio                                                             \nKyaukme                                                               \nMuse                                                                  \nLaihka                                                                \nMongnai                                                               \nMawkmai                                                               \nKutkai                                                                \nMongton                                                               \nMongyai                                                               \nMongkaing                                                             \nLashio                                                                \nMongpan                                                               \nMatman                                                                \nTachileik                                                             \nNarphan                                                               \nMongkhet                                                              \nHsipaw                                                                \nMonghsat                                                              \nMongmao                                                               \nNansang                                                               \nLaukkaing                                                             \nPangsang                                                              \nNamtu                                                                 \nMonghpyak                                                             \nKonkyan                                                               \nMongping                                                              \nHopong                                                                \nNyaungshwe                                                            \nHsihseng                                                              \nMongla                                                                \nHseni                                                                 \nKunlong                                                               \nHopang                                                                \nNamhkan                                                               \nKengtung                                                              \nLangkho                                                               \nMonghsu                                                               \nTaunggyi                                                              \nPangwaun                                                              \nKyethi                                                                \nLoilen                                                                \nManton     419.06087                                                  \nMongyang   246.76592 585.70558                                        \nKunhing    130.39336 410.49230 188.89405                              \nMongyawng  261.75211 629.43339 304.21734 295.35984                    \nTangyan    196.60826 271.82672 421.06366 249.74161 377.52279          \nNamhsan    242.15271 210.48485 450.97869 270.79121 430.02019  63.67613\n\n\n\n\nComputing hierarchical clustering\nIn R, there are several packages provide hierarchical clustering function. In this hands-on exercise, hclust() of R stats will be used.\nhclust() employed agglomeration method to compute the cluster. Eight clustering algorithms are supported, they are: ward.D, ward.D2, single, complete, average(UPGMA), mcquitty(WPGMA), median(WPGMC) and centroid(UPGMC).\n\nhclust_ward <- hclust(proxmat, method = 'ward.D')\n\nUsing plot() of Base R, we can plot the cluster dendogram.\n\nplot(hclust_ward, cex = 0.6)\n\n\n\n\n\n\nSelecting the optimal clustering algorithm\nOne of the challenge in performing hierarchical clustering is to identify stronger clustering structures. The issue can be solved by using use agnes() function of cluster package. It functions like hclus(), however, with the agnes() function you can also get the agglomerative coefficient, which measures the amount of clustering structure found (values closer to 1 suggest strong clustering structure).\n\nm <- c( \"average\", \"single\", \"complete\", \"ward\")\nnames(m) <- c( \"average\", \"single\", \"complete\", \"ward\")\n\nac <- function(x) {\n  agnes(shan_ict, method = x)$ac\n}\n\nmap_dbl(m, ac)\n\n  average    single  complete      ward \n0.8131144 0.6628705 0.8950702 0.9427730 \n\n\nWard's method provides the strongest clustering structure among the four methods assessed. Hence, in the subsequent analysis, only Ward's method will be used.\n\n\nDetermining Optimal Clusters\nAnother technical challenge face by data analyst in performing clustering analysis is to determine the optimal clusters to retain.\nThere are three commonly used methods to determine the optimal clusters, they are:\n\nElbow Method\nAverage Silhouette Method\nGap Statistic Method\n\n\nGap Statistic Method\nThe gap statistic compares the total within intra-cluster variation for different values of k with their expected values under null reference distribution of the data. The estimate of the optimal clusters will be value that maximize the gap statistic (i.e., that yields the largest gap statistic). This means that the clustering structure is far away from the random uniform distribution of points.\nTo compute the gap statistic, clusGap() of cluster package will be used. Also note that the hcut function used is from factoextra package.\n\nset.seed(12345)\ngap_stat <- clusGap(shan_ict, \n                    FUN = hcut, \n                    nstart = 25, \n                    K.max = 10, \n                    B = 50)\n# Print the result\nprint(gap_stat, method = \"firstmax\")\n\nClustering Gap statistic [\"clusGap\"] from call:\nclusGap(x = shan_ict, FUNcluster = hcut, K.max = 10, B = 50, nstart = 25)\nB=50 simulated reference sets, k = 1..10; spaceH0=\"scaledPCA\"\n --> Number of clusters (method 'firstmax'): 1\n          logW   E.logW       gap     SE.sim\n [1,] 8.407129 8.680794 0.2736651 0.04460994\n [2,] 8.130029 8.350712 0.2206824 0.03880130\n [3,] 7.992265 8.202550 0.2102844 0.03362652\n [4,] 7.862224 8.080655 0.2184311 0.03784781\n [5,] 7.756461 7.978022 0.2215615 0.03897071\n [6,] 7.665594 7.887777 0.2221833 0.03973087\n [7,] 7.590919 7.806333 0.2154145 0.04054939\n [8,] 7.526680 7.731619 0.2049390 0.04198644\n [9,] 7.458024 7.660795 0.2027705 0.04421874\n[10,] 7.377412 7.593858 0.2164465 0.04540947\n\n\nNext, we can visualise the plot by using fviz_gap_stat() of factoextra package.\n\nfviz_gap_stat(gap_stat)\n\n\n\n\nThe option of 1 cluster has the biggest gap. However, having just 1 cluster does not make sense for the purpose of clustering. Among the other options, 6 cluster has the highest gap statistic. We will choose 6 clusters.\n\n\n\nInterpreting the dendrograms\nThe height of the fusion, provided on the vertical axis, indicates the (dis)similarity between two observations. The higher the height of the fusion, the less similar the observations are. Note that, conclusions about the proximity of two observations can be drawn only based on the height where branches containing those two observations first are fused. We cannot use the proximity of two observations along the horizontal axis as a criteria of their similarity.\n\nplot(hclust_ward, cex = 0.6)\nrect.hclust(hclust_ward, \n            k = 6, \n            border = 2:5)\n\n\n\n\n\n\nVisually-driven hierarchical clustering analysis\nIn this section, we will learn how to perform visually-driven hiearchical clustering analysis by using heatmaply package.\nWith heatmaply, we are able to build both highly interactive cluster heatmap or static cluster heatmap.\n\nTransforming the data frame into a matrix\nThe data shan_ict is a data frame, so we need to transform it to a matrix to draw the heatmap.\n\nshan_ict_mat <- data.matrix(shan_ict)\n\n\n\nPlotting interactive cluster heatmap using heatmaply()\n\nheatmaply(normalize(shan_ict_mat),\n          Colv=NA,\n          dist_method = \"euclidean\",\n          hclust_method = \"ward.D\",\n          seriate = \"OLO\",\n          colors = Blues,\n          k_row = 6,\n          margins = c(NA,200,60,NA),\n          fontsize_row = 4,\n          fontsize_col = 5,\n          main=\"Geographic Segmentation of Shan State by ICT indicators\",\n          xlab = \"ICT Indicators\",\n          ylab = \"Townships of Shan State\"\n          )\n\n\n\n\n\n\n\n\nMapping the clusters formed\ncutree() of R Base will be used in the code chunk below to derive a 6-cluster model.\n\ngroups <- as.factor(cutree(hclust_ward, k=6))\n\nThe output is called groups. It is a list object.\nIn order to visualise the clusters, the groups object need to be appended onto shan_sf simple feature object.\nThe code chunk below form the join in three steps:\n\nthe groups list object will be converted into a matrix;\ncbind() is used to append groups matrix onto shan_sf to produce an output simple feature object called shan_sf_cluster; and\nrename of dplyr package is used to rename as.matrix.groups field as CLUSTER.\n\n\nshan_sf_cluster <- cbind(shan_sf, as.matrix(groups)) %>%\n  rename(`CLUSTER`=`as.matrix.groups.`)\n\nLet’s draw the map with cluster!\n\nqtm(shan_sf_cluster, \"CLUSTER\")\n\n\n\n\nThe choropleth map above reveals the clusters are very fragmented. The is one of the major limitation when non-spatial clustering algorithm such as hierarchical cluster analysis method is used."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex03.html#spatially-constrained-clustering---skater-approach",
    "href": "Hands-on_Ex/Hands-on_Ex03.html#spatially-constrained-clustering---skater-approach",
    "title": "Geographical Segmentation with Spatially Constrained Clustering Techniques",
    "section": "Spatially Constrained Clustering - SKATER approach",
    "text": "Spatially Constrained Clustering - SKATER approach\n\nConverting into SpatialPolygonsDataFrame\nFirst, we need to convert shan_sf into SpatialPolygonsDataFrame. This is because SKATER function only support sp objects such as SpatialPolygonDataFrame.\nThe code chunk below uses as_Spatial() of sf package to convert shan_sf into a SpatialPolygonDataFrame called shan_sp.\n\nshan_sp <- as_Spatial(shan_sf)\n\n\n\nComputing Neighbor List\n\nshan.nb <- poly2nb(shan_sp)\nsummary(shan.nb)\n\nNeighbour list object:\nNumber of regions: 55 \nNumber of nonzero links: 264 \nPercentage nonzero weights: 8.727273 \nAverage number of links: 4.8 \nLink number distribution:\n\n 2  3  4  5  6  7  8  9 \n 5  9  7 21  4  3  5  1 \n5 least connected regions:\n3 5 7 9 47 with 2 links\n1 most connected region:\n8 with 9 links\n\n\nNow, let’s plot the neighbor network over the boundary map of Shan State.\n\nplot(shan_sp, \n     border=grey(.5))\nplot(shan.nb, \n     coordinates(shan_sp), \n     col=\"blue\", \n     add=TRUE)\n\n\n\n\n\n\nComputing minimum spanning tree\n\nCalculating edge costs\nNext, nbcosts() of spdep package is used to compute the cost of each edge. It is the distance between it nodes. This function compute this distance using a data.frame with observations vector in each node.\n\nlcosts <- nbcosts(shan.nb, shan_ict)\n\nWe will incorporate these costs into a weights object in the same way as we did in the calculation of inverse of distance weights. In other words, we convert the neighbour list to a list weights object by specifying the just computed lcosts as the weights.\nNote that we specify the style as B to make sure the cost values are not row-standardized.\n\nshan.w <- nb2listw(shan.nb, \n                   lcosts, \n                   style=\"B\")\nsummary(shan.w)\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 55 \nNumber of nonzero links: 264 \nPercentage nonzero weights: 8.727273 \nAverage number of links: 4.8 \nLink number distribution:\n\n 2  3  4  5  6  7  8  9 \n 5  9  7 21  4  3  5  1 \n5 least connected regions:\n3 5 7 9 47 with 2 links\n1 most connected region:\n8 with 9 links\n\nWeights style: B \nWeights constants summary:\n   n   nn       S0       S1        S2\nB 55 3025 76267.65 58260785 522016004\n\n\n\n\n\nComputing minimum spanning tree\n\nshan.mst <- mstree(shan.w)\n\nLet’s check shan.mst class and dimensions.\n\nclass(shan.mst)\n\n[1] \"mst\"    \"matrix\"\n\n\n\ndim(shan.mst)\n\n[1] 54  3\n\n\nNote that the dimension is 54 and not 55. This is because the minimum spanning tree consists on n-1 edges (links) in order to traverse all the nodes.\nWe can display the content of shan.mst by using head() as shown in the code chunk below.\n\nhead(shan.mst)\n\n     [,1] [,2]      [,3]\n[1,]   31   25 229.44658\n[2,]   25   10 163.95741\n[3,]   10    1 144.02475\n[4,]   10    9 157.04230\n[5,]    9    8  90.82891\n[6,]    8    6 140.01101\n\n\nThe plot method for the MST include a way to show the observation numbers of the nodes in addition to the edge. As before, we plot this together with the township boundaries. We can see how the initial neighbor list is simplified to just one edge connecting each of the nodes, while passing through all the nodes.\n\nplot(shan_sp, border=gray(.5))\nplot.mst(shan.mst, \n         coordinates(shan_sp), \n         col=\"blue\", \n         cex.lab=0.7, \n         cex.circles=0.005, \n         add=TRUE)\n\n\n\n\n\n\nComputing spatially constrained clusters using SKATER method\n\nclust6 <- skater(edges = shan.mst[,1:2], \n                 data = shan_ict, \n                 method = \"euclidean\", \n                 ncuts = 5)\n\nLet’s examine the content of clust6.\n\nstr(clust6)\n\nList of 8\n $ groups      : num [1:55] 3 3 6 3 3 3 3 3 3 3 ...\n $ edges.groups:List of 6\n  ..$ :List of 3\n  .. ..$ node: num [1:22] 13 48 54 55 45 37 34 16 25 31 ...\n  .. ..$ edge: num [1:21, 1:3] 48 55 54 37 34 16 45 31 13 13 ...\n  .. ..$ ssw : num 3423\n  ..$ :List of 3\n  .. ..$ node: num [1:18] 47 27 53 38 42 15 41 51 43 32 ...\n  .. ..$ edge: num [1:17, 1:3] 53 15 42 38 41 51 15 27 15 43 ...\n  .. ..$ ssw : num 3759\n  ..$ :List of 3\n  .. ..$ node: num [1:11] 2 6 8 1 36 4 10 9 46 5 ...\n  .. ..$ edge: num [1:10, 1:3] 6 1 8 36 4 6 8 10 10 9 ...\n  .. ..$ ssw : num 1458\n  ..$ :List of 3\n  .. ..$ node: num [1:2] 44 20\n  .. ..$ edge: num [1, 1:3] 44 20 95\n  .. ..$ ssw : num 95\n  ..$ :List of 3\n  .. ..$ node: num 23\n  .. ..$ edge: num[0 , 1:3] \n  .. ..$ ssw : num 0\n  ..$ :List of 3\n  .. ..$ node: num 3\n  .. ..$ edge: num[0 , 1:3] \n  .. ..$ ssw : num 0\n $ not.prune   : NULL\n $ candidates  : int [1:6] 1 2 3 4 5 6\n $ ssto        : num 12613\n $ ssw         : num [1:6] 12613 10977 9962 9540 9123 ...\n $ crit        : num [1:2] 1 Inf\n $ vec.crit    : num [1:55] 1 1 1 1 1 1 1 1 1 1 ...\n - attr(*, \"class\")= chr \"skater\"\n\n\nThe most interesting component of this list structure is the groups vector containing the labels of the cluster to which each observation belongs (as before, the label itself is arbitary). This is followed by a detailed summary for each of the clusters in the edges.groups list. Sum of squares measures are given as ssto for the total and ssw to show the effect of each of the cuts on the overall criterion.\n\nccs6 <- clust6$groups\nccs6\n\n [1] 3 3 6 3 3 3 3 3 3 3 2 1 1 1 2 1 1 1 2 4 1 2 5 1 1 1 2 1 2 2 1 2 2 1 1 3 1 2\n[39] 2 2 2 2 2 4 1 3 2 1 1 1 2 1 2 1 1\n\n\nWe can find out how many observations are in each cluster by means of the table command. Parenthetially, we can also find this as the dimension of each vector in the lists contained in edges.groups. For example, the first list has node with dimension 12, which is also the number of observations in the first cluster.\n\ntable(ccs6)\n\nccs6\n 1  2  3  4  5  6 \n22 18 11  2  1  1 \n\n\nWe can also plot the pruned tree that shows the five clusters on top of the townshop area.\n\nplot(shan_sp, border=gray(.5))\nplot(clust6, \n     coordinates(shan_sp), \n     cex.lab=.7,\n     groups.colors=c(\"red\",\"green\",\"blue\", \"brown\", \"pink\"),\n     cex.circles=0.005,\n     add = TRUE)\n\n\n\n\n\n\nVisualising the clusters in choropleth map\n\ngroups_mat <- as.matrix(clust6$groups)\nshan_sf_spatialcluster <- cbind(shan_sf_cluster, as.factor(groups_mat)) %>%\n  rename(`SP_CLUSTER`=`as.factor.groups_mat.`)\nqtm(shan_sf_spatialcluster, \"SP_CLUSTER\")\n\n\n\n\nLet’s place the hierarchical clustering map and the spatially constrained hierarchical clustering map side by side to compare.\n\nhclust.map <- qtm(shan_sf_cluster,\n                  \"CLUSTER\") + \n  tm_borders(alpha = 0.5)\n\nshclust.map <- qtm(shan_sf_spatialcluster,\n                   \"SP_CLUSTER\") + \n  tm_borders(alpha = 0.5) \n\ntmap_arrange(hclust.map, shclust.map,\n             asp=1, ncol=2)"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex3/In-class_Ex3.html",
    "href": "In-class_Ex/In-class_Ex3/In-class_Ex3.html",
    "title": "Geographical Segmentation with Spatially Constrained Clustering Technique",
    "section": "",
    "text": "This is a continuation of Hands-on Exercise 3. Refer HERE for Hands-on Exercise 3.\nThe code chunk below summarizes Hands-on Exercise 3.\nNotes\nread_csv() preserve the format of the variable name. read.csv() convert the column name to have . instead of space.\nWe convert the number of households that have the attribute, to percentage, then calculate the number per 1000 households.\ncor change the object into a correlation matrix form. [, 12:17] is column slicing."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex3/In-class_Ex3.html#spatially-constrained-clustering-method-clustgeo-method",
    "href": "In-class_Ex/In-class_Ex3/In-class_Ex3.html#spatially-constrained-clustering-method-clustgeo-method",
    "title": "Geographical Segmentation with Spatially Constrained Clustering Technique",
    "section": "Spatially Constrained Clustering Method: ClustGeo Method",
    "text": "Spatially Constrained Clustering Method: ClustGeo Method\nClustGeo can only work with Ward method clustering.\nIn the nutshell, the algorithm uses two dissimilarity matrices D0 and D1 along with a mixing parameter alpha, whereby the value of alpha must be a real number between [0, 1]. D0 can be non-Euclidean and the weights of the observations can be non-uniform. It gives the dissimilarities in the attribute/clustering variable space. D1, on the other hand, gives the dissimilarities in the constraint space. The criterion minimised at each stage is a convex combination of the homogeneity criterion calculated with D0 and the homogeneity criterion calculated with D1.\nThe idea is then to determine a value of alpha which increases the spatial contiguity without deteriorating too much the quality of the solution based on the variables of interest. This need is supported by a function called choicealpha().\n\nWard-like hierarchical clustering: ClustGeo\n\nnongeo_cluster <- hclustgeo(proxmat)\nplot(nongeo_cluster, cex = 0.5)\nrect.hclust(nongeo_cluster, \n            k = 6, \n            border = 2:5)\n\n\n\n\n\nMapping the clusters formed\n\ngroups <- as.factor(cutree(nongeo_cluster, k=6))\n\n\nshan_sf_ngeo_cluster <- cbind(shan_sf, as.matrix(groups)) %>%\n  rename(`CLUSTER` = `as.matrix.groups.`)\n\n\nqtm(shan_sf_ngeo_cluster, \"CLUSTER\")\n\n\n\n\n\n\n\nSpatially Constrained Hierarchical Clustering\nBefore we can performed spatially constrained hierarchical clustering, a spatial distance matrix will be derived by using st_distance() of sf package. We have to convert the data frame into a matrix for alphachoice().\n\ndist <- st_distance(shan_sf, shan_sf)\ndistmat <- as.dist(dist)\n\n\ncr <- choicealpha(proxmat, distmat, range.alpha = seq(0, 1, 0.1), K=6, graph = TRUE)\n\n\n\n\n\n\n\nWe will choose alpha = 0.3. Next, cutree() is used to derive the cluster object.\n\nclustG <- hclustgeo(proxmat, distmat, alpha = 0.3)\n\n\ngroups <- as.factor(cutree(clustG, k=6))\n\nWe will then join back the group list with shan_sf polygon feature data frame by using the code chunk below.\n\nshan_sf_Gcluster <- cbind(shan_sf, as.matrix(groups)) %>%\n  rename(`CLUSTER` = `as.matrix.groups.`)\n\nWe can now plot the map of the newly delineated spatially constrained clusters.\n\nqtm(shan_sf_Gcluster, \"CLUSTER\")"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html",
    "title": "Take-home Exercise 2: Regionalisation of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "",
    "text": "Take-home Exercise 2 is a continuation of Take-home Exercise 1. In this exercise, we will utilize spatially constrained clustering techniques like SKATER or ClustGeo to conduct the regionalization of Nigeria’s government areas (LGA level - ADM2). The regionalization will be based on the variables below:\n\nTotal number of functional water points\nTotal number of nonfunctional water points\nPercentage of functional water points\nPercentage of non-functional water points\nPercentage of main water point technology (i.e. Hand Pump)\nPercentage of usage capacity (i.e. < 1000, >=1000)\nPercentage of rural water points\nPercentage of water source (i.e. Well)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#setup",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#setup",
    "title": "Take-home Exercise 2: Regionalisation of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "Setup",
    "text": "Setup\n\nData\nThe data used in this exercise is the same as in Take-home Exercise 1. More details about the data and its source are mentioned in Take-home Exercise 1. In short, we will use two data sets:\n\nGeospatial data: the ADM2 data of Nigeria downloaded from Geoboundaries. For simplicity sake, we rename the files to NGA-ADM2.\nAspatial data: the data of water points in Nigeria is downloaded and filtered from the data set WPdx Global Data Repositories.\n\n\n\nR packages used\n\nsf: used for importing, managing, and processing geospatial data\ntidyverse: a collection of packages for data science tasks. It contains the sub-packages dplyr, ggplot2, forcats, tibble, readr, stringr, tidyr, purrr\ntmap: used for creating thematic maps, such as choropleth and bubble maps\nspdep: used for calculating spatial dependence - weighting schemes and statistics\nfunModeling: used for EDA and data preparation\ncorrplot, ggpubr, heatmaply, factoextra: multivariate data visualization and analysis\ncluster, ClustGeo: cluster analysis\n\nWe will load the needed packages into our environment using the code below.\n\n\nShow code\npacman::p_load(sf, tidyverse, tmap, spdep, funModeling,\n               corrplot, ggpubr, heatmaply, factoextra, cluster, ClustGeo)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#overview",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#overview",
    "title": "Take-home Exercise 2: Regionalisation of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "Overview",
    "text": "Overview\nTake-home Exercise 2 is a continuation of Take-home Exercise 1. In this exercise, we will utilize spatially constrained clustering techniques like SKATER or ClustGeo to conduct the regionalization of Nigeria’s government areas (LGA level - ADM2). The regionalization will be based on the variables below:\n\nTotal number of functional water points\nTotal number of nonfunctional water points\nPercentage of functional water points\nPercentage of non-functional water points\nPercentage of main water point technology (i.e. Hand Pump)\nPercentage of usage capacity (i.e. < 1000, >=1000)\nPercentage of rural water points"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#data-preparation-and-eda",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#data-preparation-and-eda",
    "title": "Take-home Exercise 2: Regionalisation of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "Data Preparation and EDA",
    "text": "Data Preparation and EDA\nRepeating what we did in Take-home Exercise 1, we will import the data, filter the data relevant to Nigeria, then conduct data wrangling to prepare for spatially constrained clustering.\n\nData Import and Filter\n\nAspatial data\nAfter importing the data, we filter the data related to Nigeria water points using the code chunk below. After that, we save the imported data set into an rds file called wp_nga.\n\n\nShow code\nwp <- st_read(dsn = \"data/aspatial\", layer = \"geo_export\", crs = 4326) %>% \n  filter(clean_coun == \"Nigeria\")\nwrite_rds(wp, \"data/wp_nga.rds\")\n\n\nNext, we reload the Nigeria aspatial data to an object called wp_nga.\n\n\nShow code\nwp_nga <- read_rds(\"data/wp_nga.rds\")\n\n\n\n\nGeospatial data\nWe import the geospatial data of Nigeria’s government areas into our environment.\n\n\nShow code\nnga <- st_read(dsn = \"data/geospatial\",\n               layer = \"NGA-ADM2\",\n               crs = 4326)\n\n\nReading layer `NGA-ADM2' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/Take-home_Ex/Take-home_Ex2/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 774 features and 5 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2.668534 ymin: 4.273007 xmax: 14.67882 ymax: 13.89442\nGeodetic CRS:  WGS 84\n\n\n\n\n\nData Wrangling\nThis section is dedicated to examining and transforming the data in wp_nga to include the data regarding water points status, technology, location (urban or rural), and capacity.\n\nData distribution\nBy inspecting the wp_nga file, we see that the data we want to use for clustering corresponds with the variables below.\n\n\n\nData\nVariable Name\nData Type/Format\n\n\n\n\nWater point status\nstatus_cle\nNominal/String\n\n\nWater point technology\nX_water_tec\nNominal/String\n\n\nWater point capacity\nusage_cap\nNumeric/Continuous\n\n\nWater point location\nis_urban\nBoolean\n\n\n\nLet’s look at the distribution of the variables by using the functions from funModeling package. freq() is used for categorical data, and plot_num() is used for numerical data.\n\n\nShow code\nwpstat <- freq(data = wp_nga, input = \"status_cle\")\n\n\n\n\n\nShow code\nwptec <- freq(data = wp_nga, input = \"X_water_tec\")\n\n\n\n\n\nShow code\nwpcap <- hist(wp_nga$usage_cap, main = \"Usage cap distribution\", xlab = \"Usage cap\")\n\n\n\n\n\nShow code\nwploc <- freq(data = wp_nga, input = \"is_urban\")\n\n\n\n\n\n\n\nRecoding NA Values into string"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#data-import-and-preparation",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#data-import-and-preparation",
    "title": "Take-home Exercise 2: Regionalisation of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "Data Import and Preparation",
    "text": "Data Import and Preparation\nRepeating what we did in Take-home Exercise 1, we will import the data, filter the data relevant to Nigeria, then conduct data wrangling to prepare for spatially constrained clustering.\n\nData Import and Filter\n\nAspatial data\nAfter importing the data, we filter the data related to Nigeria water points using the code chunk below. After that, we save the imported data set into an rds file called wp_nga.\n\n\nShow code\nwp <- st_read(dsn = \"data/aspatial\", layer = \"geo_export\", crs = 4326) %>% \n  filter(clean_coun == \"Nigeria\")\n\n\nReading layer `geo_export' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/Take-home_Ex/Take-home_Ex2/data/aspatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 406566 features and 72 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -92.05073 ymin: -27.31495 xmax: 92.32694 ymax: 26.65622\nGeodetic CRS:  WGS 84\n\n\nShow code\nwrite_rds(wp, \"data/wp_nga.rds\")\n\n\nNext, we reload the Nigeria aspatial data to an object called wp_nga.\n\n\nShow code\nwp_nga <- read_rds(\"data/wp_nga.rds\")\n\n\n\n\nGeospatial data\nWe import the geospatial data of Nigeria’s government areas into our environment.\n\n\nShow code\nnga <- st_read(dsn = \"data/geospatial\",\n               layer = \"NGA-ADM2\",\n               crs = 4326)\n\n\nReading layer `NGA-ADM2' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/Take-home_Ex/Take-home_Ex2/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 774 features and 5 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2.668534 ymin: 4.273007 xmax: 14.67882 ymax: 13.89442\nGeodetic CRS:  WGS 84\n\n\n\n\n\nData Wrangling\nThis section is dedicated to examining and transforming the data in wp_nga to include the data regarding water points status, technology, location (urban or rural), and capacity.\n\nData distribution\nBy inspecting the wp_nga file, we see that the data we want to use for clustering corresponds with the variables below.\n\n\n\nData\nVariable Name\nData Type/Format\n\n\n\n\nWater point status\nstatus_cle\nNominal/String\n\n\nWater point technology\nX_water_tec\nNominal/String\n\n\nWater point capacity\nusage_cap\nNumeric/Continuous\n\n\nWater point location\nis_urban\nBoolean\n\n\n\nLet’s look at the distribution of the variables by using the functions from funModeling package. freq() is used for categorical data, and plot_num() is used for numerical data.\n\n\nShow code\nwpstat <- freq(data = wp_nga, input = \"status_cle\")\n\n\n\n\n\nShow code\nwptec <- freq(data = wp_nga, input = \"X_water_tec\")\n\n\n\n\n\nShow code\nwpcap <- hist(wp_nga$usage_cap, main = \"Usage cap distribution\", xlab = \"Usage cap\")\n\n\n\n\n\nShow code\nwploc <- freq(data = wp_nga, input = \"is_urban\")\n\n\n\n\n\nWhile freq() reveal the missing values as NA, hist() allows and omits NA values. Therefore, we need to check NA values for usage_cap with the code chunk below.\n\n\nShow code\ncheckna <- is.na(wp_nga$usage_cap)\nsummary(checkna)\n\n\n   Mode   FALSE \nlogical   95008 \n\n\nThe good news is there is no missing value in usage_cap. We can proceed with our analysis.\n\n\nExtracting functional data\nUsing filter() from the dplyr package, we filter out the functional values and assign it to a new variable called wpt_functional. This method will be used to extract other data from wp_nga.\n\n\nShow code\nwpt_functional <- wp_nga %>% \n  filter(status_cle %in%\n           c(\"Functional\", \"Functional but needs repair\",\n             \"Functional but not in use\"))\n\n\n\n\nExtracting non-functional data\n\n\nShow code\nwpt_nonfunctional <- wp_nga %>% \n  filter(status_cle %in%\n           c(\"Non-Functional\", \"Non-Functional due to dry season\",\n             \"Abandoned/Decommissioned\", \"Abandoned\",\n             \"Non functional due to dry season\"))\n\n\n\n\nExtracting main water point technology data\nLooking at the distribution of the water point technology, we see that Hand Pump and Mechanized Pump account for the majority of water points technology, 61.84% and 26.99% respectively. We will extract the data containing water points with hand pump technology and mechanized pump technology.\n\n\nShow code\nhandpump <- wp_nga %>% \n  filter(X_water_tec == \"Hand Pump\")\nmecpump <- wp_nga %>% \n  filter(X_water_tec == \"Mechanized Pump\")\n\n\n\n\nExtracting usage capacity data\nBased on the histogram of usage_cap, there are two major range of values that the usage capacity clutters around. The first range is under 400, and the second range is above 800 and less than 1,000. We will use summary() of Base R to inspect in more details.\n\n\nShow code\nsummary(wp_nga$usage_cap)\n\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   50.0   300.0   300.0   488.6  1000.0  1000.0 \n\n\nWe will use the threshold of the median, which is 300, to recode usage_cap and form two data range. After recoding, we will also extract usage capacity the data with recoded range. To recode, we will use mutate() and replace() of dplyr.\n\n\nShow code\nwp_nga <- read_rds(\"data/wp_nga.rds\") %>% \n  mutate(usage_cap = replace(usage_cap, usage_cap > 300, \"Greater than 300\")) %>% \n  mutate(usage_cap = replace(usage_cap, usage_cap <= 300, \"Less than or equal to 300\"))\ncap300_greater <- wp_nga %>% filter(usage_cap == \"Greater than 300\")\ncap300_less <- wp_nga %>% filter(usage_cap == \"Less than or equal to 300\")\n\n\n\n\nExtracting rural water point data\n\n\nShow code\nruralwp <- wp_nga %>% filter(is_urban == \"False\")\n\n\n\n\n\nPerforming Point-in Polygon Count\nSimilar to what we did in Take-home Exercise 1, now it is time to group the variables according to which government areas that observation belong to. We will conduct point-in polygon count using st_intersects() of tmap.\n\n\nShow code\nnga_wp <- nga %>% \n  mutate(total_wp = lengths(st_intersects(nga, wp_nga))) %>% \n  mutate(functional = lengths(st_intersects(nga, wpt_functional))) %>% \n  mutate(nonfunctional = lengths(st_intersects(nga, wpt_nonfunctional))) %>% \n  mutate(hand = lengths(st_intersects(nga, handpump))) %>% \n  mutate(mechanized = lengths(st_intersects(nga, mecpump))) %>% \n  mutate(greater_300_cap = lengths(st_intersects(nga, cap300_greater))) %>% \n  mutate(less_300_cap = lengths(st_intersects(nga, cap300_less))) %>% \n  mutate(rural = lengths(st_intersects(nga, ruralwp)))\n\n\n\n\nChecking duplicate area names\nWhile duplicate area names do not affect spatial weights analysis because it is based on the geometry of the areas, it can affect cluster analysis which is based on the values of the variables. Therefore, we need to check and rename duplicates area names before conducting cluster analysis. To check for duplicates, we will use duplicated() of the tidyverse package.\n\n\nShow code\ndupcheck <- duplicated(nga_wp$shapeName)\nsummary(dupcheck)\n\n\n   Mode   FALSE    TRUE \nlogical     768       6 \n\n\nFrom the summary, we can see that there are 6 areas with duplicate names. These are the local government areas (LGA) with the same name that belong to different states on the ADM1 level. Using the code chunk below, we extract the names of the duplicated areas, then match them with their corresponding ADM1 in wp_nga states to find out which state they belong to.\n\n\nShow code\ndupnames <- nga_wp[dupcheck,]$shapeName\ndupnames\n\n\n[1] \"Bassa\"    \"Ifelodun\" \"Irepodun\" \"Nasarawa\" \"Obi\"      \"Surulere\"\n\n\nNow let’s use the duplicated names we extracted to find out the states they belong to. cbind() is used to filter duplicates from multiple columns.\n\n\nShow code\nstatenames <- wp_nga[wp_nga$clean_adm2 %in% dupnames, 14:15]\nstatenames <- statenames[!duplicated(cbind(statenames$clean_adm1, statenames$clean_adm2)),]\nstatenames\n\n\nSimple feature collection with 12 features and 2 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 3.355785 ymin: 6.498105 xmax: 8.68657 ymax: 11.98826\nGeodetic CRS:  WGS 84\nFirst 10 features:\n      clean_adm1 clean_adm2                  geometry\n99         Kwara   Irepodun POINT (4.926598 8.107983)\n289         Kogi      Bassa POINT (7.063799 7.884609)\n863        Lagos   Surulere POINT (3.355785 6.498105)\n3778       Benue        Obi POINT (8.332327 6.926308)\n7353        Osun   Irepodun POINT (4.490475 7.829663)\n7382        Osun   Ifelodun  POINT (4.66123 7.913148)\n7640         Oyo   Surulere POINT (4.447453 7.942235)\n12445   Nasarawa   Nasarawa POINT (7.837579 7.998326)\n15215      Kwara   Ifelodun POINT (4.859352 8.520893)\n15345   Nasarawa        Obi POINT (8.670447 8.356312)\n\n\nNow we have a list of 12 duplicated LGAs together with their states. Notice that since we are filtering on wp_nga, the geometry is the location point of a certain water point and not of the LGA. Therefore, we will use st_join() of sp package to add the state names into nga_wp based on geometry data. paste() of Base R is used to concatenate the LGA name with their state name in shapeName column, then str_trim() of Base R is used to remove the white space, if any. After we have added the state names to the duplicate LGA names, clean_adm1 and clean_adm2 column will be removed.\n\n\nShow code\nnga_wp <- st_join(nga_wp, statenames) %>% \n  mutate(clean_adm1 = replace_na(clean_adm1, \" \"))\nnga_wp$shapeName <- str_trim(paste(nga_wp$shapeName, nga_wp$clean_adm1))\nnga_wp <- subset(nga_wp, select = -c(clean_adm1, clean_adm2))\n\n\n\n\nCalculating the Percentage of Water Point Values\nAbsolute measurement of a water point attribute can be affected by the number of water points in an area. For example, an urban area can have a higher number of rural water points than a rural area, simply because it has more water points, while the rural areas does not have many water points to begin with. To offset that effect, we will use percentage measurement. The percentage is calculated over the number of water points having a specific attribute in correspondent with the total number of water points in that government area.\nBefore we calculate the percentage, it is important to check out the distribution of total_wp because it is the denominator. The code chunk below filters if there is any area that does not have any water points.\n\n\nShow code\nzerowp <- nga_wp %>% \n  filter(total_wp == 0)\nzerowp$shapeName\n\n\n [1] \"Abadam\"     \"Bakassi\"    \"Geidam\"     \"Gubio\"      \"Gujba\"     \n [6] \"Guzamala\"   \"Kaga\"       \"Kala/Balge\" \"Kukawa\"     \"Madagali\"  \n[11] \"Marte\"      \"Mobbar\"     \"Nganzai\"   \n\n\nBased on the result, we know that the areas above do not have any water points. As the goal of our cluster analysis is to inspect the areas based on their water point count, the areas with no water points should be removed from our data set. The tasked will be carried out using subset() of Base R.\n\n\nShow code\nnga_wp <- subset(nga_wp, total_wp != 0)\n\n\nNext, we will calcuate the percentage of all variables in nga_wp.\n\n\nShow code\nnga_wp <- nga_wp %>% \n  mutate(pct_functional = functional/total_wp*100) %>% \n  mutate(pct_nonfunctional = nonfunctional/total_wp*100) %>% \n  mutate(pct_hand = hand/total_wp*100) %>% \n  mutate(pct_mec = mechanized/total_wp*100) %>% \n  mutate(pct_greater300 = greater_300_cap/total_wp*100) %>% \n  mutate(pct_less300 = less_300_cap/total_wp*100) %>% \n  mutate(pct_rural = rural/total_wp*100)\n\n\nFinally, we will remove the unnecessary columns, which are Level, shapeID, shapeGroup, shapeType, hand, mechanized, greater_300_cap, less_300_cap, rural. At the same time, we relocate the geometry column to after shapeName column.\n\n\nShow code\nnga_wp <- nga_wp[,-c(2,3,4,5,9,10,11,12,13)] %>% \n  relocate(geometry, .after = shapeName)\n\n\n\n\nTransforming to projected coordinate system\nBefore proceeding, we need to transform nga_wp into a projected coordinate system. The reason being further analysis involves distance-based calculate, which will not yield correct result if the data is not in the projected coordinate system. To do the transformation task, we will utilize st_transform() from sf package. The EPSG code we will convert the data into is EPSG:26391, used for Nigeria West Belt.\n\n\nShow code\nnga_wp <- st_transform(nga_wp, crs = 26391)\n\n\n\n\nSaving working data table\nWe will save nga_wp into an rds file using the code below.\n\n\nShow code\nwrite_rds(nga_wp, \"data/nga_wp.rds\")"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#exploratory-data-analysis-eda",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#exploratory-data-analysis-eda",
    "title": "Take-home Exercise 2: Regionalisation of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "Exploratory Data Analysis (EDA)",
    "text": "Exploratory Data Analysis (EDA)\nNow we can reload the nga_wp_clean.rds file we just saved.\n\n\nShow code\nnga_wp <- read_rds(\"data/nga_wp.rds\")\n\n\n\nInspecting the distribution of the variables\nBecause the variables in consideration are in numerical format, histogram and boxplot are appropriate tools to examine their distribution. Histogram reveals the shape of the distribution, while boxplot show if the variables has outliers and by how many.\nTo conduct this step. ggplot(), geom_histogram() and geom_boxplot() from ggplot2 package are utilized.\n\nFunctional water point count\n\n\nShow code\nsummary(nga_wp$functional)\n\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   0.00   18.00   47.00   68.51   88.00  752.00 \n\n\n\n\nShow code\nfunchis <- ggplot(data = nga_wp, aes(x = functional)) +\n  geom_histogram(bins = 20, color = \"black\", fill = \"lightblue\")\nfuncbox <- ggplot(data = nga_wp, aes(x = functional)) +\n  geom_boxplot(color = \"black\", fill = \"lightblue\")\nplotfunc <- ggarrange(funchis, funcbox, ncol = 2, nrow = 1)\nannotate_figure(plotfunc, top = text_grob(\"Functional Water Points Count\",\n                face = \"bold\"))\n\n\n\n\n\n\n\nNon-functional water point count\n\n\nShow code\nsummary(nga_wp$nonfunctional)\n\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   0.00   14.00   34.00   42.31   61.00  278.00 \n\n\n\n\nShow code\nnfunchis <- ggplot(data = nga_wp, aes(x = nonfunctional)) +\n  geom_histogram(bins = 20, color = \"black\", fill = \"lightblue\")\nnfuncbox <- ggplot(data = nga_wp, aes(x = nonfunctional)) +\n  geom_boxplot(color = \"black\", fill = \"lightblue\")\nplotnfunc <- ggarrange(nfunchis, nfuncbox, ncol = 2, nrow = 1)\nannotate_figure(plotnfunc, top = text_grob(\"Non-functional Water Points Count\",\n                face = \"bold\"))\n\n\n\n\n\n\n\nFunctional water point percentage\n\n\nShow code\nfunchisp <- ggplot(data = nga_wp, aes(x = pct_functional)) +\n  geom_histogram(bins = 20, color = \"black\", fill = \"lightblue\")\nfuncboxp <- ggplot(data = nga_wp, aes(x = pct_functional)) +\n  geom_boxplot(color = \"black\", fill = \"lightblue\")\nplotfuncp <- ggarrange(funchisp, funcboxp, ncol = 2, nrow = 1)\nannotate_figure(plotfuncp, top = text_grob(\"Functional Water Points Percentage\",\n                face = \"bold\"))\n\n\n\n\n\nSince the distribution of pct_functional does not skew too much. We will conduct a fit normal line to find out if the variable follows a normal distribution. The task will be conducted with fitdistr() from fitdistrplus package.\n\n\nShow code\npacman::p_load(fitdistrplus)\nfit <- fitdist(nga_wp$pct_functional, \"norm\")\nplot(fit)\n\n\n\n\n\nFrom the plots, we can see that pct_functional follows a normal distribution.\n\n\nNon-functional water point percentage\n\n\nShow code\nnfunchisp <- ggplot(data = nga_wp, aes(x = pct_nonfunctional)) +\n  geom_histogram(bins = 20, color = \"black\", fill = \"lightblue\")\nnfuncboxp <- ggplot(data = nga_wp, aes(x = pct_nonfunctional)) +\n  geom_boxplot(color = \"black\", fill = \"lightblue\")\nplotnfuncp <- ggarrange(nfunchisp, nfuncboxp, ncol = 2, nrow = 1)\nannotate_figure(plotnfuncp, top = text_grob(\"Non-functional Water Points Percentage\",\n                face = \"bold\"))\n\n\n\n\n\n\n\nHand-pump water point percentage\n\n\nShow code\nhandhisp <- ggplot(data = nga_wp, aes(x = pct_hand)) +\n  geom_histogram(bins = 20, color = \"black\", fill = \"lightblue\")\nhandboxp <- ggplot(data = nga_wp, aes(x = pct_hand)) +\n  geom_boxplot(color = \"black\", fill = \"lightblue\")\nplothandp <- ggarrange(handhisp, handboxp, ncol = 2, nrow = 1)\nannotate_figure(plothandp, top = text_grob(\"Hand Pump Percentage\",\n                face = \"bold\"))\n\n\n\n\n\n\n\nMechanized pump water point percentage\n\n\nShow code\nmechisp <- ggplot(data = nga_wp, aes(x = pct_mec)) +\n  geom_histogram(bins = 20, color = \"black\", fill = \"lightblue\")\nmecboxp <- ggplot(data = nga_wp, aes(x = pct_mec)) +\n  geom_boxplot(color = \"black\", fill = \"lightblue\")\nplotmecp <- ggarrange(mechisp, mecboxp, ncol = 2, nrow = 1)\nannotate_figure(plotmecp, top = text_grob(\"Mechanized Pump Percentage\",\n                face = \"bold\"))\n\n\n\n\n\n\n\nUsage capacity greater than 300 percentage\n\n\nShow code\ng300hisp <- ggplot(data = nga_wp, aes(x = pct_greater300)) +\n  geom_histogram(bins = 20, color = \"black\", fill = \"lightblue\")\ng300boxp <- ggplot(data = nga_wp, aes(x = pct_greater300)) +\n  geom_boxplot(color = \"black\", fill = \"lightblue\")\nplotg300p <- ggarrange(g300hisp, g300boxp, ncol = 2, nrow = 1)\nannotate_figure(plotg300p, top = text_grob(\"Usage Capacity Greater than 300 Percentage\",\n                face = \"bold\"))\n\n\n\n\n\n\n\nUsage capacity less than or equal to 300 percentage\n\n\nShow code\nl300hisp <- ggplot(data = nga_wp, aes(x = pct_less300)) +\n  geom_histogram(bins = 20, color = \"black\", fill = \"lightblue\")\nl300boxp <- ggplot(data = nga_wp, aes(x = pct_less300)) +\n  geom_boxplot(color = \"black\", fill = \"lightblue\")\nplotl300p <- ggarrange(l300hisp, l300boxp, ncol = 2, nrow = 1)\nannotate_figure(plotl300p, top = text_grob(\"Usage Capacity Less than or Equal to 300 Percentage\",\n                face = \"bold\"))\n\n\n\n\n\n\n\nRural water point percentage\n\n\nShow code\nruralhisp <- ggplot(data = nga_wp, aes(x = pct_rural)) +\n  geom_histogram(bins = 20, color = \"black\", fill = \"lightblue\")\nruralboxp <- ggplot(data = nga_wp, aes(x = pct_rural)) +\n  geom_boxplot(color = \"black\", fill = \"lightblue\")\nplotruralp <- ggarrange(ruralhisp, ruralboxp, ncol = 2, nrow = 1)\nannotate_figure(plotruralp, top = text_grob(\"Rural Water Point Percentage\",\n                face = \"bold\"))\n\n\n\n\n\n\n\nObservation\nLooking at the distribution, we can see that the scale of the variables are within 0 to 100 for all percentage variables. functional and nonfunctional has the maximum value of 752 and 278 respectively. Because the range of functional is very large comparing to the range of other variables, we need to standardize functional.\n\nNotes: the distribution of most variables is skewed and does not fit the normal distribution. Therefore, we do not have enough evidence to assume that the variables follow a normal distribution.\n\n\n\n\nData Standardization\nWe will standardize functional using the Min-Max method. The task is done using normalize() of heatmaply. The standardized value is then multiplied by 100 to convert it into the percentage value.\n\n\nShow code\nnga_wp$functional = normalize(nga_wp$functional)*100\n\n\n\n\nEDA with Choropleth Map\nChoropleth map is used to examine the distribution of attributes over the studied areas. The density of the values is displayed based on the intensity of the color. In the maps below, we will use tm_shape(), tm_borders(), tm_fill() and tm_arrange() from tmap package to draw the choropleth map.\n\n\nShow code\nfuncmap <- tm_shape(nga_wp) +\n  tm_fill(col = \"functional\", n = 5, style = \"jenks\", title = \"Functional WP\", palette = \"GnBu\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.width = 0.3,\n            legend.height = 0.3,\n            legend.text.size = 0.5)\nnfuncmap <- tm_shape(nga_wp) +\n  tm_fill(col = \"nonfunctional\", n = 5, style = \"jenks\", title = \"Non-functional WP\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.width = 0.3,\n            legend.height = 0.3,\n            legend.text.size = 0.5)\nfuncpmap <- tm_shape(nga_wp) +\n  tm_fill(col = \"pct_functional\", n = 5, style = \"jenks\",\n          title = \"Functional WP Percentage\", palette = \"GnBu\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.width = 0.3,\n            legend.height = 0.3,\n            legend.text.size = 0.5)\nnfuncpmap <- tm_shape(nga_wp) +\n  tm_fill(col = \"pct_nonfunctional\", n = 5, style = \"jenks\", title = \"Non-functional WP Percentage\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.width = 0.3,\n            legend.height = 0.3,\n            legend.text.size = 0.5)\nhandpmap <- tm_shape(nga_wp) +\n  tm_fill(col = \"pct_hand\", n = 5, style = \"jenks\",\n          title = \"Hand Pump Percentage\", palette = \"BuPu\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.width = 0.3,\n            legend.height = 0.3,\n            legend.text.size = 0.5)\nmecpmap <- tm_shape(nga_wp) +\n  tm_fill(col = \"pct_mec\", n = 5, style = \"jenks\",\n          title = \"Mechanized Pump Percentage\", palette = \"BuPu\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.width = 0.3,\n            legend.height = 0.3,\n            legend.text.size = 0.5)\ng300pmap <- tm_shape(nga_wp) +\n  tm_fill(col = \"pct_greater300\", n = 5, style = \"jenks\",\n          title = \">300 Cap Percentage\", palette = \"PuBuGn\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.width = 0.3,\n            legend.height = 0.3,\n            legend.text.size = 0.5)\nl300pmap <- tm_shape(nga_wp) +\n  tm_fill(col = \"pct_less300\", n = 5, style = \"jenks\",\n          title = \"<=300 Cap Percentage\", palette = \"PuBuGn\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.width = 0.3,\n            legend.height = 0.3,\n            legend.text.size = 0.5)\nruralpmap <- tm_shape(nga_wp) +\n  tm_fill(col = \"pct_rural\", n = 5, style = \"jenks\",\n          title = \"Rural Percentage\", palette = \"BuGn\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.width = 0.3,\n            legend.height = 0.3,\n            legend.text.size = 0.5)\ntotal <- tm_shape(nga_wp) +\n  tm_fill(col = \"total_wp\", n = 5, style = \"jenks\",\n          title = \"Total water point\", palette = \"BrBG\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.width = 0.3,\n            legend.height = 0.3,\n            legend.text.size = 0.5)\n\n\n\n\nShow code\ntmap_arrange(total, ruralpmap, asp = 1, ncol = 2, outer.margins = c(0,0,0,0))\n\n\n\n\n\nShow code\ntmap_arrange(funcmap, nfuncmap, asp = 1, ncol = 2, outer.margins = c(0,0,0,0))\n\n\n\n\n\nShow code\ntmap_arrange(funcpmap, nfuncpmap, asp = 1, ncol = 2, outer.margins = c(0,0,0,0))\n\n\n\n\n\nShow code\ntmap_arrange(handpmap, mecpmap, asp = 1, ncol = 2, outer.margins = c(0,0,0,0))\n\n\n\n\n\nShow code\ntmap_arrange(g300pmap, l300pmap, asp = 1, ncol = 2, outer.margins = c(0,0,0,0))\n\n\n\n\n\nBased on the maps, the distribution of functional and non-functional water points count overlap with total water point count, which is understandable because the higher total_wp, the higher functional and nonfunctional. This similarity decreases as the count is changed to percentage with pct_functional and pct_nonfunctional. As the cluster analysis is sensitive toward correlation, we will not include total_wp into clustering.\nIn addition, the map of mechanized pump and usage capacity greater than 300 look similar, suggesting correlation. Since correlation will affect clustering, we need to detect and remove other correlated variables.\nNotice that the white areas on the map are the LGAs that we removed because they have zero water points."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#eda-with-choropleth-map",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#eda-with-choropleth-map",
    "title": "Take-home Exercise 2: Regionalisation of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "EDA with Choropleth Map",
    "text": "EDA with Choropleth Map\n\n\nShow code\nfuncmap <- tm_shape(nga_wp) +\n  tm_fill(col = \"functional\", n = 5, style = \"jenks\", title = \"Functional WP\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.width = 0.3,\n            legend.height = 0.3,\n            legend.text.size = 0.5)\nnfuncmap <- tm_shape(nga_wp) +\n  tm_fill(col = \"nonfunctional\", n = 5, style = \"jenks\", title = \"Non-functional WP\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.width = 0.3,\n            legend.height = 0.3,\n            legend.text.size = 0.5)\nfuncpmap <- tm_shape(nga_wp) +\n  tm_fill(col = \"pct_functional\", n = 5, style = \"jenks\", title = \"Functional WP Percentage\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.width = 0.3,\n            legend.height = 0.3,\n            legend.text.size = 0.5)\nnfuncpmap <- tm_shape(nga_wp) +\n  tm_fill(col = \"pct_nonfunctional\", n = 5, style = \"jenks\", title = \"Non-functional WP Percentage\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.width = 0.3,\n            legend.height = 0.3,\n            legend.text.size = 0.5)\nhandpmap <- tm_shape(nga_wp) +\n  tm_fill(col = \"pct_hand\", n = 5, style = \"jenks\", title = \"Hand Pump Percentage\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.width = 0.3,\n            legend.height = 0.3,\n            legend.text.size = 0.5)\nmecpmap <- tm_shape(nga_wp) +\n  tm_fill(col = \"pct_mec\", n = 5, style = \"jenks\", title = \"Mechanized Pump Percentage\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.width = 0.3,\n            legend.height = 0.3,\n            legend.text.size = 0.5)\ng300pmap <- tm_shape(nga_wp) +\n  tm_fill(col = \"pct_greater300\", n = 5, style = \"jenks\", title = \">300 Cap Percentage\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.width = 0.3,\n            legend.height = 0.3,\n            legend.text.size = 0.5)\nl300pmap <- tm_shape(nga_wp) +\n  tm_fill(col = \"pct_less300\", n = 5, style = \"jenks\", title = \"<=300 Cap Percentage\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.width = 0.3,\n            legend.height = 0.3,\n            legend.text.size = 0.5)\nruralpmap <- tm_shape(nga_wp) +\n  tm_fill(col = \"pct_rural\", n = 5, style = \"jenks\", title = \"Rural Percentage\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.width = 0.3,\n            legend.height = 0.3,\n            legend.text.size = 0.5)\n\n\n\n\nShow code\ntmap_arrange(funcmap, nfuncmap, funcpmap, nfuncpmap, asp = 2, ncol = 2)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#correlation-analysis",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#correlation-analysis",
    "title": "Take-home Exercise 2: Regionalisation of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "Correlation Analysis",
    "text": "Correlation Analysis\nBefore we perform cluster analysis, it is important for us to ensure that the cluster variables are not highly correlated. To detect correlation, the best tool is multivariate graph with corrplot.mixed() from corrplot package. st_drop_geometry() from sf package is used to remove the geometry column and turn nga_wp into a non-spatial data frame.\n\nNotes: highly correlated meaning the correlation coefficient is greater than or equal to 0.85.\n\n\n\nShow code\nclust.cor = cor(st_drop_geometry(nga_wp[,4:12]))\ncorrplot.mixed(clust.cor,\n               lower = \"ellipse\",\n               upper = \"number\",\n               tl.pos = \"lt\",\n               diag = \"l\",\n               tl.col = \"black\")\n\n\n\n\n\nBased on the multivariate correlation table, pct_less300 is highly correlated with pct_mec and pct_greater300. pct_mec and pct_greater300 are also highly correlated. We will remove pct_less300 and pct_mec from our analysis.\n\n\nShow code\nnga_wp <- nga_wp[,-c(9, 11)]\nclust.cor = cor(st_drop_geometry(nga_wp[,4:10]))\ncorrplot.mixed(clust.cor,\n               lower = \"ellipse\",\n               upper = \"number\",\n               tl.pos = \"lt\",\n               diag = \"l\",\n               tl.col = \"black\")\n\n\n\n\n\nAfter removing pct_less300 and pct_mec, our data is no longer highly correlated."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#spatially-constrained-clustering-skater",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#spatially-constrained-clustering-skater",
    "title": "Take-home Exercise 2: Regionalisation of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "Spatially Constrained Clustering: SKATER",
    "text": "Spatially Constrained Clustering: SKATER\nSKATER is a spatially constrained clustering method based on the contiguity of the geospatial units. It uses the Tree Edge Removal algorithm to construct minimum spanning tree from adjacency graph, achieving maximum internal homogeneity within the cluster.\nTo conduct SKATER clustering, there are … steps.\n\nConvert the simple feature data frame into a spatial polygon data frame. This is because the SKATER function only works on spatial polygon data frames.\nCompute neighbor list. The neighbor is defined based on contiguity, also known as shared boundary.\nCompute minimum spanning tree. The trees are calculated using SKATER function to maximize internal homogeneity.\nCompute spatially constrained clusters. In this step, we group and assign cluster labels to the area unites.\nVisualize the clusters on the map. Using the choropleth map, we will display the location of the clusters on the studied area.\n\n\nConverting simple feature data frame into spatial polygon data frame\nThis task is conducted using as_Spatial() from sp package.\n\n\nShow code\nwp_sp <- as_Spatial(nga_wp)\n\n\n\n\nComputing neighbor list\npoly2nb() from spdep is used to compute the contiguous neighbor list using the QUEEN method.\n\n\nShow code\nwp_nb <- poly2nb(wp_sp)\nsummary(wp_nb)\n\n\nNeighbour list object:\nNumber of regions: 761 \nNumber of nonzero links: 4348 \nPercentage nonzero weights: 0.750793 \nAverage number of links: 5.713535 \nLink number distribution:\n\n  1   2   3   4   5   6   7   8   9  10  11  12  14 \n  4  16  57 122 177 137 121  71  39  11   4   1   1 \n4 least connected regions:\n138 509 525 560 with 1 link\n1 most connected region:\n508 with 14 links\n\n\nWith the neighbor list, now we can view the neighbor network using plot() from Base R.\n\n\nShow code\nplot(wp_sp, \n     border=grey(.5))\nplot(wp_nb, \n     coordinates(wp_sp), \n     col=\"blue\",\n     pch = 19,\n     cex = 0.2,\n     add=TRUE)\n\n\n\n\n\n\n\n\n\n\n\nComputing minimum spanning tree\nnbcosts() from spdep package will be used to calculate the cost of each tree, which is the distance between the nodes. This function compute this distance using a data.frame with observations vector in each node.\n\n\nShow code\nlcosts <- nbcosts(wp_nb, nigeria_clust)\n\n\nWhen viewing lcosts, we notice that it has the pairwise dissimilarity of the variables between a specific LGA and its neighbors. Next, we will compute a weight matrix based on the data of lcosts, treated as the weight. The “binary” style is chosen for the weight calculation as it is more robust.\n\n\nShow code\nnigeria.w <- nb2listw(wp_nb,\n                      lcosts,\n                      style = \"B\")\nsummary(nigeria.w)\n\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 761 \nNumber of nonzero links: 4348 \nPercentage nonzero weights: 0.750793 \nAverage number of links: 5.713535 \nLink number distribution:\n\n  1   2   3   4   5   6   7   8   9  10  11  12  14 \n  4  16  57 122 177 137 121  71  39  11   4   1   1 \n4 least connected regions:\n138 509 525 560 with 1 link\n1 most connected region:\n508 with 14 links\n\nWeights style: B \nWeights constants summary:\n    n     nn       S0       S1        S2\nB 761 579121 269330.2 43789952 481971405\n\n\nNext, we will use mstree() of spdep package to compute the minimum spanning tree.\n\n\nShow code\nnigeria.mst <- mstree(nigeria.w)\n\n\nNow we can plot the tree networks and their nodes onto Nigeria map.\n\n\nShow code\nplot(wp_sp, border=gray(.5))\nplot.mst(nigeria.mst, \n         coordinates(wp_sp), \n         col=\"blue\", \n         cex.lab=0.7, \n         cex.circles=0.005, \n         add=TRUE)\n\n\n\n\n\n\n\n\n\nSince our data set has more than 700 observations, presenting the minimum spanning tree on the map produces a lot of clutter nodes and overlapping text. From now on, we will only present the clusters using the choropleth map.\n\n\nComputing spatially constrained clusters using SKATER method\nWe will use skater() from spdep package to compute the spatially constrained clusters. Based on the analysis in Hierarchical Clustering, we will choose the number of cluster to be 8.\n\n\nShow code\nclust8 <- spdep::skater(edges = nigeria.mst[,1:2],\n                        data = nigeria_clust,\n                        method = \"euclidean\",\n                        ncuts = 7)\n\n\nNow we can plot the choropleth map for the clusters!\n\n\nVisualizing the clusters in choropleth map\nFirst, let’s compute the clusters and their corresponding geometry. We will call it nigeria_spatialcluster.\n\n\nShow code\ngroups_mat <- as.matrix(clust8$groups)\nnigeria_spatialcluster <- cbind(nigeria_sf_cluster, as.factor(groups_mat)) %>%\n  rename(`SP_CLUSTER`=`as.factor.groups_mat.`)\n\n\nNotice that nigeria_spatialcluster is calculated based on nga_wp_clean, which does not contain the areas that have no water point. For the sake of visualization, we will add those areas back to our spatial clustering data and set the zero-water-point areas to be in cluster 0. To do so, we will adjust the columns of zerowp to match with nigeria_spatiacluster, transform it to the projected coordinate system of EPSG 26391, then stack the two table together.\n\n\nShow code\nzerowpl <- zerowp[, -c(2:5)] %>% \n  mutate(CLUSTER = \"0\") %>% \n  mutate(SP_CLUSTER = \"0\") %>%\n  relocate(geometry, .after = SP_CLUSTER) %>% \n  rename(\"pct_functional\" = \"hand\") %>% \n  rename(\"pct_nonfunctional\" = \"mechanized\") %>% \n  rename(\"pct_hand\" = \"greater_300_cap\") %>% \n  rename(\"pct_greater300\" = \"less_300_cap\") %>% \n  rename(\"pct_rural\" = \"rural\")\nzerowpl <- st_transform(zerowpl, crs = 26391)\n\n\nNow we will use rbind() of Base R to stack nigeria_spatialcluster and zerowpl together to create a data table of 9 clusters.\n\n\nShow code\nskater_map <- rbind(nigeria_spatialcluster, zerowpl)\n\n\nNow we can map the clusters created by SKATER method. Notice that cluster 0 is not a “true cluster” for analysis. It is added in for visualization only and we will not analyze its content.\n\n\nShow code\nskater_clust <- tm_shape(skater_map) + \n  tm_fill(\"SP_CLUSTER\",\n          title = \"SKATER Clusters\") +\n  tm_layout(main.title = \"SKATER Cluster Map\",\n            main.title.position = \"center\",\n            main.title.size = 1.4,\n            legend.height = 0.25,\n            legend.width = 0.3,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\nskater_clust"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#preparing-the-data-for-cluster-analysis",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#preparing-the-data-for-cluster-analysis",
    "title": "Take-home Exercise 2: Regionalisation of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "Preparing The Data for Cluster Analysis",
    "text": "Preparing The Data for Cluster Analysis\nTo conduct the hierarchy cluster analysis, it is important that we have the right format of data. As the cluster analysis works on the variables values only, we need to extract them from nga_wp_clean simple feature data set. After that, we will set the row names to be the name of the areas.\n\n\nShow code\nclust_var <- nga_wp_clean[,-c(3)] %>% \n  st_set_geometry(NULL)\n\n\nNext, we will assign the shapeName column to be the row name column.\n\n\nShow code\nrow.names(clust_var) <- clust_var$shapeName\nhead(clust_var)\n\n\n                    shapeName functional nonfunctional pct_functional\nAba North           Aba North          7             9       41.17647\nAba South           Aba South         29            35       40.84507\nAbaji                   Abaji         23            34       40.35088\nAbak                     Abak         23            25       47.91667\nAbakaliki           Abakaliki         82            42       35.19313\nAbeokuta North Abeokuta North         16            15       47.05882\n               pct_nonfunctional  pct_hand pct_greater300 pct_rural\nAba North               52.94118 11.764706       82.35294  0.000000\nAba South               49.29577  9.859155       87.32394  5.633803\nAbaji                   59.64912 40.350877       59.64912 84.210526\nAbak                    52.08333  8.333333       91.66667 83.333333\nAbakaliki               18.02575 43.776824        9.44206 87.553648\nAbeokuta North          44.11765 14.705882       76.47059 20.588235\n\n\nLastly, we will remove the shapeName column.\n\n\nShow code\nnigeria_clust <- clust_var[,c(2:8)]"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#hierarchy-cluster-analysis",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#hierarchy-cluster-analysis",
    "title": "Take-home Exercise 2: Regionalisation of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "Hierarchy Cluster Analysis",
    "text": "Hierarchy Cluster Analysis\n\nExtracting clustering variables\nTo conduct the hierarchy cluster analysis, it is important that we have the right format of data. As the cluster analysis works on the variables values only, we need to extract them from nga_wp_clean simple feature data set. After that, we will set the row names to be the name of the areas.\n\n\nShow code\nclust_var <- nga_wp[,-c(3)] %>% \n  st_set_geometry(NULL)\n\n\nNext, we will assign the shapeName column to be the row name column.\n\n\nShow code\nrow.names(clust_var) <- clust_var$shapeName\nhead(clust_var)\n\n\n                    shapeName functional nonfunctional pct_functional\nAba North           Aba North  0.9308511             9       41.17647\nAba South           Aba South  3.8563830            35       40.84507\nAbaji                   Abaji  3.0585106            34       40.35088\nAbak                     Abak  3.0585106            25       47.91667\nAbakaliki           Abakaliki 10.9042553            42       35.19313\nAbeokuta North Abeokuta North  2.1276596            15       47.05882\n               pct_nonfunctional  pct_hand pct_greater300 pct_rural\nAba North               52.94118 11.764706       82.35294  0.000000\nAba South               49.29577  9.859155       87.32394  5.633803\nAbaji                   59.64912 40.350877       59.64912 84.210526\nAbak                    52.08333  8.333333       91.66667 83.333333\nAbakaliki               18.02575 43.776824        9.44206 87.553648\nAbeokuta North          44.11765 14.705882       76.47059 20.588235\n\n\nLastly, we will remove the shapeName column.\n\n\nShow code\nnigeria_clust <- clust_var[,c(2:8)]\n\n\n\n\nComputing proximity matrix\nTo carry out this task, dist() of base R is used. There are many proximity matrix methods that the function offers. However, we will choose the default method which is “euclidean”.\n\n\nShow code\nproxmat <- dist(nigeria_clust, method = 'euclidean')\n\n\n\n\nComputing hierarchical clustering\nWe will use hclust() of Base R to do this task. Notice that hclust() uses the agglomeration method to compute the cluster. The functions supports eight clustering algorithms: ward.D, ward.D2, single, complete, average(UPGMA), mcquitty(WPGMA), median(WPGMC) and centroid(UPGMC).\nFirst, we need to select the most optimal clustering algorithm.\n\n\nShow code\nm <- c( \"average\", \"single\", \"complete\", \"ward\")\nnames(m) <- c( \"average\", \"single\", \"complete\", \"ward\")\n\nac <- function(x) {\n  agnes(nigeria_clust, method = x)$ac\n}\n\nmap_dbl(m, ac)\n\n\n  average    single  complete      ward \n0.8924681 0.8278239 0.9467931 0.9886924 \n\n\nWe can see that the ward method provides the strongest clustering structure. Therefore, we will use the ward method to compute the hierarchical clustering as in the code below.\n\n\nShow code\nhclust_ward <- hclust(proxmat, method = 'ward.D')\n\n\n\n\nDetermining the optimal number of clusters\nWe will use the gap statistic method with the help of clusGap() of the cluster package, combined with hcut() function from extrafacto package.\n\n\nShow code\nset.seed(12345)\ngap_stat <- clusGap(nigeria_clust, \n                    FUN = hcut, \n                    nstart = 25, \n                    K.max = 15, \n                    B = 50)\nprint(gap_stat, method = \"firstmax\")\n\n\nClustering Gap statistic [\"clusGap\"] from call:\nclusGap(x = nigeria_clust, FUNcluster = hcut, K.max = 15, B = 50, nstart = 25)\nB=50 simulated reference sets, k = 1..15; spaceH0=\"scaledPCA\"\n --> Number of clusters (method 'firstmax'): 15\n          logW    E.logW       gap      SE.sim\n [1,] 9.815179 10.422963 0.6077839 0.009610740\n [2,] 9.638166 10.297151 0.6589849 0.010574727\n [3,] 9.531530 10.207097 0.6755675 0.010630666\n [4,] 9.444975 10.137891 0.6929163 0.010404717\n [5,] 9.396917 10.105064 0.7081476 0.010156073\n [6,] 9.347167 10.076573 0.7294059 0.009007775\n [7,] 9.286980 10.051022 0.7640420 0.008166518\n [8,] 9.257270 10.027901 0.7706308 0.007931508\n [9,] 9.232442 10.006590 0.7741480 0.008129448\n[10,] 9.208196  9.986848 0.7786527 0.008151905\n[11,] 9.186749  9.968241 0.7814914 0.008044768\n[12,] 9.160007  9.950893 0.7908861 0.007947134\n[13,] 9.139783  9.934492 0.7947083 0.008080864\n[14,] 9.121686  9.919149 0.7974631 0.008219217\n[15,] 9.100932  9.904830 0.8038983 0.008005014\n\n\nLet’s visualize the plot for easier decision making!\n\n\nShow code\nfviz_gap_stat(gap_stat)\n\n\n\n\n\nWhile 14 is the optimal number of clusters, it is too much to support decision making based on that many clusters. We will choose 8 to be the number of clusters.\nNow we can map the 8 clusters with the data table.\n\n\nShow code\ngroups <- as.factor(cutree(hclust_ward, k = 8))\nnigeria_sf_cluster <- cbind(nga_wp, as.matrix(groups)) %>%\n  rename(`CLUSTER`=`as.matrix.groups.`)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#spatially-constrained-clustering-glustgeo-method",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#spatially-constrained-clustering-glustgeo-method",
    "title": "Take-home Exercise 2: Regionalisation of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "Spatially Constrained Clustering: GlustGeo Method",
    "text": "Spatially Constrained Clustering: GlustGeo Method\nClustGeo method is a Ward-like hierarchical clustering method. It fins the balance between the similarity of the variables and the contiguity of the observations. In R, ClustGeo is done using the functions of the ClustGeo package. In the code chunk below, we will use hclustgeo() to compute the dissimilarity matrix.\nThe balance is represented by a value of alpha. We need to find the right balance to increase the spatial contiguity without reducing the quality of the non-spatial clustering. To do that, we can use choicealpha().\nBefore we can performed spatially constrained hierarchical clustering, a spatial distance matrix will be derived by using st_distance() of sf package.\n\n\nShow code\ndist <- st_distance(nga_wp, nga_wp)\ndistmat <- as.dist(dist)\n\n\nWe will use choicealpha() to compute the value for mixing parameter alpha.\n\n\nShow code\ncr <- choicealpha(proxmat, distmat, range.alpha = seq(0, 1, 0.1), K=8, graph = TRUE)\n\n\n\n\n\n\n\n\nBased on the graph, alpha equal 0.3 is chosen.\n\n\nShow code\nclustG <- hclustgeo(proxmat, distmat, alpha = 0.3)\ngroups <- as.factor(cutree(clustG, k=8))\nnigeria_Gcluster <- cbind(nga_wp, as.matrix(groups)) %>%\n  rename(`GEOCLUSTER` = `as.matrix.groups.`)\n\n\nLike with SKATER, now we combine the data of zero-water-point areas to display on the map together with the ClustGeo clusters.\n\n\nShow code\nzewpgeo <- zerowpl[,-c(10)] %>% \n  rename(\"GEOCLUSTER\" = \"SP_CLUSTER\")\ngeo_map <- rbind(nigeria_Gcluster, zewpgeo)\n\n\nNow we can map the spatially-constraned ClustGeo clusters.\n\n\nShow code\ngeo_clust <- tm_shape(geo_map) + \n  tm_fill(\"GEOCLUSTER\",\n          title = \"ClustGeo Clusters\") +\n  tm_layout(main.title = \"ClustGeo Cluster Map\",\n            main.title.position = \"center\",\n            main.title.size = 1.4,\n            legend.height = 0.25,\n            legend.width = 0.3,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\ngeo_clust"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#comparing-two-clustering-methods",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#comparing-two-clustering-methods",
    "title": "Take-home Exercise 2: Regionalisation of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "Comparing two clustering methods",
    "text": "Comparing two clustering methods\n\n\nShow code\ntmap_arrange(skater_clust, geo_clust, asp = 1, ncol = 2)\n\n\n\n\n\nBy comparing the map visualization, we can see that SKATER produces a cleaner view of regionalization, with the LGAs packed neatly together. ClustGeo, on the other hand, also produces regions that relatively overlap with the regions produced by SKATER, but some areas are scattering far from the main clustered region, and the border of the clustered region is not clear.\nIn addition, Cluster 1, 4, 6 contain very small LGAs that lie far away from each other. This will hinder customized efforts to organize water supply improvement initiatives. We can see that ClustGeo is not the appropriate tool to aid policy makers.\nFor this reason, we will base our next analysis on the SKATER method."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#multivariate-visualization-of-skater-clusters",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#multivariate-visualization-of-skater-clusters",
    "title": "Take-home Exercise 2: Regionalisation of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "Multivariate visualization of SKATER clusters",
    "text": "Multivariate visualization of SKATER clusters\nTo compare the clusters, we will display their variable ranges in the form of boxplots. When put next to each other, this visualization method proves effective to compare the difference of the clusters. To do this task, we will use ggparcoord() from GGally package.\nFirst, we will load the GGally package.\n\n\nShow code\npacman::p_load(GGally)\n\n\nThe graphs are drawn with the code below.\n\n\nShow code\nggparcoord(data = nigeria_spatialcluster, \n           columns = c(3:9), \n           scale = \"globalminmax\",\n           alphaLines = 0.2,\n           boxplot = TRUE, \n           title = \"Plots of SKATER Cluster Variables\") +\n  facet_grid(rows = vars(SP_CLUSTER)) + \n  theme(axis.text.x = element_text(angle = 10))\n\n\n\n\n\n\n\nShow code\nnigeria_spatialcluster %>% \n  st_set_geometry(NULL) %>%\n  group_by(SP_CLUSTER) %>%\n  summarise(functional = mean(functional),\n            nonfunctional = mean(nonfunctional),\n            pfunc = mean(pct_functional),\n            pnfunc = mean(pct_nonfunctional),\n            phand = mean(pct_hand),\n            pg300 = mean(pct_greater300),\n            prural = mean(pct_rural))\n\n\n# A tibble: 8 × 8\n  SP_CLUSTER functional nonfunctional pfunc pnfunc phand pg300 prural\n  <fct>           <dbl>         <dbl> <dbl>  <dbl> <dbl> <dbl>  <dbl>\n1 1               10.7          73.0   37.7   40.0  61.1  16.7   90.6\n2 2                2.37         22.6   37.3   44.3  16.7  63.8   71.5\n3 3               21.1          46.4   75.5   24.4  86.4  13.2   83.5\n4 4                4.50         22.5   47.0   23.7  12.0  57.8   31.6\n5 5                9.99         85.3   42.1   46.9  55.2  33.0   78.0\n6 6                2.19          4.33  71.6   28.4  64.6  34.9   73.0\n7 7                8.78         52.6   51.4   41.3  57.5  34.9   70.8\n8 8                4.77          8.08  55.1   11.9  42.3  57.4   63.2\n\n\n\nCluster 1: is the region in the south east of Nigeria. It contains the highest percentage of rural water points and a second-highest number of non-functional water point count. Water point capacity is low and mostly manual with hand pump. The region also contains the lower outliers of rural water point percentage, suggesting the presence of cities.\nCluster 2: lies in the south of Nigeria. This region has more than 71.5% of rural water points, but the percentage of water points with above-median capacity is also high (63.8%). The values of water point count and water point percentage suggests that the total water point count of this region is relatively low. The percentage of non-functional water points here is the second-highest.\nCluster 3: spans from the north to the central of Nigeria. This region is characterized with the highest number of functional water points. The percentage of hand pump water point is also the highest among the clusters with the lowest average capacity. While the percentage of non-functional water points are the second-lowest, the water points in this region are not efficient due to manual process and low capacity.\nCluster 4: is in the south east of Nigeria and contains the largest city of the nation - Lagos. The urban nature of the region is reflected by its low percentage of rural water points, with the highest average percentage of above-median capacity water points. The water points in the region is also highly mechanized, with the lowest percentage of hand pump water points.\nCluster 5: lies in the central east of Nigeria. It has the highest average count of non-functional water points. The percentage of non-functional water points is also the highest among all clusters.\nCluster 6: is located in the far west of Nigeria. The number of water points is low. While the region has a high percentage of functional water points, it can because of the low water point count. This is another region of rural areas with manual and low capacity water points.\nCluster 7: is in the north west of Nigeria. This region has high value of non-functional water point count, and low value of functional water point count. The average percentage of functional and non-functional water points are roughly equal, suggesting some areas having low count of total water points. The majority of the water point in this region lies in the rural area. This area also contains the second-lowest percentage of water points with higher-than-median capacity.\nCluster 8: is in the north east of Nigeria. Based on the choropleth map of total water point count in the EDA step, we can see that this part of Nigeria has the lowest water point count, and some LGAs (excluded from the cluster) do not have any water point at all. This is reflected in the low functional and non-functional water point count, yet high functional water point percentage."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#conclusion-and-improvement",
    "href": "Take-home_Ex/Take-home_Ex2/Take-home_Ex2.html#conclusion-and-improvement",
    "title": "Take-home Exercise 2: Regionalisation of Multivariate Water Point Attributes with Non-spatially Constrained and Spatially Constrained Clustering Methods",
    "section": "Conclusion and Improvement",
    "text": "Conclusion and Improvement\nWith the spatially constrained clustering method, we can regionalize the LGAs in Nigeria based on the characteristic of water points in each region and how the LGAs are linked to each other. This method can be a useful tool to categorize and visualize regions for policy makers when it comes to improving the water supply in Nigeria.\nThis analysis can be improved even more. When looking at the water point count, we can’t help but questioning: why do some areas have less water points than others, and why some have more non-functional water points than others? Many factors can contribute to water point count and water point functionality, like population distribution, the economic health of the region, its geography and natural water supply, even the climate of the region. That information is not included in our analysis, but it can help us in producing more meaningful regionalization."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04.html",
    "href": "Hands-on_Ex/Hands-on_Ex04.html",
    "title": "Hands-on Exercise 4: Calibrating Hedonic Pricing Model for Private Highrise Property with GWR Method",
    "section": "",
    "text": "Geographically weighted regression (GWR) is a spatial statistical technique that takes non-stationary variables into consideration (e.g., climate; demographic factors; physical environment characteristics) and models the local relationships between these independent variables and an outcome of interest (also known as dependent variable)."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04.html#data",
    "href": "Hands-on_Ex/Hands-on_Ex04.html#data",
    "title": "Hands-on Exercise 4: Calibrating Hedonic Pricing Model for Private Highrise Property with GWR Method",
    "section": "Data",
    "text": "Data\nIn this example, two data sets are going to be used.\n\nURA Master Plan subzone boundary in shapefile format (i.e. MP14_SUBZONE_WEB_PL)\ncondo_resale_2015 in csv format (i.e. condo_resale_2015.csv)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04.html#getting-started",
    "href": "Hands-on_Ex/Hands-on_Ex04.html#getting-started",
    "title": "Hands-on Exercise 4: Calibrating Hedonic Pricing Model for Private Highrise Property with GWR Method",
    "section": "Getting Started",
    "text": "Getting Started\nFirst, we will load the necessary packages. They are:\n\nolsrr: R package for building OLS and performing diagnostics tests\nGWmodel: R package for calibrating geographical weighted family of models\ncorrplot: R package for multivariate data visualisation and analysis\nsf, spdep: to handle spatial data\ntmap: to make choropleth map\nggpubr: to arrange the maps\ntidyverse, especially readr, ggplot2 and dplyr: to handle the aspatial data\ngtsummary: to create publication-ready analytical and summary tables\n\n\npacman::p_load(olsrr, corrplot, ggpubr, sf, spdep, GWmodel, tmap, tidyverse, gtsummary)\n\n\nGWmodel provides forms of localized spatial statistical methods, ie GW summary statistics, GW principal components analysis, GW discriminant analysis and various forms of GW regression, some are basic and some are robust. Commonly, outputs or parameters of the GWmodel are mapped to provide a useful exploratory tool, which can often precede (and direct) a more traditional or sophisticated statistical analysis."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04.html#geospatial-data-wrangling",
    "href": "Hands-on_Ex/Hands-on_Ex04.html#geospatial-data-wrangling",
    "title": "Hands-on Exercise 4: Calibrating Hedonic Pricing Model for Private Highrise Property with GWR Method",
    "section": "Geospatial Data Wrangling",
    "text": "Geospatial Data Wrangling\n\nImporting geospatial data\nThe shapfile MP14_SUBZONE_WEB-PL is in ESRI shapefile format. It contains the URA Master Plan 2014's planning subzone boundaries. We will use st_read() of sf package to read the file into an object called mpsz.\n\nmpsz <- st_read(dsn = \"data4/geospatial\", layer = \"MP14_SUBZONE_WEB_PL\")\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/Hands-on_Ex/data4/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\n\n\nIt is also important to note that mpsz simple feature object does not have EPSG information.\n\n\n\nUpdating CRS information\nWe use st_transform() to update mpsz with the correct EPSG code that correspond with CRS SVY21.\n\nmpsz_svy21 <- st_transform(mpsz, 3414)\n\nLet’s review mpsz_svy21 using st_crs().\n\nst_crs(mpsz_svy21)\n\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n\n\nNext, we will reveal the extent of mpsz_svy21 by using st_bbox() of sf package.\n\nst_bbox(mpsz_svy21)\n\n     xmin      ymin      xmax      ymax \n 2667.538 15748.721 56396.440 50256.334"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04.html#aspatial-data-wrangling",
    "href": "Hands-on_Ex/Hands-on_Ex04.html#aspatial-data-wrangling",
    "title": "Hands-on Exercise 4: Calibrating Hedonic Pricing Model for Private Highrise Property with GWR Method",
    "section": "Aspatial Data Wrangling",
    "text": "Aspatial Data Wrangling\n\nImporting the aspatial data\nSince the aspatial data is in the Condo_resale_2015.csv file, we will use read_csv() of readr package to load the data into an object called condo_resale.\n\ncondo_resale <- read_csv(\"data4/aspatial/Condo_resale_2015.csv\")\n\nWe will use glimpse() to inspect condo_resale.\n\nglimpse(condo_resale)\n\nRows: 1,436\nColumns: 23\n$ LATITUDE             <dbl> 1.287145, 1.328698, 1.313727, 1.308563, 1.321437,…\n$ LONGITUDE            <dbl> 103.7802, 103.8123, 103.7971, 103.8247, 103.9505,…\n$ POSTCODE             <dbl> 118635, 288420, 267833, 258380, 467169, 466472, 3…\n$ SELLING_PRICE        <dbl> 3000000, 3880000, 3325000, 4250000, 1400000, 1320…\n$ AREA_SQM             <dbl> 309, 290, 248, 127, 145, 139, 218, 141, 165, 168,…\n$ AGE                  <dbl> 30, 32, 33, 7, 28, 22, 24, 24, 27, 31, 17, 22, 6,…\n$ PROX_CBD             <dbl> 7.941259, 6.609797, 6.898000, 4.038861, 11.783402…\n$ PROX_CHILDCARE       <dbl> 0.16597932, 0.28027246, 0.42922669, 0.39473543, 0…\n$ PROX_ELDERLYCARE     <dbl> 2.5198118, 1.9333338, 0.5021395, 1.9910316, 1.121…\n$ PROX_URA_GROWTH_AREA <dbl> 6.618741, 7.505109, 6.463887, 4.906512, 6.410632,…\n$ PROX_HAWKER_MARKET   <dbl> 1.76542207, 0.54507614, 0.37789301, 1.68259969, 0…\n$ PROX_KINDERGARTEN    <dbl> 0.05835552, 0.61592412, 0.14120309, 0.38200076, 0…\n$ PROX_MRT             <dbl> 0.5607188, 0.6584461, 0.3053433, 0.6910183, 0.528…\n$ PROX_PARK            <dbl> 1.1710446, 0.1992269, 0.2779886, 0.9832843, 0.116…\n$ PROX_PRIMARY_SCH     <dbl> 1.6340256, 0.9747834, 1.4715016, 1.4546324, 0.709…\n$ PROX_TOP_PRIMARY_SCH <dbl> 3.3273195, 0.9747834, 1.4715016, 2.3006394, 0.709…\n$ PROX_SHOPPING_MALL   <dbl> 2.2102717, 2.9374279, 1.2256850, 0.3525671, 1.307…\n$ PROX_SUPERMARKET     <dbl> 0.9103958, 0.5900617, 0.4135583, 0.4162219, 0.581…\n$ PROX_BUS_STOP        <dbl> 0.10336166, 0.28673408, 0.28504777, 0.29872340, 0…\n$ NO_Of_UNITS          <dbl> 18, 20, 27, 30, 30, 31, 32, 32, 32, 32, 34, 34, 3…\n$ FAMILY_FRIENDLY      <dbl> 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0…\n$ FREEHOLD             <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1…\n$ LEASEHOLD_99YR       <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n\n\nWe can use head() to see the data of a specific column.\n\nhead(condo_resale$LATITUDE)\n\n[1] 1.287145 1.328698 1.313727 1.308563 1.321437 1.314198\n\n\n\nhead(condo_resale$LONGITUDE)\n\n[1] 103.7802 103.8123 103.7971 103.8247 103.9505 103.9386\n\n\nNext, summary() of base R is used to display the summary statistics of cond_resale tibble data frame.\n\nsummary(condo_resale)\n\n    LATITUDE       LONGITUDE        POSTCODE      SELLING_PRICE     \n Min.   :1.240   Min.   :103.7   Min.   : 18965   Min.   :  540000  \n 1st Qu.:1.309   1st Qu.:103.8   1st Qu.:259849   1st Qu.: 1100000  \n Median :1.328   Median :103.8   Median :469298   Median : 1383222  \n Mean   :1.334   Mean   :103.8   Mean   :440439   Mean   : 1751211  \n 3rd Qu.:1.357   3rd Qu.:103.9   3rd Qu.:589486   3rd Qu.: 1950000  \n Max.   :1.454   Max.   :104.0   Max.   :828833   Max.   :18000000  \n    AREA_SQM          AGE           PROX_CBD       PROX_CHILDCARE    \n Min.   : 34.0   Min.   : 0.00   Min.   : 0.3869   Min.   :0.004927  \n 1st Qu.:103.0   1st Qu.: 5.00   1st Qu.: 5.5574   1st Qu.:0.174481  \n Median :121.0   Median :11.00   Median : 9.3567   Median :0.258135  \n Mean   :136.5   Mean   :12.14   Mean   : 9.3254   Mean   :0.326313  \n 3rd Qu.:156.0   3rd Qu.:18.00   3rd Qu.:12.6661   3rd Qu.:0.368293  \n Max.   :619.0   Max.   :37.00   Max.   :19.1804   Max.   :3.465726  \n PROX_ELDERLYCARE  PROX_URA_GROWTH_AREA PROX_HAWKER_MARKET PROX_KINDERGARTEN \n Min.   :0.05451   Min.   :0.2145       Min.   :0.05182    Min.   :0.004927  \n 1st Qu.:0.61254   1st Qu.:3.1643       1st Qu.:0.55245    1st Qu.:0.276345  \n Median :0.94179   Median :4.6186       Median :0.90842    Median :0.413385  \n Mean   :1.05351   Mean   :4.5981       Mean   :1.27987    Mean   :0.458903  \n 3rd Qu.:1.35122   3rd Qu.:5.7550       3rd Qu.:1.68578    3rd Qu.:0.578474  \n Max.   :3.94916   Max.   :9.1554       Max.   :5.37435    Max.   :2.229045  \n    PROX_MRT         PROX_PARK       PROX_PRIMARY_SCH  PROX_TOP_PRIMARY_SCH\n Min.   :0.05278   Min.   :0.02906   Min.   :0.07711   Min.   :0.07711     \n 1st Qu.:0.34646   1st Qu.:0.26211   1st Qu.:0.44024   1st Qu.:1.34451     \n Median :0.57430   Median :0.39926   Median :0.63505   Median :1.88213     \n Mean   :0.67316   Mean   :0.49802   Mean   :0.75471   Mean   :2.27347     \n 3rd Qu.:0.84844   3rd Qu.:0.65592   3rd Qu.:0.95104   3rd Qu.:2.90954     \n Max.   :3.48037   Max.   :2.16105   Max.   :3.92899   Max.   :6.74819     \n PROX_SHOPPING_MALL PROX_SUPERMARKET PROX_BUS_STOP       NO_Of_UNITS    \n Min.   :0.0000     Min.   :0.0000   Min.   :0.001595   Min.   :  18.0  \n 1st Qu.:0.5258     1st Qu.:0.3695   1st Qu.:0.098356   1st Qu.: 188.8  \n Median :0.9357     Median :0.5687   Median :0.151710   Median : 360.0  \n Mean   :1.0455     Mean   :0.6141   Mean   :0.193974   Mean   : 409.2  \n 3rd Qu.:1.3994     3rd Qu.:0.7862   3rd Qu.:0.220466   3rd Qu.: 590.0  \n Max.   :3.4774     Max.   :2.2441   Max.   :2.476639   Max.   :1703.0  \n FAMILY_FRIENDLY     FREEHOLD      LEASEHOLD_99YR  \n Min.   :0.0000   Min.   :0.0000   Min.   :0.0000  \n 1st Qu.:0.0000   1st Qu.:0.0000   1st Qu.:0.0000  \n Median :0.0000   Median :0.0000   Median :0.0000  \n Mean   :0.4868   Mean   :0.4227   Mean   :0.4882  \n 3rd Qu.:1.0000   3rd Qu.:1.0000   3rd Qu.:1.0000  \n Max.   :1.0000   Max.   :1.0000   Max.   :1.0000  \n\n\n\n\nConverting aspatial data frame into a sf object\nCurrently, the condo_resale tibble data frame is aspatial. We will convert it to a sf object. The code chunk below converts condo_resale data frame into a simple feature data frame by using st_as_sf() of sf packages. To match with the EPSG value of mpsz_svy21, we use st_transform() to convert the coordinates from WGS84 to SVY21.\n\ncondo_resale.sf <- st_as_sf(condo_resale,\n                            coords = c(\"LONGITUDE\", \"LATITUDE\"),\n                            crs=4326) %>%\n  st_transform(crs=3414)\n\nLet’s inspect condo_resale.sf.\n\nhead(condo_resale.sf)\n\nSimple feature collection with 6 features and 21 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 22085.12 ymin: 29951.54 xmax: 41042.56 ymax: 34546.2\nProjected CRS: SVY21 / Singapore TM\n# A tibble: 6 × 22\n  POSTCODE SELLI…¹ AREA_…²   AGE PROX_…³ PROX_…⁴ PROX_…⁵ PROX_…⁶ PROX_…⁷ PROX_…⁸\n     <dbl>   <dbl>   <dbl> <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>\n1   118635 3000000     309    30    7.94   0.166   2.52     6.62   1.77   0.0584\n2   288420 3880000     290    32    6.61   0.280   1.93     7.51   0.545  0.616 \n3   267833 3325000     248    33    6.90   0.429   0.502    6.46   0.378  0.141 \n4   258380 4250000     127     7    4.04   0.395   1.99     4.91   1.68   0.382 \n5   467169 1400000     145    28   11.8    0.119   1.12     6.41   0.565  0.461 \n6   466472 1320000     139    22   10.3    0.125   0.789    5.09   0.781  0.0994\n# … with 12 more variables: PROX_MRT <dbl>, PROX_PARK <dbl>,\n#   PROX_PRIMARY_SCH <dbl>, PROX_TOP_PRIMARY_SCH <dbl>,\n#   PROX_SHOPPING_MALL <dbl>, PROX_SUPERMARKET <dbl>, PROX_BUS_STOP <dbl>,\n#   NO_Of_UNITS <dbl>, FAMILY_FRIENDLY <dbl>, FREEHOLD <dbl>,\n#   LEASEHOLD_99YR <dbl>, geometry <POINT [m]>, and abbreviated variable names\n#   ¹​SELLING_PRICE, ²​AREA_SQM, ³​PROX_CBD, ⁴​PROX_CHILDCARE, ⁵​PROX_ELDERLYCARE,\n#   ⁶​PROX_URA_GROWTH_AREA, ⁷​PROX_HAWKER_MARKET, ⁸​PROX_KINDERGARTEN\n\n\nThe data is point feature data frame."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04.html#exploratory-data-analysis-eda",
    "href": "Hands-on_Ex/Hands-on_Ex04.html#exploratory-data-analysis-eda",
    "title": "Hands-on Exercise 4: Calibrating Hedonic Pricing Model for Private Highrise Property with GWR Method",
    "section": "Exploratory Data Analysis (EDA)",
    "text": "Exploratory Data Analysis (EDA)\n\nEDA using statistical graphics\nWe can plot the distribution of SELLING_PRICE by using appropriate Exploratory Data Analysis (EDA) as shown in the code chunk below.\n\nggplot(data=condo_resale.sf, aes(x=`SELLING_PRICE`)) +\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\n\n\n\n\nThe figure above reveals a right skewed distribution. This means that more condominium units were transacted at relative lower prices.\nStatistically, the skewed dsitribution can be normalised by using log transformation. The code chunk below is used to derive a new variable called LOG_SELLING_PRICE by using a log transformation on the variable SELLING_PRICE. It is performed using mutate() of dplyr package.\n\ncondo_resale.sf <- condo_resale.sf %>%\n  mutate(`LOG_SELLING_PRICE` = log(SELLING_PRICE))\n\nLet’s see the distribution of LOG_SELLING_PRICE.\n\nggplot(data=condo_resale.sf, aes(x=`LOG_SELLING_PRICE`)) +\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\n\n\n\n\nThe distribution is relatively less skewed now.\n\n\nMultiple histogram plots distribution of variables\nIf we want to combine multiple plots in the same figure, we can use ggarrange() from ggpubr package.\n\nAREA_SQM <- ggplot(data=condo_resale.sf, aes(x= `AREA_SQM`)) + \n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\n\nAGE <- ggplot(data=condo_resale.sf, aes(x= `AGE`)) +\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\n\nPROX_CBD <- ggplot(data=condo_resale.sf, aes(x= `PROX_CBD`)) +\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\n\nPROX_CHILDCARE <- ggplot(data=condo_resale.sf, aes(x= `PROX_CHILDCARE`)) + \n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\n\nPROX_ELDERLYCARE <- ggplot(data=condo_resale.sf, aes(x= `PROX_ELDERLYCARE`)) +\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\n\nPROX_URA_GROWTH_AREA <- ggplot(data=condo_resale.sf, \n                               aes(x= `PROX_URA_GROWTH_AREA`)) +\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\n\nPROX_HAWKER_MARKET <- ggplot(data=condo_resale.sf, aes(x= `PROX_HAWKER_MARKET`)) +\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\n\nPROX_KINDERGARTEN <- ggplot(data=condo_resale.sf, aes(x= `PROX_KINDERGARTEN`)) +\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\n\nPROX_MRT <- ggplot(data=condo_resale.sf, aes(x= `PROX_MRT`)) +\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\n\nPROX_PARK <- ggplot(data=condo_resale.sf, aes(x= `PROX_PARK`)) +\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\n\nPROX_PRIMARY_SCH <- ggplot(data=condo_resale.sf, aes(x= `PROX_PRIMARY_SCH`)) +\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\n\nPROX_TOP_PRIMARY_SCH <- ggplot(data=condo_resale.sf, \n                               aes(x= `PROX_TOP_PRIMARY_SCH`)) +\n  geom_histogram(bins=20, color=\"black\", fill=\"light blue\")\n\nggarrange(AREA_SQM, AGE, PROX_CBD, PROX_CHILDCARE, PROX_ELDERLYCARE, \n          PROX_URA_GROWTH_AREA, PROX_HAWKER_MARKET, PROX_KINDERGARTEN, PROX_MRT,\n          PROX_PARK, PROX_PRIMARY_SCH, PROX_TOP_PRIMARY_SCH,  \n          ncol = 3, nrow = 4)\n\n\n\n\n\n\n\n\n\n\nDrawing Statistical Point Map\nLastly, we want to reveal the geospatial distribution condominium resale prices in Singapore. The map will be prepared by using tmap package.\nFirst, we will turn on the interactive mode of tmap by using the code chunk below.\n\ntmap_mode(\"view\")\n\nNow we can create an interactive point symbol map.\n\ntm_shape(mpsz_svy21)+\n  tm_polygons() +\n  tm_shape(condo_resale.sf) +  \n  tm_dots(col = \"SELLING_PRICE\",\n          alpha = 0.6,\n          style=\"quantile\") +\n  tm_view(set.zoom.limits = c(11,14)) +\n  tmap_options(check.and.fix = TRUE)\n\n\n\n\n\n\nNotice that tm_dots() is used instead of tm_bubbles().\nset.zoom.limits argument of tm_view() sets the minimum and maximum zoom level to 11 and 14 respectively.\nBefore moving on to the next section, the code below will be used to turn R display into plot mode.\n\ntmap_mode(\"plot\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04.html#hedonic-pricing-modelling-in-r",
    "href": "Hands-on_Ex/Hands-on_Ex04.html#hedonic-pricing-modelling-in-r",
    "title": "Hands-on Exercise 4: Calibrating Hedonic Pricing Model for Private Highrise Property with GWR Method",
    "section": "Hedonic Pricing Modelling in R",
    "text": "Hedonic Pricing Modelling in R\n\nSimple Linear Regression Method\nFirst, we will build a simple linear regression model by using SELLING_PRICE as the dependent variable and AREA_SQM as the independent variable.\n\ncondo.slr <- lm(formula=SELLING_PRICE ~ AREA_SQM, data = condo_resale.sf)\n\nlm() returns an object of class \"lm\" or for multiple responses of class c(\"mlm\", \"lm\").\nThe functions summary() and anova() can be used to obtain and print a summary and analysis of variance table of the results. The generic accessor functions coefficients, effects, fitted.values and residuals extract various useful features of the value returned by lm.\n\nsummary(condo.slr)\n\n\nCall:\nlm(formula = SELLING_PRICE ~ AREA_SQM, data = condo_resale.sf)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-3695815  -391764   -87517   258900 13503875 \n\nCoefficients:\n             Estimate Std. Error t value Pr(>|t|)    \n(Intercept) -258121.1    63517.2  -4.064 5.09e-05 ***\nAREA_SQM      14719.0      428.1  34.381  < 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 942700 on 1434 degrees of freedom\nMultiple R-squared:  0.4518,    Adjusted R-squared:  0.4515 \nF-statistic:  1182 on 1 and 1434 DF,  p-value: < 2.2e-16\n\n\nThe output report reveals that the SELLING_PRICE can be explained by using the formula:\ny = -258121.1 + 14719x\nThe R-squared of 0.4518 reveals that the simple regression model built is able to explain about 45% of the resale prices.\nSince p-value is much smaller than 0.0001, we will reject the null hypothesis that mean is a good estimator of SELLING_PRICE. This will allow us to infer that simple linear regression model above is a good estimator of SELLING_PRICE.\nThe Coefficients: section of the report reveals that the p-values of both the estimates of the Intercept and ARA_SQM are smaller than 0.001. In view of this, the null hypothesis of the B0 and B1 are equal to 0 will be rejected. As a results, we will be able to infer that the B0 and B1 are good parameter estimates.\nNow we can visualize the best fit curve. Notice that lm is used as a method.\n\nggplot(data=condo_resale.sf,  \n       aes(x=`AREA_SQM`, y=`SELLING_PRICE`)) +\n  geom_point() +\n  geom_smooth(method = lm)\n\n\n\n\n\n\nMultiple Linear Regression Method\n\nVisualising the relationships of the independent variables\nLinear regression models are sensitive to correlated variables, also known as multicollinearity. Therefore, we need to example multivariate correlation between the variables.\nSimilar to previous exercises, we can use corrplot() of the corrplot package to explore the relationship between the variables.\n\ncorrplot(cor(condo_resale[, 5:23]), diag = FALSE, order = \"AOE\",\n         tl.pos = \"td\", tl.cex = 0.5, method = \"number\", type = \"upper\")\n\n\n\n\n\n\n\n\nMatrix reorder is very important for mining the hiden structure and patter in the matrix. There are four methods in corrplot (parameter order), named \"AOE\", \"FPC\", \"hclust\", \"alphabet\". In the code chunk above, AOE order is used. It orders the variables by using the angular order of the eigenvectors method suggested by Michael Friendly.\nFrom the analysis, we see that Freehold is highly correlated to LEASE_99YEAR. We should remove one of them, the the variable to be removed is LEASE_99YEAR.\n\n\n\nBuilding a hedonic pricing model using multiple linear regression method\nWe will build the linear regression model using lm().\n\ncondo.mlr <- lm(formula = SELLING_PRICE ~ AREA_SQM + AGE    + \n                  PROX_CBD + PROX_CHILDCARE + PROX_ELDERLYCARE +\n                  PROX_URA_GROWTH_AREA + PROX_HAWKER_MARKET + PROX_KINDERGARTEN + \n                  PROX_MRT  + PROX_PARK + PROX_PRIMARY_SCH + \n                  PROX_TOP_PRIMARY_SCH + PROX_SHOPPING_MALL + PROX_SUPERMARKET + \n                  PROX_BUS_STOP + NO_Of_UNITS + FAMILY_FRIENDLY + FREEHOLD, \n                data=condo_resale.sf)\nsummary(condo.mlr)\n\n\nCall:\nlm(formula = SELLING_PRICE ~ AREA_SQM + AGE + PROX_CBD + PROX_CHILDCARE + \n    PROX_ELDERLYCARE + PROX_URA_GROWTH_AREA + PROX_HAWKER_MARKET + \n    PROX_KINDERGARTEN + PROX_MRT + PROX_PARK + PROX_PRIMARY_SCH + \n    PROX_TOP_PRIMARY_SCH + PROX_SHOPPING_MALL + PROX_SUPERMARKET + \n    PROX_BUS_STOP + NO_Of_UNITS + FAMILY_FRIENDLY + FREEHOLD, \n    data = condo_resale.sf)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-3475964  -293923   -23069   241043 12260381 \n\nCoefficients:\n                       Estimate Std. Error t value Pr(>|t|)    \n(Intercept)           481728.40  121441.01   3.967 7.65e-05 ***\nAREA_SQM               12708.32     369.59  34.385  < 2e-16 ***\nAGE                   -24440.82    2763.16  -8.845  < 2e-16 ***\nPROX_CBD              -78669.78    6768.97 -11.622  < 2e-16 ***\nPROX_CHILDCARE       -351617.91  109467.25  -3.212  0.00135 ** \nPROX_ELDERLYCARE      171029.42   42110.51   4.061 5.14e-05 ***\nPROX_URA_GROWTH_AREA   38474.53   12523.57   3.072  0.00217 ** \nPROX_HAWKER_MARKET     23746.10   29299.76   0.810  0.41782    \nPROX_KINDERGARTEN     147468.99   82668.87   1.784  0.07466 .  \nPROX_MRT             -314599.68   57947.44  -5.429 6.66e-08 ***\nPROX_PARK             563280.50   66551.68   8.464  < 2e-16 ***\nPROX_PRIMARY_SCH      180186.08   65237.95   2.762  0.00582 ** \nPROX_TOP_PRIMARY_SCH    2280.04   20410.43   0.112  0.91107    \nPROX_SHOPPING_MALL   -206604.06   42840.60  -4.823 1.57e-06 ***\nPROX_SUPERMARKET      -44991.80   77082.64  -0.584  0.55953    \nPROX_BUS_STOP         683121.35  138353.28   4.938 8.85e-07 ***\nNO_Of_UNITS             -231.18      89.03  -2.597  0.00951 ** \nFAMILY_FRIENDLY       140340.77   47020.55   2.985  0.00289 ** \nFREEHOLD              359913.01   49220.22   7.312 4.38e-13 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 755800 on 1417 degrees of freedom\nMultiple R-squared:  0.6518,    Adjusted R-squared:  0.6474 \nF-statistic: 147.4 on 18 and 1417 DF,  p-value: < 2.2e-16\n\n\n\n\nPreparing Publication Quality Table: olsrr method\nWith reference to the report above, it is clear that not all the independent variables are statistically significant. We will revised the model by removing those variables which are not statistically significant.\n\ncondo.mlr1 <- lm(formula = SELLING_PRICE ~ AREA_SQM + AGE + \n                   PROX_CBD + PROX_CHILDCARE + PROX_ELDERLYCARE +\n                   PROX_URA_GROWTH_AREA + PROX_MRT  + PROX_PARK + \n                   PROX_PRIMARY_SCH + PROX_SHOPPING_MALL    + PROX_BUS_STOP + \n                   NO_Of_UNITS + FAMILY_FRIENDLY + FREEHOLD,\n                 data=condo_resale.sf)\nols_regress(condo.mlr1)\n\n                             Model Summary                               \n------------------------------------------------------------------------\nR                       0.807       RMSE                     755957.289 \nR-Squared               0.651       Coef. Var                    43.168 \nAdj. R-Squared          0.647       MSE                571471422208.591 \nPred R-Squared          0.638       MAE                      414819.628 \n------------------------------------------------------------------------\n RMSE: Root Mean Square Error \n MSE: Mean Square Error \n MAE: Mean Absolute Error \n\n                                     ANOVA                                       \n--------------------------------------------------------------------------------\n                    Sum of                                                      \n                   Squares          DF         Mean Square       F         Sig. \n--------------------------------------------------------------------------------\nRegression    1.512586e+15          14        1.080418e+14    189.059    0.0000 \nResidual      8.120609e+14        1421    571471422208.591                      \nTotal         2.324647e+15        1435                                          \n--------------------------------------------------------------------------------\n\n                                               Parameter Estimates                                                \n-----------------------------------------------------------------------------------------------------------------\n               model           Beta    Std. Error    Std. Beta       t        Sig           lower          upper \n-----------------------------------------------------------------------------------------------------------------\n         (Intercept)     527633.222    108183.223                   4.877    0.000     315417.244     739849.200 \n            AREA_SQM      12777.523       367.479        0.584     34.771    0.000      12056.663      13498.382 \n                 AGE     -24687.739      2754.845       -0.167     -8.962    0.000     -30091.739     -19283.740 \n            PROX_CBD     -77131.323      5763.125       -0.263    -13.384    0.000     -88436.469     -65826.176 \n      PROX_CHILDCARE    -318472.751    107959.512       -0.084     -2.950    0.003    -530249.889    -106695.613 \n    PROX_ELDERLYCARE     185575.623     39901.864        0.090      4.651    0.000     107302.737     263848.510 \nPROX_URA_GROWTH_AREA      39163.254     11754.829        0.060      3.332    0.001      16104.571      62221.936 \n            PROX_MRT    -294745.107     56916.367       -0.112     -5.179    0.000    -406394.234    -183095.980 \n           PROX_PARK     570504.807     65507.029        0.150      8.709    0.000     442003.938     699005.677 \n    PROX_PRIMARY_SCH     159856.136     60234.599        0.062      2.654    0.008      41697.849     278014.424 \n  PROX_SHOPPING_MALL    -220947.251     36561.832       -0.115     -6.043    0.000    -292668.213    -149226.288 \n       PROX_BUS_STOP     682482.221    134513.243        0.134      5.074    0.000     418616.359     946348.082 \n         NO_Of_UNITS       -245.480        87.947       -0.053     -2.791    0.005       -418.000        -72.961 \n     FAMILY_FRIENDLY     146307.576     46893.021        0.057      3.120    0.002      54320.593     238294.560 \n            FREEHOLD     350599.812     48506.485        0.136      7.228    0.000     255447.802     445751.821 \n-----------------------------------------------------------------------------------------------------------------\n\n\n\n\nPreparing Publication Quality Table: gtsummary method\nThe gtsummary package provides an elegant and flexible way to create publication-ready summary tables in R. We will use tbl_regression() from that package to create a well formatted regression report.\n\ntbl_regression(condo.mlr1, intercept = TRUE)\n\n\n\n\n\n  \n  \n    \n      Characteristic\n      Beta\n      95% CI1\n      p-value\n    \n  \n  \n    (Intercept)\n527,633\n315,417, 739,849\n<0.001\n    AREA_SQM\n12,778\n12,057, 13,498\n<0.001\n    AGE\n-24,688\n-30,092, -19,284\n<0.001\n    PROX_CBD\n-77,131\n-88,436, -65,826\n<0.001\n    PROX_CHILDCARE\n-318,473\n-530,250, -106,696\n0.003\n    PROX_ELDERLYCARE\n185,576\n107,303, 263,849\n<0.001\n    PROX_URA_GROWTH_AREA\n39,163\n16,105, 62,222\n<0.001\n    PROX_MRT\n-294,745\n-406,394, -183,096\n<0.001\n    PROX_PARK\n570,505\n442,004, 699,006\n<0.001\n    PROX_PRIMARY_SCH\n159,856\n41,698, 278,014\n0.008\n    PROX_SHOPPING_MALL\n-220,947\n-292,668, -149,226\n<0.001\n    PROX_BUS_STOP\n682,482\n418,616, 946,348\n<0.001\n    NO_Of_UNITS\n-245\n-418, -73\n0.005\n    FAMILY_FRIENDLY\n146,308\n54,321, 238,295\n0.002\n    FREEHOLD\n350,600\n255,448, 445,752\n<0.001\n  \n  \n  \n    \n      1 CI = Confidence Interval\n    \n  \n\n\n\n\nWe can also use the code below to add the model statistics to the report.\n\ntbl_regression(condo.mlr1, \n               intercept = TRUE) %>% \n  add_glance_source_note(\n    label = list(sigma ~ \"\\U03C3\"),\n    include = c(r.squared, adj.r.squared, \n                AIC, statistic,\n                p.value, sigma))\n\n\n\n\n\n  \n  \n    \n      Characteristic\n      Beta\n      95% CI1\n      p-value\n    \n  \n  \n    (Intercept)\n527,633\n315,417, 739,849\n<0.001\n    AREA_SQM\n12,778\n12,057, 13,498\n<0.001\n    AGE\n-24,688\n-30,092, -19,284\n<0.001\n    PROX_CBD\n-77,131\n-88,436, -65,826\n<0.001\n    PROX_CHILDCARE\n-318,473\n-530,250, -106,696\n0.003\n    PROX_ELDERLYCARE\n185,576\n107,303, 263,849\n<0.001\n    PROX_URA_GROWTH_AREA\n39,163\n16,105, 62,222\n<0.001\n    PROX_MRT\n-294,745\n-406,394, -183,096\n<0.001\n    PROX_PARK\n570,505\n442,004, 699,006\n<0.001\n    PROX_PRIMARY_SCH\n159,856\n41,698, 278,014\n0.008\n    PROX_SHOPPING_MALL\n-220,947\n-292,668, -149,226\n<0.001\n    PROX_BUS_STOP\n682,482\n418,616, 946,348\n<0.001\n    NO_Of_UNITS\n-245\n-418, -73\n0.005\n    FAMILY_FRIENDLY\n146,308\n54,321, 238,295\n0.002\n    FREEHOLD\n350,600\n255,448, 445,752\n<0.001\n  \n  \n    \n      R² = 0.651; Adjusted R² = 0.647; AIC = 42,967; Statistic = 189; p-value = <0.001; σ = 755,957\n    \n  \n  \n    \n      1 CI = Confidence Interval\n    \n  \n\n\n\n\n\nChecking for multicolinearity\nIn the code chunk below, the ols_vif_tol() of olsrr package is used to test if there are sign of multicollinearity.\n\nols_vif_tol(condo.mlr1)\n\n              Variables Tolerance      VIF\n1              AREA_SQM 0.8728554 1.145665\n2                   AGE 0.7071275 1.414172\n3              PROX_CBD 0.6356147 1.573280\n4        PROX_CHILDCARE 0.3066019 3.261559\n5      PROX_ELDERLYCARE 0.6598479 1.515501\n6  PROX_URA_GROWTH_AREA 0.7510311 1.331503\n7              PROX_MRT 0.5236090 1.909822\n8             PROX_PARK 0.8279261 1.207837\n9      PROX_PRIMARY_SCH 0.4524628 2.210126\n10   PROX_SHOPPING_MALL 0.6738795 1.483945\n11        PROX_BUS_STOP 0.3514118 2.845664\n12          NO_Of_UNITS 0.6901036 1.449058\n13      FAMILY_FRIENDLY 0.7244157 1.380423\n14             FREEHOLD 0.6931163 1.442759\n\n\nSince the VIF of the independent variables are less than 10. We can safely conclude that there are no sign of multicollinearity among the independent variables.\n\n\nTest for Non-Linearity\nIn multiple linear regression, it is important for us to test the assumption that linearity and additivity of the relationship between dependent and independent variables. We will use ols_plot_resid_fit() to perform linearity assumption test.\n\nols_plot_resid_fit(condo.mlr1)\n\n\n\n\nThe figure above reveals that most of the data poitns are scattered around the 0 line, hence we can safely conclude that the relationships between the dependent variable and independent variables are linear.\n\n\nTest for Normality Assumption\n\nols_plot_resid_hist(condo.mlr1)\n\n\n\n\nThe figure reveals that the residual of the multiple linear regression model (i.e. condo.mlr1) is resemble normal distribution.\nols_test_normality() of olsrr package can be used to view formal statistical test methods.\n\nols_test_normality(condo.mlr1)\n\n-----------------------------------------------\n       Test             Statistic       pvalue  \n-----------------------------------------------\nShapiro-Wilk              0.6856         0.0000 \nKolmogorov-Smirnov        0.1366         0.0000 \nCramer-von Mises         121.0768        0.0000 \nAnderson-Darling         67.9551         0.0000 \n-----------------------------------------------\n\n\nThe summary table above reveals that the p-values of the four tests are way smaller than the alpha value of 0.05. Hence we will reject the null hypothesis and infer that there is statistical evidence that the residual are not normally distributed.\n\n\nTesting for Spatial Autocorrelation\nFirst, we will export the residual of the hedonic pricing model and save it as a data frame.\n\nmlr.output <- as.data.frame(condo.mlr1$residuals)\n\nNext, we will join the newly created data frame with condo_resale.sf object.\n\ncondo_resale.res.sf <- cbind(condo_resale.sf, \n                        condo.mlr1$residuals) %>%\nrename(`MLR_RES` = `condo.mlr1.residuals`)\n\nThe code chunk below will be used to perform the data conversion process.\n\ncondo_resale.sp <- as_Spatial(condo_resale.res.sf)\ncondo_resale.sp\n\nclass       : SpatialPointsDataFrame \nfeatures    : 1436 \nextent      : 14940.85, 43352.45, 24765.67, 48382.81  (xmin, xmax, ymin, ymax)\ncrs         : +proj=tmerc +lat_0=1.36666666666667 +lon_0=103.833333333333 +k=1 +x_0=28001.642 +y_0=38744.572 +ellps=WGS84 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs \nvariables   : 23\nnames       : POSTCODE, SELLING_PRICE, AREA_SQM, AGE,    PROX_CBD, PROX_CHILDCARE, PROX_ELDERLYCARE, PROX_URA_GROWTH_AREA, PROX_HAWKER_MARKET, PROX_KINDERGARTEN,    PROX_MRT,   PROX_PARK, PROX_PRIMARY_SCH, PROX_TOP_PRIMARY_SCH, PROX_SHOPPING_MALL, ... \nmin values  :    18965,        540000,       34,   0, 0.386916393,    0.004927023,      0.054508623,          0.214539508,        0.051817113,       0.004927023, 0.052779424, 0.029064164,      0.077106132,          0.077106132,                  0, ... \nmax values  :   828833,       1.8e+07,      619,  37, 19.18042832,     3.46572633,      3.949157205,           9.15540001,        5.374348075,       2.229045366,  3.48037319,  2.16104919,      3.928989144,          6.748192062,        3.477433767, ... \n\n\nNext, we will use tmap package to display the distribution of the residuals on an interactive map.\n\ntmap_mode(\"view\")\ntm_shape(mpsz_svy21)+\n  tmap_options(check.and.fix = TRUE) +\n  tm_polygons(alpha = 0.4) +\ntm_shape(condo_resale.res.sf) +  \n  tm_dots(col = \"MLR_RES\",\n          alpha = 0.6,\n          style=\"quantile\") +\n  tm_view(set.zoom.limits = c(11,14))\n\n\n\n\n\n\nWe switch back to plot mode before continuing\n\ntmap_mode(\"plot\")\n\nTo proof that our observation is indeed true, the Moran's I test will be performed\nFirst, we will compute the distance-based weight matrix by using dnearneigh() function of spdep.\n\nnb <- dnearneigh(coordinates(condo_resale.sp), 0, 1500, longlat = FALSE)\nsummary(nb)\n\nNeighbour list object:\nNumber of regions: 1436 \nNumber of nonzero links: 66266 \nPercentage nonzero weights: 3.213526 \nAverage number of links: 46.14624 \nLink number distribution:\n\n  1   3   5   7   9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24 \n  3   3   9   4   3  15  10  19  17  45  19   5  14  29  19   6  35  45  18  47 \n 25  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41  42  43  44 \n 16  43  22  26  21  11   9  23  22  13  16  25  21  37  16  18   8  21   4  12 \n 45  46  47  48  49  50  51  52  53  54  55  56  57  58  59  60  61  62  63  64 \n  8  36  18  14  14  43  11  12   8  13  12  13   4   5   6  12  11  20  29  33 \n 65  66  67  68  69  70  71  72  73  74  75  76  77  78  79  80  81  82  83  84 \n 15  20  10  14  15  15  11  16  12  10   8  19  12  14   9   8   4  13  11   6 \n 85  86  87  88  89  90  91  92  93  94  95  96  97  98  99 100 101 102 103 104 \n  4   9   4   4   4   6   2  16   9   4   5   9   3   9   4   2   1   2   1   1 \n105 106 107 108 109 110 112 116 125 \n  1   5   9   2   1   3   1   1   1 \n3 least connected regions:\n193 194 277 with 1 link\n1 most connected region:\n285 with 125 links\n\n\nNext, nb2listw() of spdep packge will be used to convert the output neighbours lists (i.e. nb) into a spatial weights.\n\nnb_lw <- nb2listw(nb, style = 'W')\nsummary(nb_lw)\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 1436 \nNumber of nonzero links: 66266 \nPercentage nonzero weights: 3.213526 \nAverage number of links: 46.14624 \nLink number distribution:\n\n  1   3   5   7   9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24 \n  3   3   9   4   3  15  10  19  17  45  19   5  14  29  19   6  35  45  18  47 \n 25  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41  42  43  44 \n 16  43  22  26  21  11   9  23  22  13  16  25  21  37  16  18   8  21   4  12 \n 45  46  47  48  49  50  51  52  53  54  55  56  57  58  59  60  61  62  63  64 \n  8  36  18  14  14  43  11  12   8  13  12  13   4   5   6  12  11  20  29  33 \n 65  66  67  68  69  70  71  72  73  74  75  76  77  78  79  80  81  82  83  84 \n 15  20  10  14  15  15  11  16  12  10   8  19  12  14   9   8   4  13  11   6 \n 85  86  87  88  89  90  91  92  93  94  95  96  97  98  99 100 101 102 103 104 \n  4   9   4   4   4   6   2  16   9   4   5   9   3   9   4   2   1   2   1   1 \n105 106 107 108 109 110 112 116 125 \n  1   5   9   2   1   3   1   1   1 \n3 least connected regions:\n193 194 277 with 1 link\n1 most connected region:\n285 with 125 links\n\nWeights style: W \nWeights constants summary:\n     n      nn   S0       S1       S2\nW 1436 2062096 1436 94.81916 5798.341\n\n\nNext, lm.morantest() of spdep package will be used to perform Moran's I test for residual spatial autocorrelation.\n\nlm.morantest(condo.mlr1, nb_lw)\n\n\n    Global Moran I for regression residuals\n\ndata:  \nmodel: lm(formula = SELLING_PRICE ~ AREA_SQM + AGE + PROX_CBD +\nPROX_CHILDCARE + PROX_ELDERLYCARE + PROX_URA_GROWTH_AREA + PROX_MRT +\nPROX_PARK + PROX_PRIMARY_SCH + PROX_SHOPPING_MALL + PROX_BUS_STOP +\nNO_Of_UNITS + FAMILY_FRIENDLY + FREEHOLD, data = condo_resale.sf)\nweights: nb_lw\n\nMoran I statistic standard deviate = 24.366, p-value < 2.2e-16\nalternative hypothesis: greater\nsample estimates:\nObserved Moran I      Expectation         Variance \n    1.438876e-01    -5.487594e-03     3.758259e-05 \n\n\nThe Global Moran's I test for residual spatial autocorrelation shows that it's p-value is less than 0.00000000000000022 which is less than the alpha value of 0.05. Hence, we will reject the null hypothesis that the residuals are randomly distributed.\nSince the Observed Global Moran I = 0.1424418 which is greater than 0, we can infer than the residuals resemble cluster distribution."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04.html#building-hedonic-pricing-models-using-gwmodel",
    "href": "Hands-on_Ex/Hands-on_Ex04.html#building-hedonic-pricing-models-using-gwmodel",
    "title": "Hands-on Exercise 4: Calibrating Hedonic Pricing Model for Private Highrise Property with GWR Method",
    "section": "Building Hedonic Pricing Models using GWmodel",
    "text": "Building Hedonic Pricing Models using GWmodel\n\nBuilding Fixed Bandwidth GWR Model\n\nComputing fixed bandwith\n\nbw.fixed <- bw.gwr(formula = SELLING_PRICE ~ AREA_SQM + AGE + PROX_CBD + \n                     PROX_CHILDCARE + PROX_ELDERLYCARE  + PROX_URA_GROWTH_AREA + \n                     PROX_MRT   + PROX_PARK + PROX_PRIMARY_SCH + \n                     PROX_SHOPPING_MALL + PROX_BUS_STOP + NO_Of_UNITS + \n                     FAMILY_FRIENDLY + FREEHOLD, \n                   data=condo_resale.sp, \n                   approach=\"CV\", \n                   kernel=\"gaussian\", \n                   adaptive=FALSE, \n                   longlat=FALSE)\n\nFixed bandwidth: 17660.96 CV score: 8.259118e+14 \nFixed bandwidth: 10917.26 CV score: 7.970454e+14 \nFixed bandwidth: 6749.419 CV score: 7.273273e+14 \nFixed bandwidth: 4173.553 CV score: 6.300006e+14 \nFixed bandwidth: 2581.58 CV score: 5.404958e+14 \nFixed bandwidth: 1597.687 CV score: 4.857515e+14 \nFixed bandwidth: 989.6077 CV score: 4.722431e+14 \nFixed bandwidth: 613.7939 CV score: 1.37828e+16 \nFixed bandwidth: 1221.873 CV score: 4.778717e+14 \nFixed bandwidth: 846.0596 CV score: 4.791629e+14 \nFixed bandwidth: 1078.325 CV score: 4.751406e+14 \nFixed bandwidth: 934.7772 CV score: 4.72518e+14 \nFixed bandwidth: 1023.495 CV score: 4.730305e+14 \nFixed bandwidth: 968.6643 CV score: 4.721317e+14 \nFixed bandwidth: 955.7206 CV score: 4.722072e+14 \nFixed bandwidth: 976.6639 CV score: 4.721387e+14 \nFixed bandwidth: 963.7202 CV score: 4.721484e+14 \nFixed bandwidth: 971.7199 CV score: 4.721293e+14 \nFixed bandwidth: 973.6083 CV score: 4.721309e+14 \nFixed bandwidth: 970.5527 CV score: 4.721295e+14 \nFixed bandwidth: 972.4412 CV score: 4.721296e+14 \nFixed bandwidth: 971.2741 CV score: 4.721292e+14 \nFixed bandwidth: 970.9985 CV score: 4.721293e+14 \nFixed bandwidth: 971.4443 CV score: 4.721292e+14 \nFixed bandwidth: 971.5496 CV score: 4.721293e+14 \nFixed bandwidth: 971.3793 CV score: 4.721292e+14 \nFixed bandwidth: 971.3391 CV score: 4.721292e+14 \nFixed bandwidth: 971.3143 CV score: 4.721292e+14 \nFixed bandwidth: 971.3545 CV score: 4.721292e+14 \nFixed bandwidth: 971.3296 CV score: 4.721292e+14 \nFixed bandwidth: 971.345 CV score: 4.721292e+14 \nFixed bandwidth: 971.3355 CV score: 4.721292e+14 \nFixed bandwidth: 971.3413 CV score: 4.721292e+14 \nFixed bandwidth: 971.3377 CV score: 4.721292e+14 \nFixed bandwidth: 971.34 CV score: 4.721292e+14 \nFixed bandwidth: 971.3405 CV score: 4.721292e+14 \nFixed bandwidth: 971.3408 CV score: 4.721292e+14 \nFixed bandwidth: 971.341 CV score: 4.721292e+14 \nFixed bandwidth: 971.3407 CV score: 4.721292e+14 \nFixed bandwidth: 971.3409 CV score: 4.721292e+14 \nFixed bandwidth: 971.3408 CV score: 4.721292e+14 \nFixed bandwidth: 971.3408 CV score: 4.721292e+14 \n\n\nThe result shows that the recommended bandwidth is 971.3398 metres. The measurement is in meter because SVY21 is based on the metric unit.\n\n\nGWModel method - fixed bandwidth\n\ngwr.fixed <- gwr.basic(formula = SELLING_PRICE ~ AREA_SQM + AGE + PROX_CBD + \n                         PROX_CHILDCARE + PROX_ELDERLYCARE  + PROX_URA_GROWTH_AREA + \n                         PROX_MRT   + PROX_PARK + PROX_PRIMARY_SCH + \n                         PROX_SHOPPING_MALL + PROX_BUS_STOP + NO_Of_UNITS + \n                         FAMILY_FRIENDLY + FREEHOLD, \n                       data=condo_resale.sp, \n                       bw=bw.fixed, \n                       kernel = 'gaussian', \n                       longlat = FALSE)\n\nThe code below can be used to display the model output.\n\ngwr.fixed\n\n   ***********************************************************************\n   *                       Package   GWmodel                             *\n   ***********************************************************************\n   Program starts at: 2022-12-09 23:43:20 \n   Call:\n   gwr.basic(formula = SELLING_PRICE ~ AREA_SQM + AGE + PROX_CBD + \n    PROX_CHILDCARE + PROX_ELDERLYCARE + PROX_URA_GROWTH_AREA + \n    PROX_MRT + PROX_PARK + PROX_PRIMARY_SCH + PROX_SHOPPING_MALL + \n    PROX_BUS_STOP + NO_Of_UNITS + FAMILY_FRIENDLY + FREEHOLD, \n    data = condo_resale.sp, bw = bw.fixed, kernel = \"gaussian\", \n    longlat = FALSE)\n\n   Dependent (y) variable:  SELLING_PRICE\n   Independent variables:  AREA_SQM AGE PROX_CBD PROX_CHILDCARE PROX_ELDERLYCARE PROX_URA_GROWTH_AREA PROX_MRT PROX_PARK PROX_PRIMARY_SCH PROX_SHOPPING_MALL PROX_BUS_STOP NO_Of_UNITS FAMILY_FRIENDLY FREEHOLD\n   Number of data points: 1436\n   ***********************************************************************\n   *                    Results of Global Regression                     *\n   ***********************************************************************\n\n   Call:\n    lm(formula = formula, data = data)\n\n   Residuals:\n     Min       1Q   Median       3Q      Max \n-3470778  -298119   -23481   248917 12234210 \n\n   Coefficients:\n                          Estimate Std. Error t value Pr(>|t|)    \n   (Intercept)           527633.22  108183.22   4.877 1.20e-06 ***\n   AREA_SQM               12777.52     367.48  34.771  < 2e-16 ***\n   AGE                   -24687.74    2754.84  -8.962  < 2e-16 ***\n   PROX_CBD              -77131.32    5763.12 -13.384  < 2e-16 ***\n   PROX_CHILDCARE       -318472.75  107959.51  -2.950 0.003231 ** \n   PROX_ELDERLYCARE      185575.62   39901.86   4.651 3.61e-06 ***\n   PROX_URA_GROWTH_AREA   39163.25   11754.83   3.332 0.000885 ***\n   PROX_MRT             -294745.11   56916.37  -5.179 2.56e-07 ***\n   PROX_PARK             570504.81   65507.03   8.709  < 2e-16 ***\n   PROX_PRIMARY_SCH      159856.14   60234.60   2.654 0.008046 ** \n   PROX_SHOPPING_MALL   -220947.25   36561.83  -6.043 1.93e-09 ***\n   PROX_BUS_STOP         682482.22  134513.24   5.074 4.42e-07 ***\n   NO_Of_UNITS             -245.48      87.95  -2.791 0.005321 ** \n   FAMILY_FRIENDLY       146307.58   46893.02   3.120 0.001845 ** \n   FREEHOLD              350599.81   48506.48   7.228 7.98e-13 ***\n\n   ---Significance stars\n   Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 \n   Residual standard error: 756000 on 1421 degrees of freedom\n   Multiple R-squared: 0.6507\n   Adjusted R-squared: 0.6472 \n   F-statistic: 189.1 on 14 and 1421 DF,  p-value: < 2.2e-16 \n   ***Extra Diagnostic information\n   Residual sum of squares: 8.120609e+14\n   Sigma(hat): 752522.9\n   AIC:  42966.76\n   AICc:  42967.14\n   BIC:  41731.39\n   ***********************************************************************\n   *          Results of Geographically Weighted Regression              *\n   ***********************************************************************\n\n   *********************Model calibration information*********************\n   Kernel function: gaussian \n   Fixed bandwidth: 971.3408 \n   Regression points: the same locations as observations are used.\n   Distance metric: Euclidean distance metric is used.\n\n   ****************Summary of GWR coefficient estimates:******************\n                               Min.     1st Qu.      Median     3rd Qu.\n   Intercept            -3.5988e+07 -5.1998e+05  7.6780e+05  1.7412e+06\n   AREA_SQM              1.0003e+03  5.2758e+03  7.4740e+03  1.2301e+04\n   AGE                  -1.3475e+05 -2.0813e+04 -8.6260e+03 -3.7784e+03\n   PROX_CBD             -7.7047e+07 -2.3608e+05 -8.3600e+04  3.4645e+04\n   PROX_CHILDCARE       -6.0097e+06 -3.3667e+05 -9.7425e+04  2.9008e+05\n   PROX_ELDERLYCARE     -3.5000e+06 -1.5970e+05  3.1971e+04  1.9577e+05\n   PROX_URA_GROWTH_AREA -3.0170e+06 -8.2013e+04  7.0749e+04  2.2612e+05\n   PROX_MRT             -3.5282e+06 -6.5836e+05 -1.8833e+05  3.6922e+04\n   PROX_PARK            -1.2062e+06 -2.1732e+05  3.5383e+04  4.1335e+05\n   PROX_PRIMARY_SCH     -2.2695e+07 -1.7066e+05  4.8472e+04  5.1555e+05\n   PROX_SHOPPING_MALL   -7.2585e+06 -1.6684e+05 -1.0517e+04  1.5923e+05\n   PROX_BUS_STOP        -1.4676e+06 -4.5206e+04  3.7601e+05  1.1664e+06\n   NO_Of_UNITS          -1.3170e+03 -2.4822e+02 -3.0846e+01  2.5496e+02\n   FAMILY_FRIENDLY      -2.2749e+06 -1.1140e+05  7.6214e+03  1.6107e+05\n   FREEHOLD             -9.2067e+06  3.8073e+04  1.5169e+05  3.7528e+05\n                             Max.\n   Intercept            112793007\n   AREA_SQM                 21575\n   AGE                     434200\n   PROX_CBD               2704591\n   PROX_CHILDCARE         1654088\n   PROX_ELDERLYCARE      38867786\n   PROX_URA_GROWTH_AREA  78515685\n   PROX_MRT               3124310\n   PROX_PARK             18122416\n   PROX_PRIMARY_SCH       4637495\n   PROX_SHOPPING_MALL     1529951\n   PROX_BUS_STOP         11342166\n   NO_Of_UNITS              12907\n   FAMILY_FRIENDLY        1720744\n   FREEHOLD               6073633\n   ************************Diagnostic information*************************\n   Number of data points: 1436 \n   Effective number of parameters (2trace(S) - trace(S'S)): 438.3803 \n   Effective degrees of freedom (n-2trace(S) + trace(S'S)): 997.6197 \n   AICc (GWR book, Fotheringham, et al. 2002, p. 61, eq 2.33): 42263.61 \n   AIC (GWR book, Fotheringham, et al. 2002,GWR p. 96, eq. 4.22): 41632.36 \n   BIC (GWR book, Fotheringham, et al. 2002,GWR p. 61, eq. 2.34): 42515.71 \n   Residual sum of squares: 2.534071e+14 \n   R-square value:  0.8909911 \n   Adjusted R-square value:  0.8430417 \n\n   ***********************************************************************\n   Program stops at: 2022-12-09 23:43:21 \n\n\nThe report shows that the adjusted r-square of the gwr is 0.8430 which is significantly better than the globel multiple linear regression model of 0.6472.\n\n\n\nBuilding Adaptive Bandwidth GWR Mode\n\nComputing the adaptive bandwidth\n\nbw.adaptive <- bw.gwr(formula = SELLING_PRICE ~ AREA_SQM + AGE  + \n                        PROX_CBD + PROX_CHILDCARE + PROX_ELDERLYCARE    + \n                        PROX_URA_GROWTH_AREA + PROX_MRT + PROX_PARK + \n                        PROX_PRIMARY_SCH + PROX_SHOPPING_MALL   + PROX_BUS_STOP + \n                        NO_Of_UNITS + FAMILY_FRIENDLY + FREEHOLD, \n                      data=condo_resale.sp, \n                      approach=\"CV\", \n                      kernel=\"gaussian\", \n                      adaptive=TRUE, \n                      longlat=FALSE)\n\nAdaptive bandwidth: 895 CV score: 7.952401e+14 \nAdaptive bandwidth: 561 CV score: 7.667364e+14 \nAdaptive bandwidth: 354 CV score: 6.953454e+14 \nAdaptive bandwidth: 226 CV score: 6.15223e+14 \nAdaptive bandwidth: 147 CV score: 5.674373e+14 \nAdaptive bandwidth: 98 CV score: 5.426745e+14 \nAdaptive bandwidth: 68 CV score: 5.168117e+14 \nAdaptive bandwidth: 49 CV score: 4.859631e+14 \nAdaptive bandwidth: 37 CV score: 4.646518e+14 \nAdaptive bandwidth: 30 CV score: 4.422088e+14 \nAdaptive bandwidth: 25 CV score: 4.430816e+14 \nAdaptive bandwidth: 32 CV score: 4.505602e+14 \nAdaptive bandwidth: 27 CV score: 4.462172e+14 \nAdaptive bandwidth: 30 CV score: 4.422088e+14 \n\n\n\n\nConstructing the adaptive bandwidth gwr model\n\ngwr.adaptive <- gwr.basic(formula = SELLING_PRICE ~ AREA_SQM + AGE + \n                            PROX_CBD + PROX_CHILDCARE + PROX_ELDERLYCARE + \n                            PROX_URA_GROWTH_AREA + PROX_MRT + PROX_PARK + \n                            PROX_PRIMARY_SCH + PROX_SHOPPING_MALL + PROX_BUS_STOP + \n                            NO_Of_UNITS + FAMILY_FRIENDLY + FREEHOLD, \n                          data=condo_resale.sp, bw=bw.adaptive, \n                          kernel = 'gaussian', \n                          adaptive=TRUE, \n                          longlat = FALSE)\n\nNow we can display the output.\n\ngwr.adaptive\n\n   ***********************************************************************\n   *                       Package   GWmodel                             *\n   ***********************************************************************\n   Program starts at: 2022-12-09 23:43:27 \n   Call:\n   gwr.basic(formula = SELLING_PRICE ~ AREA_SQM + AGE + PROX_CBD + \n    PROX_CHILDCARE + PROX_ELDERLYCARE + PROX_URA_GROWTH_AREA + \n    PROX_MRT + PROX_PARK + PROX_PRIMARY_SCH + PROX_SHOPPING_MALL + \n    PROX_BUS_STOP + NO_Of_UNITS + FAMILY_FRIENDLY + FREEHOLD, \n    data = condo_resale.sp, bw = bw.adaptive, kernel = \"gaussian\", \n    adaptive = TRUE, longlat = FALSE)\n\n   Dependent (y) variable:  SELLING_PRICE\n   Independent variables:  AREA_SQM AGE PROX_CBD PROX_CHILDCARE PROX_ELDERLYCARE PROX_URA_GROWTH_AREA PROX_MRT PROX_PARK PROX_PRIMARY_SCH PROX_SHOPPING_MALL PROX_BUS_STOP NO_Of_UNITS FAMILY_FRIENDLY FREEHOLD\n   Number of data points: 1436\n   ***********************************************************************\n   *                    Results of Global Regression                     *\n   ***********************************************************************\n\n   Call:\n    lm(formula = formula, data = data)\n\n   Residuals:\n     Min       1Q   Median       3Q      Max \n-3470778  -298119   -23481   248917 12234210 \n\n   Coefficients:\n                          Estimate Std. Error t value Pr(>|t|)    \n   (Intercept)           527633.22  108183.22   4.877 1.20e-06 ***\n   AREA_SQM               12777.52     367.48  34.771  < 2e-16 ***\n   AGE                   -24687.74    2754.84  -8.962  < 2e-16 ***\n   PROX_CBD              -77131.32    5763.12 -13.384  < 2e-16 ***\n   PROX_CHILDCARE       -318472.75  107959.51  -2.950 0.003231 ** \n   PROX_ELDERLYCARE      185575.62   39901.86   4.651 3.61e-06 ***\n   PROX_URA_GROWTH_AREA   39163.25   11754.83   3.332 0.000885 ***\n   PROX_MRT             -294745.11   56916.37  -5.179 2.56e-07 ***\n   PROX_PARK             570504.81   65507.03   8.709  < 2e-16 ***\n   PROX_PRIMARY_SCH      159856.14   60234.60   2.654 0.008046 ** \n   PROX_SHOPPING_MALL   -220947.25   36561.83  -6.043 1.93e-09 ***\n   PROX_BUS_STOP         682482.22  134513.24   5.074 4.42e-07 ***\n   NO_Of_UNITS             -245.48      87.95  -2.791 0.005321 ** \n   FAMILY_FRIENDLY       146307.58   46893.02   3.120 0.001845 ** \n   FREEHOLD              350599.81   48506.48   7.228 7.98e-13 ***\n\n   ---Significance stars\n   Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 \n   Residual standard error: 756000 on 1421 degrees of freedom\n   Multiple R-squared: 0.6507\n   Adjusted R-squared: 0.6472 \n   F-statistic: 189.1 on 14 and 1421 DF,  p-value: < 2.2e-16 \n   ***Extra Diagnostic information\n   Residual sum of squares: 8.120609e+14\n   Sigma(hat): 752522.9\n   AIC:  42966.76\n   AICc:  42967.14\n   BIC:  41731.39\n   ***********************************************************************\n   *          Results of Geographically Weighted Regression              *\n   ***********************************************************************\n\n   *********************Model calibration information*********************\n   Kernel function: gaussian \n   Adaptive bandwidth: 30 (number of nearest neighbours)\n   Regression points: the same locations as observations are used.\n   Distance metric: Euclidean distance metric is used.\n\n   ****************Summary of GWR coefficient estimates:******************\n                               Min.     1st Qu.      Median     3rd Qu.\n   Intercept            -1.3487e+08 -2.4669e+05  7.7928e+05  1.6194e+06\n   AREA_SQM              3.3188e+03  5.6285e+03  7.7825e+03  1.2738e+04\n   AGE                  -9.6746e+04 -2.9288e+04 -1.4043e+04 -5.6119e+03\n   PROX_CBD             -2.5330e+06 -1.6256e+05 -7.7242e+04  2.6624e+03\n   PROX_CHILDCARE       -1.2790e+06 -2.0175e+05  8.7158e+03  3.7778e+05\n   PROX_ELDERLYCARE     -1.6212e+06 -9.2050e+04  6.1029e+04  2.8184e+05\n   PROX_URA_GROWTH_AREA -7.2686e+06 -3.0350e+04  4.5869e+04  2.4613e+05\n   PROX_MRT             -4.3781e+07 -6.7282e+05 -2.2115e+05 -7.4593e+04\n   PROX_PARK            -2.9020e+06 -1.6782e+05  1.1601e+05  4.6572e+05\n   PROX_PRIMARY_SCH     -8.6418e+05 -1.6627e+05 -7.7853e+03  4.3222e+05\n   PROX_SHOPPING_MALL   -1.8272e+06 -1.3175e+05 -1.4049e+04  1.3799e+05\n   PROX_BUS_STOP        -2.0579e+06 -7.1461e+04  4.1104e+05  1.2071e+06\n   NO_Of_UNITS          -2.1993e+03 -2.3685e+02 -3.4699e+01  1.1657e+02\n   FAMILY_FRIENDLY      -5.9879e+05 -5.0927e+04  2.6173e+04  2.2481e+05\n   FREEHOLD             -1.6340e+05  4.0765e+04  1.9023e+05  3.7960e+05\n                            Max.\n   Intercept            18758355\n   AREA_SQM                23064\n   AGE                     13303\n   PROX_CBD             11346650\n   PROX_CHILDCARE        2892127\n   PROX_ELDERLYCARE      2465671\n   PROX_URA_GROWTH_AREA  7384059\n   PROX_MRT              1186242\n   PROX_PARK             2588497\n   PROX_PRIMARY_SCH      3381462\n   PROX_SHOPPING_MALL   38038564\n   PROX_BUS_STOP        12081592\n   NO_Of_UNITS              1010\n   FAMILY_FRIENDLY       2072414\n   FREEHOLD              1813995\n   ************************Diagnostic information*************************\n   Number of data points: 1436 \n   Effective number of parameters (2trace(S) - trace(S'S)): 350.3088 \n   Effective degrees of freedom (n-2trace(S) + trace(S'S)): 1085.691 \n   AICc (GWR book, Fotheringham, et al. 2002, p. 61, eq 2.33): 41982.22 \n   AIC (GWR book, Fotheringham, et al. 2002,GWR p. 96, eq. 4.22): 41546.74 \n   BIC (GWR book, Fotheringham, et al. 2002,GWR p. 61, eq. 2.34): 41914.08 \n   Residual sum of squares: 2.528227e+14 \n   R-square value:  0.8912425 \n   Adjusted R-square value:  0.8561185 \n\n   ***********************************************************************\n   Program stops at: 2022-12-09 23:43:28 \n\n\n\n\n\nVisualising GWR Output\nRefer HERE for more information about visualizing GWR output.\n\n\nConverting SDF into sf data.frame\nTo visualize the data in SDF, we need to convert the data table into the simple feature format.\n\ncondo_resale.sf.adaptive <- st_as_sf(gwr.adaptive$SDF) %>%\n  st_transform(crs=3414)\ncondo_resale.sf.adaptive.svy21 <- st_transform(condo_resale.sf.adaptive, 3414)\ngwr.adaptive.output <- as.data.frame(gwr.adaptive$SDF)\ncondo_resale.sf.adaptive <- cbind(condo_resale.res.sf, as.matrix(gwr.adaptive.output))\n\nNext, glimpse() is used to display the content of condo_resale.sf.adaptive sf data frame.\n\nglimpse(condo_resale.sf.adaptive)\n\nRows: 1,436\nColumns: 77\n$ POSTCODE                <dbl> 118635, 288420, 267833, 258380, 467169, 466472…\n$ SELLING_PRICE           <dbl> 3000000, 3880000, 3325000, 4250000, 1400000, 1…\n$ AREA_SQM                <dbl> 309, 290, 248, 127, 145, 139, 218, 141, 165, 1…\n$ AGE                     <dbl> 30, 32, 33, 7, 28, 22, 24, 24, 27, 31, 17, 22,…\n$ PROX_CBD                <dbl> 7.941259, 6.609797, 6.898000, 4.038861, 11.783…\n$ PROX_CHILDCARE          <dbl> 0.16597932, 0.28027246, 0.42922669, 0.39473543…\n$ PROX_ELDERLYCARE        <dbl> 2.5198118, 1.9333338, 0.5021395, 1.9910316, 1.…\n$ PROX_URA_GROWTH_AREA    <dbl> 6.618741, 7.505109, 6.463887, 4.906512, 6.4106…\n$ PROX_HAWKER_MARKET      <dbl> 1.76542207, 0.54507614, 0.37789301, 1.68259969…\n$ PROX_KINDERGARTEN       <dbl> 0.05835552, 0.61592412, 0.14120309, 0.38200076…\n$ PROX_MRT                <dbl> 0.5607188, 0.6584461, 0.3053433, 0.6910183, 0.…\n$ PROX_PARK               <dbl> 1.1710446, 0.1992269, 0.2779886, 0.9832843, 0.…\n$ PROX_PRIMARY_SCH        <dbl> 1.6340256, 0.9747834, 1.4715016, 1.4546324, 0.…\n$ PROX_TOP_PRIMARY_SCH    <dbl> 3.3273195, 0.9747834, 1.4715016, 2.3006394, 0.…\n$ PROX_SHOPPING_MALL      <dbl> 2.2102717, 2.9374279, 1.2256850, 0.3525671, 1.…\n$ PROX_SUPERMARKET        <dbl> 0.9103958, 0.5900617, 0.4135583, 0.4162219, 0.…\n$ PROX_BUS_STOP           <dbl> 0.10336166, 0.28673408, 0.28504777, 0.29872340…\n$ NO_Of_UNITS             <dbl> 18, 20, 27, 30, 30, 31, 32, 32, 32, 32, 34, 34…\n$ FAMILY_FRIENDLY         <dbl> 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0…\n$ FREEHOLD                <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1…\n$ LEASEHOLD_99YR          <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ LOG_SELLING_PRICE       <dbl> 14.91412, 15.17135, 15.01698, 15.26243, 14.151…\n$ MLR_RES                 <dbl> -1489099.55, 415494.57, 194129.69, 1088992.71,…\n$ Intercept               <dbl> 2050011.67, 1633128.24, 3433608.17, 234358.91,…\n$ AREA_SQM.1              <dbl> 9561.892, 16576.853, 13091.861, 20730.601, 672…\n$ AGE.1                   <dbl> -9514.634, -58185.479, -26707.386, -93308.988,…\n$ PROX_CBD.1              <dbl> -120681.94, -149434.22, -259397.77, 2426853.66…\n$ PROX_CHILDCARE.1        <dbl> 319266.925, 441102.177, -120116.816, 480825.28…\n$ PROX_ELDERLYCARE.1      <dbl> -393417.795, 325188.741, 535855.806, 314783.72…\n$ PROX_URA_GROWTH_AREA.1  <dbl> -159980.203, -142290.389, -253621.206, -267929…\n$ PROX_MRT.1              <dbl> -299742.96, -2510522.23, -936853.28, -2039479.…\n$ PROX_PARK.1             <dbl> -172104.47, 523379.72, 209099.85, -759153.26, …\n$ PROX_PRIMARY_SCH.1      <dbl> 242668.03, 1106830.66, 571462.33, 3127477.21, …\n$ PROX_SHOPPING_MALL.1    <dbl> 300881.390, -87693.378, -126732.712, -29593.34…\n$ PROX_BUS_STOP.1         <dbl> 1210615.44, 1843587.22, 1411924.90, 7225577.51…\n$ NO_Of_UNITS.1           <dbl> 104.8290640, -288.3441183, -9.5532945, -161.35…\n$ FAMILY_FRIENDLY.1       <dbl> -9075.370, 310074.664, 5949.746, 1556178.531, …\n$ FREEHOLD.1              <dbl> 303955.61, 396221.27, 168821.75, 1212515.58, 3…\n$ y                       <dbl> 3000000, 3880000, 3325000, 4250000, 1400000, 1…\n$ yhat                    <dbl> 2886531.8, 3466801.5, 3616527.2, 5435481.6, 13…\n$ residual                <dbl> 113468.16, 413198.52, -291527.20, -1185481.63,…\n$ CV_Score                <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…\n$ Stud_residual           <dbl> 0.38207013, 1.01433140, -0.83780678, -2.846146…\n$ Intercept_SE            <dbl> 516105.5, 488083.5, 963711.4, 444185.5, 211962…\n$ AREA_SQM_SE             <dbl> 823.2860, 825.2380, 988.2240, 617.4007, 1376.2…\n$ AGE_SE                  <dbl> 5889.782, 6226.916, 6510.236, 6010.511, 8180.3…\n$ PROX_CBD_SE             <dbl> 37411.22, 23615.06, 56103.77, 469337.41, 41064…\n$ PROX_CHILDCARE_SE       <dbl> 319111.1, 299705.3, 349128.5, 304965.2, 698720…\n$ PROX_ELDERLYCARE_SE     <dbl> 120633.34, 84546.69, 129687.07, 127150.69, 327…\n$ PROX_URA_GROWTH_AREA_SE <dbl> 56207.39, 76956.50, 95774.60, 470762.12, 47433…\n$ PROX_MRT_SE             <dbl> 185181.3, 281133.9, 275483.7, 279877.1, 363830…\n$ PROX_PARK_SE            <dbl> 205499.6, 229358.7, 314124.3, 227249.4, 364580…\n$ PROX_PRIMARY_SCH_SE     <dbl> 152400.7, 165150.7, 196662.6, 240878.9, 249087…\n$ PROX_SHOPPING_MALL_SE   <dbl> 109268.8, 98906.8, 119913.3, 177104.1, 301032.…\n$ PROX_BUS_STOP_SE        <dbl> 600668.6, 410222.1, 464156.7, 562810.8, 740922…\n$ NO_Of_UNITS_SE          <dbl> 218.1258, 208.9410, 210.9828, 361.7767, 299.50…\n$ FAMILY_FRIENDLY_SE      <dbl> 131474.73, 114989.07, 146607.22, 108726.62, 16…\n$ FREEHOLD_SE             <dbl> 115954.0, 130110.0, 141031.5, 138239.1, 210641…\n$ Intercept_TV            <dbl> 3.9720784, 3.3460017, 3.5629010, 0.5276150, 1.…\n$ AREA_SQM_TV             <dbl> 11.614302, 20.087361, 13.247868, 33.577223, 4.…\n$ AGE_TV                  <dbl> -1.6154474, -9.3441881, -4.1023685, -15.524301…\n$ PROX_CBD_TV             <dbl> -3.22582173, -6.32792021, -4.62353528, 5.17080…\n$ PROX_CHILDCARE_TV       <dbl> 1.000488185, 1.471786337, -0.344047555, 1.5766…\n$ PROX_ELDERLYCARE_TV     <dbl> -3.26126929, 3.84626245, 4.13191383, 2.4756745…\n$ PROX_URA_GROWTH_AREA_TV <dbl> -2.846248368, -1.848971738, -2.648105057, -5.6…\n$ PROX_MRT_TV             <dbl> -1.61864578, -8.92998600, -3.40075727, -7.2870…\n$ PROX_PARK_TV            <dbl> -0.83749312, 2.28192684, 0.66565951, -3.340617…\n$ PROX_PRIMARY_SCH_TV     <dbl> 1.59230221, 6.70194543, 2.90580089, 12.9836104…\n$ PROX_SHOPPING_MALL_TV   <dbl> 2.753588422, -0.886626400, -1.056869486, -0.16…\n$ PROX_BUS_STOP_TV        <dbl> 2.0154464, 4.4941192, 3.0419145, 12.8383775, 0…\n$ NO_Of_UNITS_TV          <dbl> 0.480589953, -1.380026395, -0.045279967, -0.44…\n$ FAMILY_FRIENDLY_TV      <dbl> -0.06902748, 2.69655779, 0.04058290, 14.312764…\n$ FREEHOLD_TV             <dbl> 2.6213469, 3.0452799, 1.1970499, 8.7711485, 1.…\n$ Local_R2                <dbl> 0.8846744, 0.8899773, 0.8947007, 0.9073605, 0.…\n$ coords.x1               <dbl> 22085.12, 25656.84, 23963.99, 27044.28, 41042.…\n$ coords.x2               <dbl> 29951.54, 34546.20, 32890.80, 32319.77, 33743.…\n$ geometry                <POINT [m]> POINT (22085.12 29951.54), POINT (25656.…\n\n\n\nsummary(gwr.adaptive$SDF$yhat)\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n  171347  1102001  1385528  1751842  1982307 13887901 \n\n\n\n\nVisualising local R2\n\ntmap_mode(\"view\")\ntm_shape(mpsz_svy21)+\n  tm_polygons(alpha = 0.1) +\ntm_shape(condo_resale.sf.adaptive) +  \n  tm_dots(col = \"Local_R2\",\n          border.col = \"gray60\",\n          border.lwd = 1) +\n  tm_view(set.zoom.limits = c(11,14))\n\n\n\n\n\n\n\ntmap_mode(\"plot\")\n\n\nBy URA Plannign Region\n\ntm_shape(mpsz_svy21[mpsz_svy21$REGION_N==\"CENTRAL REGION\", ])+\n  tm_polygons()+\ntm_shape(condo_resale.sf.adaptive) + \n  tm_bubbles(col = \"Local_R2\",\n           size = 0.15,\n           border.col = \"gray60\",\n           border.lwd = 1)"
  }
]