[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Map Here and There",
    "section": "",
    "text": "This is my journey of learning geospatial analytics. Follow me on this webpage for more!"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Hello, this is an introduction site. I will update content later, maybe stories of my learning journey?"
  },
  {
    "objectID": "Hands-on_Ex01.html",
    "href": "Hands-on_Ex01.html",
    "title": "Hands-on Exercise 1: Geospatial Wrangling with R",
    "section": "",
    "text": "In this hands-on exercise, I learn how to import and wrangle geospatial data using appropriate R packages."
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html",
    "title": "Hands-on Exercise 1: Geospatial Wrangling and Choropleth Mapping with R",
    "section": "",
    "text": "In this hands-on exercise, I learn how to import and wrangle geospatial data using appropriate R packages.\n\n\n\nThe code chunk below installs and loads sf and tidyverse.\nNotes: Make sure you imported the pacman package before running the code below.\n\npacman::p_load(sf, tidyverse)\n\n\n\n\nBefore importing anything, download the data zip file(s), unzip, and put them into the folder inside the directory of your page. Then create a Quarto document within that folder. The Quarto document and the data files need to be in the same folder, or you need to clarify the path to the data file while running the code below.\n\n\nNotes: You need to save your working R document as an qmd file before you can run the code below.\n\nmpsz <- st_read(dsn = \"data/geospatial\", layer = \"MP14_SUBZONE_WEB_PL\")\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/Hands-on_Ex01/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\n\n\n\n\nRun the code chunk below.\n\ncyclingpath <- st_read(dsn = \"data/geospatial\", layer = \"CyclingPath\")\n\nReading layer `CyclingPath' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/Hands-on_Ex01/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 1625 features and 2 fields\nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: 12711.19 ymin: 28711.33 xmax: 42626.09 ymax: 48948.15\nProjected CRS: SVY21\n\n\n\n\n\nRun the code chunk below.\n\npreschool <- st_read(\"data/geospatial/pre-schools-location-kml.kml\")\n\nReading layer `PRESCHOOLS_LOCATION' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/Hands-on_Ex01/data/geospatial/pre-schools-location-kml.kml' \n  using driver `KML'\nSimple feature collection with 1359 features and 2 fields\nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6824 ymin: 1.248403 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\n\n\n\n\n\n\n\n\nThe type of geometry is multipolygon.\n\nst_geometry(mpsz)\n\nGeometry set for 323 features \nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\nFirst 5 geometries:\n\n\nMULTIPOLYGON (((31495.56 30140.01, 31980.96 296...\n\n\nMULTIPOLYGON (((29092.28 30021.89, 29119.64 300...\n\n\nMULTIPOLYGON (((29932.33 29879.12, 29947.32 298...\n\n\nMULTIPOLYGON (((27131.28 30059.73, 27088.33 297...\n\n\nMULTIPOLYGON (((26451.03 30396.46, 26440.47 303...\n\n\n\n\n\nGlimpse display a sneak peek into the data type and values of the variables. Notice that X_ADDR and Y_ADDR are double type. There are other types like character, integer, and date.\n\nglimpse(mpsz)\n\nRows: 323\nColumns: 16\n$ OBJECTID   <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, …\n$ SUBZONE_NO <int> 1, 1, 3, 8, 3, 7, 9, 2, 13, 7, 12, 6, 1, 5, 1, 1, 3, 2, 2, …\n$ SUBZONE_N  <chr> \"MARINA SOUTH\", \"PEARL'S HILL\", \"BOAT QUAY\", \"HENDERSON HIL…\n$ SUBZONE_C  <chr> \"MSSZ01\", \"OTSZ01\", \"SRSZ03\", \"BMSZ08\", \"BMSZ03\", \"BMSZ07\",…\n$ CA_IND     <chr> \"Y\", \"Y\", \"Y\", \"N\", \"N\", \"N\", \"N\", \"Y\", \"N\", \"N\", \"N\", \"N\",…\n$ PLN_AREA_N <chr> \"MARINA SOUTH\", \"OUTRAM\", \"SINGAPORE RIVER\", \"BUKIT MERAH\",…\n$ PLN_AREA_C <chr> \"MS\", \"OT\", \"SR\", \"BM\", \"BM\", \"BM\", \"BM\", \"SR\", \"QT\", \"QT\",…\n$ REGION_N   <chr> \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENT…\n$ REGION_C   <chr> \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\",…\n$ INC_CRC    <chr> \"5ED7EB253F99252E\", \"8C7149B9EB32EEFC\", \"C35FEFF02B13E0E5\",…\n$ FMEL_UPD_D <date> 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05…\n$ X_ADDR     <dbl> 31595.84, 28679.06, 29654.96, 26782.83, 26201.96, 25358.82,…\n$ Y_ADDR     <dbl> 29220.19, 29782.05, 29974.66, 29933.77, 30005.70, 29991.38,…\n$ SHAPE_Leng <dbl> 5267.381, 3506.107, 1740.926, 3313.625, 2825.594, 4428.913,…\n$ SHAPE_Area <dbl> 1630379.27, 559816.25, 160807.50, 595428.89, 387429.44, 103…\n$ geometry   <MULTIPOLYGON [m]> MULTIPOLYGON (((31495.56 30..., MULTIPOLYGON (…\n\n\n\n\n\nUse n = … to select the number of records to display. Head gives a look at the first few rows of the data frame.\n\nhead(mpsz, n = 5)\n\nSimple feature collection with 5 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 25867.68 ymin: 28369.47 xmax: 32362.39 ymax: 30435.54\nProjected CRS: SVY21\n  OBJECTID SUBZONE_NO      SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N\n1        1          1   MARINA SOUTH    MSSZ01      Y    MARINA SOUTH\n2        2          1   PEARL'S HILL    OTSZ01      Y          OUTRAM\n3        3          3      BOAT QUAY    SRSZ03      Y SINGAPORE RIVER\n4        4          8 HENDERSON HILL    BMSZ08      N     BUKIT MERAH\n5        5          3        REDHILL    BMSZ03      N     BUKIT MERAH\n  PLN_AREA_C       REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1         MS CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84\n2         OT CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06\n3         SR CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96\n4         BM CENTRAL REGION       CR 3775D82C5DDBEFBD 2014-12-05 26782.83\n5         BM CENTRAL REGION       CR 85D9ABEF0A40678F 2014-12-05 26201.96\n    Y_ADDR SHAPE_Leng SHAPE_Area                       geometry\n1 29220.19   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...\n2 29782.05   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...\n3 29974.66   1740.926   160807.5 MULTIPOLYGON (((29932.33 29...\n4 29933.77   3313.625   595428.9 MULTIPOLYGON (((27131.28 30...\n5 30005.70   2825.594   387429.4 MULTIPOLYGON (((26451.03 30...\n\n\n\n\n\n\nWith geospatial data, we can use the plot() function to display them as visual elements. We can use max.plot = … to define the number of plots shown. This data set has 15 plots at the maximum but we only sketch 9 plots here, hence max.plot = 9.\n\nplot(mpsz, max.plot = 9)\n\n\n\n\nWe can choose to plot just one plot using the code chunk below. This is the plot of the sf object, which is the frame of all plots.\n\nplot(st_geometry(mpsz))\n\n\n\n\nOr we can plot and view a specific attribute.\n\nplot(mpsz[\"PLN_AREA_N\"])\n\n\n\n\n\nNotes: plot is only used for a quickly. For high cartographic quality plot, use tmap R package.\n\n\n\n\nWhen we want to project two or more geospatial data sets, it is important to ensure the data sets are projected under the same coordinate system. Projection Transformation is the method of projecting a data frame from one coordinate system to another.\n\n\nIssues to notice: missing coordination or wrongly assigned coordination due to the importing process.\nUsing the code chunk below, we can see the coordinate system of mpsz.\n\nst_crs(mpsz)\n\nCoordinate Reference System:\n  User input: SVY21 \n  wkt:\nPROJCRS[\"SVY21\",\n    BASEGEOGCRS[\"SVY21[WGS84]\",\n        DATUM[\"World Geodetic System 1984\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ID[\"EPSG\",6326]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"Degree\",0.0174532925199433]]],\n    CONVERSION[\"unnamed\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]\n\n\n\nNotice the User input says the data is projected in svy21, but the EPSG code is 9001. This is a wrong EPSG code because the EPSG code for svy21 should be 3414.\n\nWe now assign the correct EPSG code using the code below.\n\nmpsz3414 <- st_set_crs(mpsz, 3414)\n\nWarning: st_crs<- : replacing crs does not reproject data; use st_transform for\nthat\n\n\nR warns us that st_crs does not reproject data. While this is true in case we want to do projection transformation, here we simply want to fix the EPSG code. Therefore, reprojection is not necessary and we can proceed with checking the EPSG of mpsz3414, which shows the correct EPSG code.\n\nst_crs(mpsz3414)\n\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n\n\n\n\n\nNow we inspect the geometry of preschool. It is clear that preschool is projected in the WGS84 coordinate system.\n\nst_geometry(preschool)\n\nGeometry set for 1359 features \nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6824 ymin: 1.248403 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\nFirst 5 geometries:\n\n\nPOINT Z (103.7614 1.308683 0)\n\n\nPOINT Z (103.7536 1.315748 0)\n\n\nPOINT Z (103.7645 1.305078 0)\n\n\nPOINT Z (103.765 1.305239 0)\n\n\nPOINT Z (103.7597 1.315983 0)\n\n\nWe will transform the projection of preschool to svy21 using st_transform.\n\npreschool3414 <- st_transform(preschool, crs = 3414)\n\nNow we can inspect the geometry of preschool3414, which is now projected in svy21 coordinate system.\n\nst_geometry(preschool3414)\n\nGeometry set for 1359 features \nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 11203.01 ymin: 25667.6 xmax: 45404.24 ymax: 49300.88\nz_range:       zmin: 0 zmax: 0\nProjected CRS: SVY21 / Singapore TM\nFirst 5 geometries:\n\n\nPOINT Z (19997.26 32333.17 0)\n\n\nPOINT Z (19126.75 33114.35 0)\n\n\nPOINT Z (20345.12 31934.56 0)\n\n\nPOINT Z (20400.31 31952.36 0)\n\n\nPOINT Z (19810.78 33140.31 0)\n\n\n\nNotes: in Bounding box, the values are greater than 0-360 range of decimal degree commonly used by most of the geographic coordinate systems.\n\n\n\n\n\n\n\nBecause the listings dataset is in the csv format, we use the read.csv() function to import the data into an object called listings, which is a tibble data frame.\n\nlistings <- read.csv(\"data/aspatial/listings.csv\")\n\nTo inspect the data set, instead of using glimpse, now we use list because of the object type.\n\noptions(max.print = 10)\nlist(listings)\n\n[[1]]\n     id name host_id host_name neighbourhood_group neighbourhood latitude\n     longitude room_type price minimum_nights number_of_reviews last_review\n     reviews_per_month calculated_host_listings_count availability_365\n [ reached 'max' / getOption(\"max.print\") -- omitted 4252 rows ]\n\n\nWe can see that listings has 4,252 rows and 16 columns. We are going to use latitude and longitude.\n\nNote that they are in decimal degree format. As a best guess, we will assume that the data is in wgs84 Geographic Coordinate System.\n\n\n\n\nWe now convert listings into a simple feature data frame using st_as_sf().\n\nlistings_sf <- st_as_sf(listings, coords = c(\"longitude\", \"latitude\"), crs = 4326) %>%\n  st_transform(crs = 3414)\n\nNotes\n\n\ncoords argument requires you to provide the column name of the x-coordinates first then followed by the column name of the y-coordinates.\ncrs argument requires you to provide the coordinates system in epsg format. EPSG: 4326 is wgs84 Geographic Coordinate System and EPSG: 3414 is Singapore SVY21 Projected Coordinate System. You can search for other country’s epsg code by referring to epsg.io.\n%>% is used to nest st_transform() to transform the newly created simple feature data frame into svy21 projected coordinates system.\n\n\nAfter the transformation, we can examine the new object listings_sf using glimpse.\n\nglimpse(listings_sf)\n\nRows: 4,252\nColumns: 15\n$ id                             <int> 50646, 71609, 71896, 71903, 275343, 275…\n$ name                           <chr> \"Pleasant Room along Bukit Timah\", \"Ens…\n$ host_id                        <int> 227796, 367042, 367042, 367042, 1439258…\n$ host_name                      <chr> \"Sujatha\", \"Belinda\", \"Belinda\", \"Belin…\n$ neighbourhood_group            <chr> \"Central Region\", \"East Region\", \"East …\n$ neighbourhood                  <chr> \"Bukit Timah\", \"Tampines\", \"Tampines\", …\n$ room_type                      <chr> \"Private room\", \"Private room\", \"Privat…\n$ price                          <int> 80, 178, 81, 81, 52, 40, 72, 41, 49, 49…\n$ minimum_nights                 <int> 90, 90, 90, 90, 14, 14, 90, 8, 14, 14, …\n$ number_of_reviews              <int> 18, 20, 24, 48, 20, 13, 133, 105, 14, 1…\n$ last_review                    <chr> \"2014-07-08\", \"2019-12-28\", \"2014-12-10…\n$ reviews_per_month              <dbl> 0.22, 0.28, 0.33, 0.67, 0.20, 0.16, 1.2…\n$ calculated_host_listings_count <int> 1, 4, 4, 4, 50, 50, 7, 1, 50, 50, 50, 4…\n$ availability_365               <int> 365, 365, 365, 365, 353, 364, 365, 90, …\n$ geometry                       <POINT [m]> POINT (22646.02 35167.9), POINT (…\n\n\n\n\n\n\n\n\nThe scenario\nThe authority is planning to upgrade the exiting cycling path. To do so, they need to acquire 5 metres of reserved land on the both sides of the current cycling path. You are tasked to determine the extend of the land need to be acquired and their total area.\nSolution\nCompute the 5-meter buffers around cycling paths\n\nbuffer_cycling <- st_buffer(cyclingpath, dist = 5, nQuadSegs = 30)\n\nCalculate the area of the buffers as shown in the code chunk below.\n\nbuffer_cycling$AREA <- st_area(buffer_cycling)\n\nLastly, sum() of Base R will be used to derive the total land involved.\n\nsum(buffer_cycling$AREA)\n\n773143.9 [m^2]\n\n\n\n\n\nThe scenario\nA pre-school service group want to find out the numbers of pre-schools in each Planning Subzone.\nThe solution\nThe code chunk below performs two operations at one go. Firstly, identify pre-schools located inside each Planning Subzone by using st_intersects(). Next, length() of Base R is used to calculate numbers of pre-schools that fall inside each planning subzone.\n\nmpsz3414$`PreSch Count` <- lengths(st_intersects(mpsz3414, preschool3414))\n\nNow we check the new PreSch Count field.\n\nsummary(mpsz3414$`PreSch Count`)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  0.000   0.000   2.000   4.207   6.000  37.000 \n\n\nTo list the planning subzone with the most number of pre-school, the top_n() of dplyr package is used as shown in the code chunk below.\n\ntop_n(mpsz3414, 1, `PreSch Count`)\n\nSimple feature collection with 1 feature and 16 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 23449.05 ymin: 46001.23 xmax: 25594.22 ymax: 47996.47\nProjected CRS: SVY21 / Singapore TM\n     OBJECTID SUBZONE_NO SUBZONE_N SUBZONE_C CA_IND PLN_AREA_N PLN_AREA_C\n     REGION_N REGION_C INC_CRC FMEL_UPD_D X_ADDR Y_ADDR SHAPE_Leng SHAPE_Area\n     geometry PreSch Count\n [ reached 'max' / getOption(\"max.print\") -- omitted 1 rows ]\n\n\n\n\n\nFirstly, the code chunk below uses st_area() of sf package to derive the area of each planning subzone.\n\nmpsz3414$Area <- mpsz3414 %>%\n  st_area()\n\nNext, mutate() of dplyr package is used to compute the density by using the code chunk below.\n\nmpsz3414 <- mpsz3414 %>%\n  mutate(`PreSch Density` = `PreSch Count`/Area * 1000000)\n\nResults\n\nsummary(mpsz3414$`PreSch Density`)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  0.000   0.000   2.974   4.076   6.609  29.059 \n\n\n\ntop_n(mpsz3414, 1, `PreSch Density`)\n\nSimple feature collection with 1 feature and 18 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 28896.26 ymin: 28339.16 xmax: 29426.66 ymax: 28685.25\nProjected CRS: SVY21 / Singapore TM\n\n\nWarning in format.data.frame(if (omit) x[seq_len(n0), , drop = FALSE] else x, :\ncorrupt data frame: columns will be truncated or padded with NAs\n\n\n     OBJECTID SUBZONE_NO SUBZONE_N SUBZONE_C CA_IND PLN_AREA_N PLN_AREA_C\n     REGION_N REGION_C INC_CRC FMEL_UPD_D X_ADDR Y_ADDR SHAPE_Leng SHAPE_Area\n     geometry PreSch Count Area PreSch Density\n [ reached 'max' / getOption(\"max.print\") -- omitted 1 rows ]\n\n\n\n\n\n\nFirstly, we will plot a histogram to reveal the distribution of PreSch Density. Conventionally, hist() of R Graphics will be used as shown in the code chunk below.\n\nhist(mpsz3414$`PreSch Density`, main = \"Histogram of School Density\", xlab = \"School Density\")\n\n\n\n\nIn the code chunk below, appropriate ggplot2 functions will be used.\n\nggplot(data=mpsz3414, \n       aes(x= as.numeric(`PreSch Density`)))+\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  labs(title = \"Are pre-school even distributed in Singapore?\",\n       subtitle= \"There are many planning sub-zones with a single pre-school, on the other hand, \\nthere are two planning sub-zones with at least 20 pre-schools\",\n      x = \"Pre-school density (per km sq)\",\n      y = \"Frequency\")\n\n\n\n\n\n\n\nggplot(data = mpsz3414,\n       aes(x = as.numeric(`PreSch Density`), y = as.numeric(`PreSch Count`))) +\n  geom_point() +\n  labs(x = \"Pre-school Density (per km square)\",\n       y = \"Pre-school Count\")"
  },
  {
    "objectID": "Hands-on_Ex01.html#getting-started",
    "href": "Hands-on_Ex01.html#getting-started",
    "title": "Hands-on Exercise 1: Geospatial Wrangling with R",
    "section": "Getting Started",
    "text": "Getting Started\nThe code chunk below installs and loads sf and tidyverse.\nNotes: Make sure you imported the pacman package before running the code below.\n\npacman::p_load(sf, tidyverse)"
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#getting-started",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#getting-started",
    "title": "Hands-on Exercise 1: Geospatial Wrangling with R",
    "section": "Getting Started",
    "text": "Getting Started\nThe code chunk below installs and loads sf and tidyverse.\nNotes: Make sure you imported the pacman package before running the code below.\n\npacman::p_load(sf, tidyverse)"
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#import-geospatial-data",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#import-geospatial-data",
    "title": "Hands-on Exercise 1: Geospatial Wrangling with R",
    "section": "Import Geospatial Data",
    "text": "Import Geospatial Data\nBefore importing anything, download the data zip file(s), unzip, and put them into the folder inside the directory of your page. Then create a Quarto document within that folder. The Quarto document and the data files need to be in the same folder, or you need to clarify the path to the data file while running the code below.\n\nImport polygon feature data\nNotes: You need to save your working R document as an qmd file before you can run the code below.\n\nmpsz <- st_read(dsn = \"data/geospatial\", layer = \"MP14_SUBZONE_WEB_PL\")\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/Hands-on_Ex01/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\n\n\n\nImport polyline feature data\nRun the code chunk below.\n\ncyclingpath <- st_read(dsn = \"data/geospatial\", layer = \"CyclingPath\")\n\nReading layer `CyclingPath' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/Hands-on_Ex01/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 1625 features and 2 fields\nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: 12711.19 ymin: 28711.33 xmax: 42626.09 ymax: 48948.15\nProjected CRS: SVY21\n\n\n\n\nImport GIS data in kml format\nRun the code chunk below.\n\npreschool <- st_read(\"data/geospatial/pre-schools-location-kml.kml\")\n\nReading layer `PRESCHOOLS_LOCATION' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/Hands-on_Ex01/data/geospatial/pre-schools-location-kml.kml' \n  using driver `KML'\nSimple feature collection with 1359 features and 2 fields\nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6824 ymin: 1.248403 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84"
  },
  {
    "objectID": "Hands-on_Ex01.html#import-geospatial-data",
    "href": "Hands-on_Ex01.html#import-geospatial-data",
    "title": "Hands-on Exercise 1: Geospatial Wrangling with R",
    "section": "Import Geospatial Data",
    "text": "Import Geospatial Data\n\nImport polygon feature data\nNotes: You need to save your working R document as an qmd file before you can run the code below.\n\nmpsz <- st_read(dsn = \"Hands-on_Ex01/data/geospatial\", layer = \"MP14_SUBZONE_WEB_PL\")\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/Hands-on_Ex01/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21"
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#checking-data-frame-content",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#checking-data-frame-content",
    "title": "Hands-on Exercise 1: Geospatial Wrangling with R",
    "section": "Checking Data Frame Content",
    "text": "Checking Data Frame Content\n\nWorking with st_geometry()\nThe type of geometry is multipolygon.\n\nst_geometry(mpsz)\n\nGeometry set for 323 features \nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\nFirst 5 geometries:\n\n\nMULTIPOLYGON (((31495.56 30140.01, 31980.96 296...\n\n\nMULTIPOLYGON (((29092.28 30021.89, 29119.64 300...\n\n\nMULTIPOLYGON (((29932.33 29879.12, 29947.32 298...\n\n\nMULTIPOLYGON (((27131.28 30059.73, 27088.33 297...\n\n\nMULTIPOLYGON (((26451.03 30396.46, 26440.47 303...\n\n\n\n\nWorking with glimpse()\nGlimpse display a sneak peek into the data type and values of the variables. Notice that X_ADDR and Y_ADDR are double type. There are other types like character, integer, and date.\n\nglimpse(mpsz)\n\nRows: 323\nColumns: 16\n$ OBJECTID   <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, …\n$ SUBZONE_NO <int> 1, 1, 3, 8, 3, 7, 9, 2, 13, 7, 12, 6, 1, 5, 1, 1, 3, 2, 2, …\n$ SUBZONE_N  <chr> \"MARINA SOUTH\", \"PEARL'S HILL\", \"BOAT QUAY\", \"HENDERSON HIL…\n$ SUBZONE_C  <chr> \"MSSZ01\", \"OTSZ01\", \"SRSZ03\", \"BMSZ08\", \"BMSZ03\", \"BMSZ07\",…\n$ CA_IND     <chr> \"Y\", \"Y\", \"Y\", \"N\", \"N\", \"N\", \"N\", \"Y\", \"N\", \"N\", \"N\", \"N\",…\n$ PLN_AREA_N <chr> \"MARINA SOUTH\", \"OUTRAM\", \"SINGAPORE RIVER\", \"BUKIT MERAH\",…\n$ PLN_AREA_C <chr> \"MS\", \"OT\", \"SR\", \"BM\", \"BM\", \"BM\", \"BM\", \"SR\", \"QT\", \"QT\",…\n$ REGION_N   <chr> \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENT…\n$ REGION_C   <chr> \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\",…\n$ INC_CRC    <chr> \"5ED7EB253F99252E\", \"8C7149B9EB32EEFC\", \"C35FEFF02B13E0E5\",…\n$ FMEL_UPD_D <date> 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05…\n$ X_ADDR     <dbl> 31595.84, 28679.06, 29654.96, 26782.83, 26201.96, 25358.82,…\n$ Y_ADDR     <dbl> 29220.19, 29782.05, 29974.66, 29933.77, 30005.70, 29991.38,…\n$ SHAPE_Leng <dbl> 5267.381, 3506.107, 1740.926, 3313.625, 2825.594, 4428.913,…\n$ SHAPE_Area <dbl> 1630379.27, 559816.25, 160807.50, 595428.89, 387429.44, 103…\n$ geometry   <MULTIPOLYGON [m]> MULTIPOLYGON (((31495.56 30..., MULTIPOLYGON (…\n\n\n\n\nWorking with head()\nUse n = … to select the number of records to display. Head gives a look at the first few rows of the data frame.\n\nhead(mpsz, n = 5)\n\nSimple feature collection with 5 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 25867.68 ymin: 28369.47 xmax: 32362.39 ymax: 30435.54\nProjected CRS: SVY21\n  OBJECTID SUBZONE_NO      SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N\n1        1          1   MARINA SOUTH    MSSZ01      Y    MARINA SOUTH\n2        2          1   PEARL'S HILL    OTSZ01      Y          OUTRAM\n3        3          3      BOAT QUAY    SRSZ03      Y SINGAPORE RIVER\n4        4          8 HENDERSON HILL    BMSZ08      N     BUKIT MERAH\n5        5          3        REDHILL    BMSZ03      N     BUKIT MERAH\n  PLN_AREA_C       REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1         MS CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84\n2         OT CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06\n3         SR CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96\n4         BM CENTRAL REGION       CR 3775D82C5DDBEFBD 2014-12-05 26782.83\n5         BM CENTRAL REGION       CR 85D9ABEF0A40678F 2014-12-05 26201.96\n    Y_ADDR SHAPE_Leng SHAPE_Area                       geometry\n1 29220.19   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...\n2 29782.05   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...\n3 29974.66   1740.926   160807.5 MULTIPOLYGON (((29932.33 29...\n4 29933.77   3313.625   595428.9 MULTIPOLYGON (((27131.28 30...\n5 30005.70   2825.594   387429.4 MULTIPOLYGON (((26451.03 30..."
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#plotting-the-geopspatial-data",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#plotting-the-geopspatial-data",
    "title": "Hands-on Exercise 1: Geospatial Wrangling with R",
    "section": "Plotting The Geopspatial Data",
    "text": "Plotting The Geopspatial Data\nWith geospatial data, we can use the plot() function to display them as visual elements. We can use max.plot = … to define the number of plots shown. This data set has 15 plots at the maximum but we only sketch 9 plots here, hence max.plot = 9.\n\nplot(mpsz, max.plot = 9)\n\n\n\n\nWe can choose to plot just one plot using the code chunk below. This is the plot of the sf object, which is the frame of all plots.\n\nplot(st_geometry(mpsz))\n\n\n\n\nOr we can plot and view a specific attribute.\n\nplot(mpsz[\"PLN_AREA_N\"])\n\n\n\n\n\nNotes: plot is only used for a quickly. For high cartographic quality plot, use tmap R package."
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#working-with-projection",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#working-with-projection",
    "title": "Hands-on Exercise 1: Geospatial Wrangling with R",
    "section": "Working with Projection",
    "text": "Working with Projection\nWhen we want to project two or more geospatial data sets, it is important to ensure the data sets are projected under the same coordinate system. Projection Transformation is the method of projecting a data frame from one coordinate system to another.\n\nAssign EPSG code to a data frame\nIssues to notice: missing coordination or wrongly assigned coordination due to the importing process.\nUsing the code chunk below, we can see the coordinate system of mpsz.\n\nst_crs(mpsz)\n\nCoordinate Reference System:\n  User input: SVY21 \n  wkt:\nPROJCRS[\"SVY21\",\n    BASEGEOGCRS[\"SVY21[WGS84]\",\n        DATUM[\"World Geodetic System 1984\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ID[\"EPSG\",6326]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"Degree\",0.0174532925199433]]],\n    CONVERSION[\"unnamed\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]\n\n\n\nNotice the User input says the data is projected in svy21, but the EPSG code is 9001. This is a wrong EPSG code because the EPSG code for svy21 should be 3414.\n\nWe now assign the correct EPSG code using the code below.\n\nmpsz3414 <- st_set_crs(mpsz, 3414)\n\nWarning: st_crs<- : replacing crs does not reproject data; use st_transform for\nthat\n\n\nR warns us that st_crs does not reproject data. While this is true in case we want to do projection transformation, here we simply want to fix the EPSG code. Therefore, reprojection is not necessary and we can proceed with checking the EPSG of mpsz3414, which shows the correct EPSG code.\n\nst_crs(mpsz3414)\n\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n\n\n\n\nTransform the projection of preschool from wgs84 to svy21\nNow we inspect the geometry of preschool. It is clear that preschool is projected in the WGS84 coordinate system.\n\nst_geometry(preschool)\n\nGeometry set for 1359 features \nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6824 ymin: 1.248403 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\nFirst 5 geometries:\n\n\nPOINT Z (103.7614 1.308683 0)\n\n\nPOINT Z (103.7536 1.315748 0)\n\n\nPOINT Z (103.7645 1.305078 0)\n\n\nPOINT Z (103.765 1.305239 0)\n\n\nPOINT Z (103.7597 1.315983 0)\n\n\nWe will transform the projection of preschool to svy21 using st_transform.\n\npreschool3414 <- st_transform(preschool, crs = 3414)\n\nNow we can inspect the geometry of preschool3414, which is now projected in svy21 coordinate system.\n\nst_geometry(preschool3414)\n\nGeometry set for 1359 features \nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 11203.01 ymin: 25667.6 xmax: 45404.24 ymax: 49300.88\nz_range:       zmin: 0 zmax: 0\nProjected CRS: SVY21 / Singapore TM\nFirst 5 geometries:\n\n\nPOINT Z (19997.26 32333.17 0)\n\n\nPOINT Z (19126.75 33114.35 0)\n\n\nPOINT Z (20345.12 31934.56 0)\n\n\nPOINT Z (20400.31 31952.36 0)\n\n\nPOINT Z (19810.78 33140.31 0)\n\n\n\nNotes: in Bounding box, the values are greater than 0-360 range of decimal degree commonly used by most of the geographic coordinate systems."
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#importing-and-converting-an-aspatial-data",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#importing-and-converting-an-aspatial-data",
    "title": "Hands-on Exercise 1: Geospatial Wrangling with R",
    "section": "Importing and Converting an Aspatial Data",
    "text": "Importing and Converting an Aspatial Data\n\nImport aspatial data\nBecause the listings dataset is in the csv format, we use the read.csv() function to import the data into an object called listings, which is a tibble data frame.\n\nlistings <- read.csv(\"data/aspatial/listings.csv\")\n\nTo inspect the data set, instead of using glimpse, now we use list because of the object type.\n\noptions(max.print = 5)\nlist(listings)\n\n[[1]]\n     id name host_id host_name neighbourhood_group neighbourhood latitude\n     longitude room_type price minimum_nights number_of_reviews last_review\n     reviews_per_month calculated_host_listings_count availability_365\n [ reached 'max' / getOption(\"max.print\") -- omitted 4252 rows ]\n\n\nWe can see that listings has 4,252 rows and 16 columns. We are going to use latitude and longitude.\n\nNote that they are in decimal degree format. As a best guess, we will assume that the data is in wgs84 Geographic Coordinate System.\n\n\n\nCreate a simple feature data frame\nWe now convert listings into a simple feature data frame using st_as_sf().\n\nlistings_sf <- st_as_sf(listings, coords = c(\"longitude\", \"latitude\"), crs = 4326) %>%\n  st_transform(crs = 3414)\n\nNotes\n\n\ncoords argument requires you to provide the column name of the x-coordinates first then followed by the column name of the y-coordinates.\ncrs argument requires you to provide the coordinates system in epsg format. EPSG: 4326 is wgs84 Geographic Coordinate System and EPSG: 3414 is Singapore SVY21 Projected Coordinate System. You can search for other country’s epsg code by referring to epsg.io.\n%>% is used to nest st_transform() to transform the newly created simple feature data frame into svy21 projected coordinates system.\n\n\nAfter the transformation, we can examine the new object listings_sf using glimpse.\n\nglimpse(listings_sf)\n\nRows: 4,252\nColumns: 15\n$ id                             <int> 50646, 71609, 71896, 71903, 275343, 275…\n$ name                           <chr> \"Pleasant Room along Bukit Timah\", \"Ens…\n$ host_id                        <int> 227796, 367042, 367042, 367042, 1439258…\n$ host_name                      <chr> \"Sujatha\", \"Belinda\", \"Belinda\", \"Belin…\n$ neighbourhood_group            <chr> \"Central Region\", \"East Region\", \"East …\n$ neighbourhood                  <chr> \"Bukit Timah\", \"Tampines\", \"Tampines\", …\n$ room_type                      <chr> \"Private room\", \"Private room\", \"Privat…\n$ price                          <int> 80, 178, 81, 81, 52, 40, 72, 41, 49, 49…\n$ minimum_nights                 <int> 90, 90, 90, 90, 14, 14, 90, 8, 14, 14, …\n$ number_of_reviews              <int> 18, 20, 24, 48, 20, 13, 133, 105, 14, 1…\n$ last_review                    <chr> \"2014-07-08\", \"2019-12-28\", \"2014-12-10…\n$ reviews_per_month              <dbl> 0.22, 0.28, 0.33, 0.67, 0.20, 0.16, 1.2…\n$ calculated_host_listings_count <int> 1, 4, 4, 4, 50, 50, 7, 1, 50, 50, 50, 4…\n$ availability_365               <int> 365, 365, 365, 365, 353, 364, 365, 90, …\n$ geometry                       <POINT [m]> POINT (22646.02 35167.9), POINT (…"
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#geoprocessing-with-sf-package",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#geoprocessing-with-sf-package",
    "title": "Hands-on Exercise 1: Geospatial Wrangling with R",
    "section": "Geoprocessing with SF package",
    "text": "Geoprocessing with SF package\n\nBuffering\nThe scenario\nThe authority is planning to upgrade the exiting cycling path. To do so, they need to acquire 5 metres of reserved land on the both sides of the current cycling path. You are tasked to determine the extend of the land need to be acquired and their total area.\nSolution\nCompute the 5-meter buffers around cycling paths\n\nbuffer_cycling <- st_buffer(cyclingpath, dist = 5, nQuadSegs = 30)\n\nCalculate the area of the buffers as shown in the code chunk below.\n\nbuffer_cycling$AREA <- st_area(buffer_cycling)\n\nLastly, sum() of Base R will be used to derive the total land involved.\n\nsum(buffer_cycling$AREA)\n\n773143.9 [m^2]\n\n\n\n\nPoint-in-polygon count\nThe scenario\nA pre-school service group want to find out the numbers of pre-schools in each Planning Subzone.\nThe solution\nThe code chunk below performs two operations at one go. Firstly, identify pre-schools located inside each Planning Subzone by using st_intersects(). Next, length() of Base R is used to calculate numbers of pre-schools that fall inside each planning subzone.\n\nmpsz3414$`PreSch Count` <- lengths(st_intersects(mpsz3414, preschool3414))\n\nNow we check the new PreSch Count field.\n\nsummary(mpsz3414$`PreSch Count`)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  0.000   0.000   2.000   4.207   6.000  37.000 \n\n\nTo list the planning subzone with the most number of pre-school, the top_n() of dplyr package is used as shown in the code chunk below.\n\ntop_n(mpsz3414, 1, `PreSch Count`)\n\nSimple feature collection with 1 feature and 16 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 23449.05 ymin: 46001.23 xmax: 25594.22 ymax: 47996.47\nProjected CRS: SVY21 / Singapore TM\n     OBJECTID SUBZONE_NO SUBZONE_N SUBZONE_C CA_IND PLN_AREA_N PLN_AREA_C\n     REGION_N REGION_C INC_CRC FMEL_UPD_D X_ADDR Y_ADDR SHAPE_Leng SHAPE_Area\n     geometry PreSch Count\n [ reached 'max' / getOption(\"max.print\") -- omitted 1 rows ]\n\n\n\n\nCalculate the density of pre-school by planning subzone\nFirstly, the code chunk below uses st_area() of sf package to derive the area of each planning subzone.\n\nmpsz3414$Area <- mpsz3414 %>%\n  st_area()\n\nNext, mutate() of dplyr package is used to compute the density by using the code chunk below.\n\nmpsz3414 <- mpsz3414 %>%\n  mutate(`PreSch Density` = `PreSch Count`/Area * 1000000)\n\nResults\n\nsummary(mpsz3414$`PreSch Density`)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  0.000   0.000   2.974   4.076   6.609  29.059 \n\n\n\ntop_n(mpsz3414, 1, `PreSch Density`)\n\nSimple feature collection with 1 feature and 18 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 28896.26 ymin: 28339.16 xmax: 29426.66 ymax: 28685.25\nProjected CRS: SVY21 / Singapore TM\n\n\nWarning in format.data.frame(if (omit) x[seq_len(n0), , drop = FALSE] else x, :\ncorrupt data frame: columns will be truncated or padded with NAs\n\n\n     OBJECTID SUBZONE_NO SUBZONE_N SUBZONE_C CA_IND PLN_AREA_N PLN_AREA_C\n     REGION_N REGION_C INC_CRC FMEL_UPD_D X_ADDR Y_ADDR SHAPE_Leng SHAPE_Area\n     geometry PreSch Count Area PreSch Density\n [ reached 'max' / getOption(\"max.print\") -- omitted 1 rows ]"
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#exploratory-data-analysis",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#exploratory-data-analysis",
    "title": "Hands-on Exercise 1: Geospatial Wrangling with R",
    "section": "Exploratory Data Analysis",
    "text": "Exploratory Data Analysis\nFirstly, we will plot a histogram to reveal the distribution of PreSch Density. Conventionally, hist() of R Graphics will be used as shown in the code chunk below.\n\nhist(mpsz3414$`PreSch Density`, main = \"Histogram of School Density\", xlab = \"School Density\")\n\n\n\n\nIn the code chunk below, appropriate ggplot2 functions will be used.\n\nggplot(data=mpsz3414, \n       aes(x= as.numeric(`PreSch Density`)))+\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  labs(title = \"Are pre-school even distributed in Singapore?\",\n       subtitle= \"There are many planning sub-zones with a single pre-school, on the other hand, \\nthere are two planning sub-zones with at least 20 pre-schools\",\n      x = \"Pre-school density (per km sq)\",\n      y = \"Frequency\")\n\n\n\n\n\nRelationship between Pre-school Density and Pre-school Count\n\nggplot(data = mpsz3414,\n       aes(x = as.numeric(`PreSch Density`), y = as.numeric(`PreSch Count`))) +\n  geom_point() +\n  labs(x = \"Pre-school Density (per km square)\",\n       y = \"Pre-school Count\")"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex1/In-class_ex1.html",
    "href": "In-class_Ex/In-class_Ex1/In-class_ex1.html",
    "title": "Spatial Weight and Applications",
    "section": "",
    "text": "The code chunk below will install and load tidyverse and sf package.\n\npacman::p_load(sf, tidyverse)\n\nThen we load tmap.\n\nlibrary(tmap)"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex1/In-class_ex1.html#getting-started",
    "href": "In-class_Ex/In-class_Ex1/In-class_ex1.html#getting-started",
    "title": "In-class Exercise",
    "section": "Getting Started",
    "text": "Getting Started\nThe code chunk below will install and load tidyverse and sf package.\n\npacman::p_load(sf, tidyverse)"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex1/In-class_ex1.html#import-geospatial-data",
    "href": "In-class_Ex/In-class_Ex1/In-class_ex1.html#import-geospatial-data",
    "title": "Spatial Weight and Applications",
    "section": "Import Geospatial Data",
    "text": "Import Geospatial Data\n\nImporting polygon features\nThis code chunk will import ESRI shapefile into R.\n\nhunan <- st_read(dsn = \"dataC/geospatial\", layer = \"Hunan\")\n\nReading layer `Hunan' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/In-class_Ex/In-class_Ex1/dataC/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n\n\n\n\nImporting attribute data in csv\n\nhunan2012 <- read_csv(\"dataC/aspatial/Hunan_2012.csv\", show_col_types = FALSE)\n\n\n\nPerforming Relational Join\n\nhunan <- left_join(hunan,hunan2012)\n\nJoining, by = \"County\""
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#overview-1",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#overview-1",
    "title": "Hands-on Exercise 1: Geospatial Wrangling and Choropleth Mapping with R",
    "section": "Overview",
    "text": "Overview\nChoropleth map is a map showing different colors depending on the value of the attribute that the map is presenting. For example, a map showing population density have different colors for each areas with varying levels of population density."
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#getting-started-1",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#getting-started-1",
    "title": "Hands-on Exercise 1: Geospatial Wrangling and Choropleth Mapping with R",
    "section": "Getting Started",
    "text": "Getting Started\nThis exercise will use the tmap R package and four other R packages.\n\nreadr for importing delimited text file,\ntidyr for tidying data,\ndplyr for wrangling data and\nsf for handling geospatial data.\n\nFirst, we load the packages into R Studio.\n\npacman::p_load(sf, tmap, tidyverse)"
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#importing-data-into-r",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#importing-data-into-r",
    "title": "Hands-on Exercise 1: Geospatial Wrangling and Choropleth Mapping with R",
    "section": "Importing Data into R",
    "text": "Importing Data into R\n\nImporting Geospatial Data into R\nSince we already imported and inspected the MP4_SUBZONE_WEB_PL shapefile as mpsz, we can skip this step.\n\n\nImporting Attribute Data into R\n\npopdata <- read_csv('~/sylvie-le/ISSS624/Hands-on_Ex01/data/aspatial/respopagesextod2011to2020.csv')\n\nRows: 984656 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): PA, SZ, AG, Sex, TOD\ndbl (2): Pop, Time\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\n\nData Preparation\n\n\nWe need to prepare a data table with the necessary data points as below.\n\nYOUNG: age group 0 to 4 until age groyup 20 to 24,\nECONOMY ACTIVE: age group 25-29 until age group 60-64,\nAGED: age group 65 and above,\nTOTAL: all age group, and\nDEPENDENCY: the ratio between young and aged against economy active group\n\n\nData Wrangling\nThe functions below is used to wrangle the data as defined above.\n\npopdata2020 <- popdata %>%\n  filter(Time == 2020) %>%\n  group_by(PA, SZ, AG) %>%\n  summarise(`POP` = sum(`Pop`)) %>%\n  ungroup()%>%\n  pivot_wider(names_from=AG, \n              values_from=POP) %>%\n  mutate(YOUNG = rowSums(.[3:6])\n         +rowSums(.[12])) %>%\nmutate(`ECONOMY ACTIVE` = rowSums(.[7:11])+\nrowSums(.[13:15]))%>%\nmutate(`AGED`=rowSums(.[16:21])) %>%\nmutate(`TOTAL`=rowSums(.[3:21])) %>%  \nmutate(`DEPENDENCY` = (`YOUNG` + `AGED`)\n/`ECONOMY ACTIVE`) %>%\n  select(`PA`, `SZ`, `YOUNG`, \n       `ECONOMY ACTIVE`, `AGED`, \n       `TOTAL`, `DEPENDENCY`)\n\n`summarise()` has grouped output by 'PA', 'SZ'. You can override using the\n`.groups` argument.\n\n\n\n\nJoining the attribute data and geospatial data\nBefore we can perform the georelational join, one extra step is required to convert the values in PA and SZ fields to uppercase. This is because the values of PA and SZ fields are made up of upper- and lowercase. On the other, hand the SUBZONE_N and PLN_AREA_N are in uppercase.\nSince funs() was deprecated, we use list() instead.\n\npopdata2020 <- popdata2020 %>%\n  mutate_at(.vars = vars(PA, SZ), \n          .funs = list(toupper)) %>%\n  filter(`ECONOMY ACTIVE` > 0)\n\nAfter that, we conduct a left join of the data using left_join() , to ensure the output to be simple features data frame.\n\nmpsz_pop2020 <- left_join(mpsz, popdata2020,\n                          by = c(\"SUBZONE_N\" = \"SZ\"))\n\nNow we save the new file after creating a new folder called rds in data folder.\n\nwrite_rds(mpsz_pop2020, \"~/sylvie-le/ISSS624/Hands-on_Ex01/data/rds/mpszpop2020.rds\")"
  },
  {
    "objectID": "Hands-on_Ex01/Hands-on_Ex01.html#choropleth-mapping-geospatial-data-using-tmap",
    "href": "Hands-on_Ex01/Hands-on_Ex01.html#choropleth-mapping-geospatial-data-using-tmap",
    "title": "Hands-on Exercise 1: Geospatial Wrangling and Choropleth Mapping with R",
    "section": "Choropleth Mapping Geospatial Data Using tmap",
    "text": "Choropleth Mapping Geospatial Data Using tmap\nTwo approaches can be used to prepare thematic map using tmap, they are:\n\nPlotting a thematic map quickly by using qtm().\nPlotting highly customisable thematic map by using tmap elements.\n\n\nMethod 1: Plotting using qtm()\n\ntmap_mode(mode = \"plot\")\n\ntmap mode set to plotting\n\nqtm(mpsz_pop2020, \n    fill = \"DEPENDENCY\")\n\n\n\n\nNotes\n\n\ntmap_mode() with “plot” option is used to produce a static map. For interactive mode, “view” option should be used.\nfill argument is used to map the attribute (i.e. DEPENDENCY)\n\n\n\n\nMethod 2: Creating a choropleth map by using tmap’s elements\nWhile being convenient and short, qtm() does not allow for drawing maps with high cartographic quality. To overcome qtm()’s disadvantage, we can use tmap’s elements.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\",\n          title = \"Dependency ratio\") +\n  tm_layout(main.title = \"Distribution of Dependency Ratio by planning subzone\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar() +\n  tm_grid(alpha =0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\\n and Population data from Department of Statistics DOS\", \n             position = c(\"left\", \"bottom\"))\n\n\n\n\nNext, let’s look at the code and draw the map step by step to understand how each element works.\n\nDrawing a base map\nThe building block of tmap is tm_shape(), which is followed by elements such as tm_fill() and tm_polygons(). We will use tm_polygons() as it allows us to fill the polygons with color as tm_fill() does, and also let us draw the border of the polygons as tm_border().\n\ntm_shape(mpsz_pop2020) +\n  tm_polygons()\n\n\n\n\n\n\nDrawing a choropleth map using tm_polygons()\nNext, we will define how the colors are filled into the map by letting tm_polygons() know the criteria to fill. In this case, the criteria is the variable DEPENDENCY.\n\ntm_shape(mpsz_pop2020)+\n  tm_polygons(\"DEPENDENCY\")\n\n\n\n\nNotes\n\n\nThe default binning to draw the choropleth map is called “pretty”. Refer to sub-section 4.3 for more details.\nThe default color scheme is YlOrRd. Refer to sub-section 4.4 for more details of color schemes.\nBy default, Missing value is filled with gray.\n\n\n\n\nDrawing a choropleth map using tm_fill() and tm_border()\nInstead of using tm_polygons(), we can use tm_fill() and tm_border() instead. The code will be longer but if some day we like to type more, we can opt for this option.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\")\n\n\n\n\nWith just tm_fill(), the map is drawn without the borders between the areas. To add the borders, we combine the code chunk above with tm_borders().\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\") +\n  tm_borders(lwd = 0.1,  alpha = 1)\n\n\n\n\nObserving the map, we see that the border thickness are different that what we achieved with tm_polygons(). This suggests that we can customize border thickness with tm_borders().\nThe argument to customize borders are at below.\n\n\ncol = border colour,\nlwd = border line width. The default is 1, and\nlty = border line type. The default is “solid”.\n\n\n\n\n\nData classification methods of tmap\nData classification is to group a large numbers of observations into ranges or classes. It helps us to better describe the data and present the information we want to highlight, besides other roles.\ntmap provides a total ten data classification methods, namely: fixed, sd, equal, pretty (default), quantile, kmeans, hclust, bclust, fisher, and jenks. Refer to R documentations details on the methods.\nTo define a data classification method, the style argument of tm_fill() or tm_polygons() will be used.\n\nPlotting choropleth maps with built-in classification methods\nUse n = 5 as in the code chunk below to classify the data into 5 classes.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\nThe code below classifies the data using equal classification method.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\nNotice that the distribution of quantile data classification method are more evenly distributed then equal data classification method.\nNext, we will use all of the classification methods and compare the results.\n\nMap Comparison\n\nm1 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"sd\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"SD\")\nm2 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Equal\")\nm3 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"pretty\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Pretty\")\nm4 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Quantile\")\nm5 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"kmeans\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Kmeans\")\nm6 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"hclust\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Hclust\")\nm7 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"bclust\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Bclust\")\nm8 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"fisher\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Fisher\")\nm9 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Jenks\")\n\ntmap_arrange(m1, m2, asp=1, ncol=2)\n\n\n\ntmap_arrange(m3, m4, asp=1, ncol=2)\n\n\n\ntmap_arrange(m5, m6, asp=1, ncol=2)\n\n\n\ntmap_arrange(m7, m8, asp=1, ncol=2)\n\n\n\n\nCommittee Member: 1(1) 2(1) 3(1) 4(1) 5(1) 6(1) 7(1) 8(1) 9(1) 10(1)\nComputing Hierarchical Clustering\n\ntmap_arrange(m9, asp=1, ncol=2)\n\n\n\n\nEach data classification methods provide a different representation of the data. Therefore, we should consider which classification method to best presenting the data, and which classification methods are meaningful to the data. Data presentation can be misleading if we don’t choose carefully.\n\n\n\nPlotting choropleth map with custome break\nFor all the built-in styles, the category breaks are computed internally. In order to override these defaults, the breakpoints can be set explicitly by means of the breaks argument to the tm_fill(). It is important to note that, in tmap the breaks include a minimum and maximum. As a result, in order to end up with n categories, n+1 elements must be specified in the breaks option (the values must be in increasing order).\nBefore we get started, it is always a good practice to get some descriptive statistics on the variable before setting the break points. Code chunk below will be used to compute and display the descriptive statistics of DEPENDENCY field.\n\nsummary(mpsz_pop2020$DEPENDENCY)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n 0.0000  0.6519  0.7025  0.7742  0.7645 19.0000      92 \n\n\nWe set break point at 0.60, 0.70, 0.80, and 0.90 to reflect the quartiles, and include the min and max values as 0 and 100 respectively. Our breaks vector will be c(0, 0.60, 0.70, 0.80, 0.90, 100).\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          breaks = c(0, 0.60, 0.70, 0.80, 0.90, 100)) +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\nColour Scheme\ntmap supports colour ramps either defined by the user or a set of predefined colour ramps from the RColorBrewer package.\n\nUsing ColourBrewer palette\nUsing the palette argument of tm_fill(), we can define the color.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 6,\n          style = \"quantile\",\n          palette = \"Blues\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\nIn this map, the color gets bolder when the value increases. To reverse the color map and make the higher values lighter, we use the prefix - before the color map’s name.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          style = \"quantile\",\n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\nMap Layouts\nMap layout refers to the combination of all map elements like title, legend, scale bar, etc. into a cohensive map.\n\nMap Legend\nWe can customize the legend with multiple arguments using tm_layouts(). A histogram legend can be added using legend.hist. legend.is.portrait determines if the legends are in portrait or landscape mode. Refer to R documentation on tm_fill() for more details of legend settings.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"jenks\", \n          palette = \"Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1) +\n  tm_layout(main.title = \"Distribution of Dependency Ratio by planning subzone \\n(Jenks classification)\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            legend.outside = FALSE,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\nMap style\ntmap_style() is used to set many styles for the map. See Details of tm_layout() for predefined styles.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"classic\")\n\ntmap style set to \"classic\"\n\n\nother available styles are: \"white\", \"gray\", \"natural\", \"cobalt\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"watercolor\" \n\n\n\n\n\n\n\nCartographic Furniture\nBeside map style, tmap also also provides arguments to draw other map furniture such as compass, scale bar and grid lines. Refer to tm_layout()’s documentation for more details on the argument to customize the map.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\",\n          title = \"No. of persons\") +\n  tm_layout(main.title = \"Distribution of Dependency Ratio \\nby planning subzone\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\\n and Population data from Department of Statistics DOS\", \n             position = c(\"left\", \"bottom\"))\n\n\n\n\n\n\n\nDrawing Small Multiple Choropleth Maps\nSmall multiple maps, also referred to as facet maps, are composed of many maps arrange side-by-side, and sometimes stacked vertically.\nIn tmap, small multiple maps can be plotted in three ways:\n\nby assigning multiple values to at least one of the asthetic arguments,\nby defining a group-by variable in tm_facets(), and\nby creating multiple stand-alone maps with tmap_arrange().\n\n\nBy assigning multiple values to at least one of the aesthetic arguments\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(c(\"YOUNG\", \"AGED\"),\n          style = \"equal\", \n          palette = \"Blues\") +\n  tm_layout(legend.position = c(\"right\", \"bottom\")) +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"white\")\n\ntmap style set to \"white\"\n\n\nother available styles are: \"gray\", \"natural\", \"cobalt\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"classic\", \"watercolor\" \n\n\n\n\n\nIn this example, small multiple choropleth maps are created by assigning multiple values to at least one of the aesthetic arguments.\n\ntm_shape(mpsz_pop2020)+ \n  tm_polygons(c(\"DEPENDENCY\",\"AGED\"),\n          style = c(\"equal\", \"quantile\"), \n          palette = list(\"Blues\",\"Greens\")) +\n  tm_layout(legend.position = c(\"right\", \"bottom\"))\n\n\n\n\n\n\nBy defining a group-by variable in tm_facets()\n\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          style = \"quantile\",\n          palette = \"Blues\",\n          thres.poly = 0) + \n  tm_facets(by=\"REGION_N\", \n            free.coords=TRUE, \n            drop.shapes=TRUE) +\n  tm_layout(legend.show = FALSE,\n            title.position = c(\"center\", \"center\"), \n            title.size = 20) +\n  tm_borders(alpha = 0.5)\n\nWarning: The argument drop.shapes has been renamed to drop.units, and is\ntherefore deprecated\n\n\n\n\n\n\n\nBy creating multiple stand-alone maps with tmap_arrange()\n\nyoungmap <- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"YOUNG\", \n              style = \"quantile\", \n              palette = \"Blues\")\n\nagedmap <- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"AGED\", \n              style = \"quantile\", \n              palette = \"Blues\")\n\ntmap_arrange(youngmap, agedmap, asp=1, ncol=2)\n\n\n\n\n\n\n\nMappping Spatial Object Meeting a Selection Criterion\nThis code chunk below filter the areas by the criterion determined below in tm_shape().\n\ntm_shape(mpsz_pop2020[mpsz_pop2020$REGION_N==\"CENTRAL REGION\", ])+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1) +\n  tm_layout(legend.outside = TRUE,\n            legend.height = 0.45, \n            legend.width = 5.0,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n\nWarning in pre_process_gt(x, interactive = interactive, orig_crs =\ngm$shape.orig_crs): legend.width controls the width of the legend within a map.\nPlease use legend.outside.size to control the width of the outside legend"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex1/In-class_ex1.html#visualising-regional-development-indicator",
    "href": "In-class_Ex/In-class_Ex1/In-class_ex1.html#visualising-regional-development-indicator",
    "title": "Spatial Weight and Applications",
    "section": "Visualising Regional Development Indicator",
    "text": "Visualising Regional Development Indicator\nNow, we are going to prepare a basemap and a choropleth map showing the distribution of GDPPC 2012 by using qtm() of tmap package.\n\nbasemap <- tm_shape(hunan) +\n  tm_polygons() +\n  tm_text(\"NAME_3\", size=0.3)+\n  tmap_options(check.and.fix = TRUE)\n\ngdppc <- qtm(hunan, \"GDPPC\")+\n  tm_layout(legend.text.size = 0.5)\n\ntmap_arrange(basemap, gdppc, asp=1, ncol=2)"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex1/In-class_ex1.html#computing-contiguity-spatial-weights",
    "href": "In-class_Ex/In-class_Ex1/In-class_ex1.html#computing-contiguity-spatial-weights",
    "title": "Spatial Weight and Applications",
    "section": "Computing Contiguity Spatial Weights",
    "text": "Computing Contiguity Spatial Weights\n\nComputing (QUEEN) contiguity based neighbors\nFirst we install spdep package.\n\npacman::p_load(spdep)\n\n\nwm_q <- poly2nb(hunan, queen=TRUE)\nsummary(wm_q)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n\n\nTo see the neighbors for the first polygon in the object.\n\nwm_q[[1]]\n\n[1]  2  3  4 57 85\n\n\nWe can retrive the county name of Polygon ID=1 by using the code chunk below.\n\nhunan$County[1]\n\n[1] \"Anxiang\"\n\n\nRetrieve the names of the neighboring polygons with polygon 1.\n\nhunan$NAME_3[c(2,3,4,57,85)]\n\n[1] \"Hanshou\" \"Jinshi\"  \"Li\"      \"Nan\"     \"Taoyuan\"\n\n\nRetrieve the GDPPC of the areas.\n\nnb1 <- wm_q[[1]]\nnbb <- hunan$GDPPC[nb1]\nnbb\n\n[1] 20981 34592 24473 21311 22879\n\n\nDisplay the complete weight matrix.\n\nstr(wm_q)\n\nList of 88\n $ : int [1:5] 2 3 4 57 85\n $ : int [1:5] 1 57 58 78 85\n $ : int [1:4] 1 4 5 85\n $ : int [1:4] 1 3 5 6\n $ : int [1:4] 3 4 6 85\n $ : int [1:5] 4 5 69 75 85\n $ : int [1:4] 67 71 74 84\n $ : int [1:7] 9 46 47 56 78 80 86\n $ : int [1:6] 8 66 68 78 84 86\n $ : int [1:8] 16 17 19 20 22 70 72 73\n $ : int [1:3] 14 17 72\n $ : int [1:5] 13 60 61 63 83\n $ : int [1:4] 12 15 60 83\n $ : int [1:3] 11 15 17\n $ : int [1:4] 13 14 17 83\n $ : int [1:5] 10 17 22 72 83\n $ : int [1:7] 10 11 14 15 16 72 83\n $ : int [1:5] 20 22 23 77 83\n $ : int [1:6] 10 20 21 73 74 86\n $ : int [1:7] 10 18 19 21 22 23 82\n $ : int [1:5] 19 20 35 82 86\n $ : int [1:5] 10 16 18 20 83\n $ : int [1:7] 18 20 38 41 77 79 82\n $ : int [1:5] 25 28 31 32 54\n $ : int [1:5] 24 28 31 33 81\n $ : int [1:4] 27 33 42 81\n $ : int [1:3] 26 29 42\n $ : int [1:5] 24 25 33 49 54\n $ : int [1:3] 27 37 42\n $ : int 33\n $ : int [1:8] 24 25 32 36 39 40 56 81\n $ : int [1:8] 24 31 50 54 55 56 75 85\n $ : int [1:5] 25 26 28 30 81\n $ : int [1:3] 36 45 80\n $ : int [1:6] 21 41 47 80 82 86\n $ : int [1:6] 31 34 40 45 56 80\n $ : int [1:4] 29 42 43 44\n $ : int [1:4] 23 44 77 79\n $ : int [1:5] 31 40 42 43 81\n $ : int [1:6] 31 36 39 43 45 79\n $ : int [1:6] 23 35 45 79 80 82\n $ : int [1:7] 26 27 29 37 39 43 81\n $ : int [1:6] 37 39 40 42 44 79\n $ : int [1:4] 37 38 43 79\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:3] 8 47 86\n $ : int [1:5] 8 35 46 80 86\n $ : int [1:5] 50 51 52 53 55\n $ : int [1:4] 28 51 52 54\n $ : int [1:5] 32 48 52 54 55\n $ : int [1:3] 48 49 52\n $ : int [1:5] 48 49 50 51 54\n $ : int [1:3] 48 55 75\n $ : int [1:6] 24 28 32 49 50 52\n $ : int [1:5] 32 48 50 53 75\n $ : int [1:7] 8 31 32 36 78 80 85\n $ : int [1:6] 1 2 58 64 76 85\n $ : int [1:5] 2 57 68 76 78\n $ : int [1:4] 60 61 87 88\n $ : int [1:4] 12 13 59 61\n $ : int [1:7] 12 59 60 62 63 77 87\n $ : int [1:3] 61 77 87\n $ : int [1:4] 12 61 77 83\n $ : int [1:2] 57 76\n $ : int 76\n $ : int [1:5] 9 67 68 76 84\n $ : int [1:4] 7 66 76 84\n $ : int [1:5] 9 58 66 76 78\n $ : int [1:3] 6 75 85\n $ : int [1:3] 10 72 73\n $ : int [1:3] 7 73 74\n $ : int [1:5] 10 11 16 17 70\n $ : int [1:5] 10 19 70 71 74\n $ : int [1:6] 7 19 71 73 84 86\n $ : int [1:6] 6 32 53 55 69 85\n $ : int [1:7] 57 58 64 65 66 67 68\n $ : int [1:7] 18 23 38 61 62 63 83\n $ : int [1:7] 2 8 9 56 58 68 85\n $ : int [1:7] 23 38 40 41 43 44 45\n $ : int [1:8] 8 34 35 36 41 45 47 56\n $ : int [1:6] 25 26 31 33 39 42\n $ : int [1:5] 20 21 23 35 41\n $ : int [1:9] 12 13 15 16 17 18 22 63 77\n $ : int [1:6] 7 9 66 67 74 86\n $ : int [1:11] 1 2 3 5 6 32 56 57 69 75 ...\n $ : int [1:9] 8 9 19 21 35 46 47 74 84\n $ : int [1:4] 59 61 62 88\n $ : int [1:2] 59 87\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language poly2nb(pl = hunan, queen = TRUE)\n - attr(*, \"type\")= chr \"queen\"\n - attr(*, \"sym\")= logi TRUE\n\n\n\n\nCreating (ROOK) contiguity based neighbors\n\nwm_r <- poly2nb(hunan, queen=FALSE)\nsummary(wm_r)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 440 \nPercentage nonzero weights: 5.681818 \nAverage number of links: 5 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 10 \n 2  2 12 20 21 14 11  3  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 10 links\n\n\n\n\nVisualizing contiguity weights\nA connectivity graph takes a point and displays a line to each neighboring point. We are working with polygons, so need to find a way to convert them into points. The most typical method is to find out the polygon centroids.\nGet longitude and latitude value for the centroids.\n\nlongitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])\nlatitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])\n\nNow that we have latitude and longitude, we use cbind to put longitude and latitude into the same object.\n\ncoords <- cbind(longitude, latitude)\n\nCheck the first few observations.\n\nhead(coords)\n\n     longitude latitude\n[1,]  112.1531 29.44362\n[2,]  112.0372 28.86489\n[3,]  111.8917 29.47107\n[4,]  111.7031 29.74499\n[5,]  111.6138 29.49258\n[6,]  111.0341 29.79863\n\n\n\nPlotting Queen contiguity based neighbors map\n\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= \"red\")\n\n\n\n\n\n\nPlotting Rook contiguity based neighbors map\n\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = \"red\")\n\n\n\n\n\n\nPlotting both Queen and Rook contiguity based neighbors maps\n\npar(mfrow=c(1,2))\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= \"red\", main=\"Queen Contiguity\")\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = \"red\", main=\"Rook Contiguity\")"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex1/In-class_ex1.html#computing-distance-based-neighbors",
    "href": "In-class_Ex/In-class_Ex1/In-class_ex1.html#computing-distance-based-neighbors",
    "title": "Spatial Weight and Applications",
    "section": "Computing distance based neighbors",
    "text": "Computing distance based neighbors\n\nk1 <- knn2nb(knearneigh(coords))\nk1dists <- unlist(nbdists(k1, coords, longlat = TRUE))\nsummary(k1dists)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  24.79   32.57   38.01   39.07   44.52   61.79 \n\n\nThe summary report shows that the largest first nearest neighbour distance is 61.79 km, so using this as the upper threshold gives certainty that all units will have at least one neighbor.\n\nComputing fixed distance weight matrix\n\nwm_d62 <- dnearneigh(coords, 0, 62, longlat = TRUE)\nwm_d62\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \n\n\nThe average number of links are the number of nonzero link for each region, which equals 324 divided by 88.\nNow we display the content of wm_d62.\n\nstr(wm_d62)\n\nList of 88\n $ : int [1:5] 3 4 5 57 64\n $ : int [1:4] 57 58 78 85\n $ : int [1:4] 1 4 5 57\n $ : int [1:3] 1 3 5\n $ : int [1:4] 1 3 4 85\n $ : int 69\n $ : int [1:2] 67 84\n $ : int [1:4] 9 46 47 78\n $ : int [1:4] 8 46 68 84\n $ : int [1:4] 16 22 70 72\n $ : int [1:3] 14 17 72\n $ : int [1:5] 13 60 61 63 83\n $ : int [1:4] 12 15 60 83\n $ : int [1:2] 11 17\n $ : int 13\n $ : int [1:4] 10 17 22 83\n $ : int [1:3] 11 14 16\n $ : int [1:3] 20 22 63\n $ : int [1:5] 20 21 73 74 82\n $ : int [1:5] 18 19 21 22 82\n $ : int [1:6] 19 20 35 74 82 86\n $ : int [1:4] 10 16 18 20\n $ : int [1:3] 41 77 82\n $ : int [1:4] 25 28 31 54\n $ : int [1:4] 24 28 33 81\n $ : int [1:4] 27 33 42 81\n $ : int [1:2] 26 29\n $ : int [1:6] 24 25 33 49 52 54\n $ : int [1:2] 27 37\n $ : int 33\n $ : int [1:2] 24 36\n $ : int 50\n $ : int [1:5] 25 26 28 30 81\n $ : int [1:3] 36 45 80\n $ : int [1:6] 21 41 46 47 80 82\n $ : int [1:5] 31 34 45 56 80\n $ : int [1:2] 29 42\n $ : int [1:3] 44 77 79\n $ : int [1:4] 40 42 43 81\n $ : int [1:3] 39 45 79\n $ : int [1:5] 23 35 45 79 82\n $ : int [1:5] 26 37 39 43 81\n $ : int [1:3] 39 42 44\n $ : int [1:2] 38 43\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:5] 8 9 35 47 86\n $ : int [1:5] 8 35 46 80 86\n $ : int [1:5] 50 51 52 53 55\n $ : int [1:4] 28 51 52 54\n $ : int [1:6] 32 48 51 52 54 55\n $ : int [1:4] 48 49 50 52\n $ : int [1:6] 28 48 49 50 51 54\n $ : int [1:2] 48 55\n $ : int [1:5] 24 28 49 50 52\n $ : int [1:4] 48 50 53 75\n $ : int 36\n $ : int [1:5] 1 2 3 58 64\n $ : int [1:5] 2 57 64 66 68\n $ : int [1:3] 60 87 88\n $ : int [1:4] 12 13 59 61\n $ : int [1:5] 12 60 62 63 87\n $ : int [1:4] 61 63 77 87\n $ : int [1:5] 12 18 61 62 83\n $ : int [1:4] 1 57 58 76\n $ : int 76\n $ : int [1:5] 58 67 68 76 84\n $ : int [1:2] 7 66\n $ : int [1:4] 9 58 66 84\n $ : int [1:2] 6 75\n $ : int [1:3] 10 72 73\n $ : int [1:2] 73 74\n $ : int [1:3] 10 11 70\n $ : int [1:4] 19 70 71 74\n $ : int [1:5] 19 21 71 73 86\n $ : int [1:2] 55 69\n $ : int [1:3] 64 65 66\n $ : int [1:3] 23 38 62\n $ : int [1:2] 2 8\n $ : int [1:4] 38 40 41 45\n $ : int [1:5] 34 35 36 45 47\n $ : int [1:5] 25 26 33 39 42\n $ : int [1:6] 19 20 21 23 35 41\n $ : int [1:4] 12 13 16 63\n $ : int [1:4] 7 9 66 68\n $ : int [1:2] 2 5\n $ : int [1:4] 21 46 47 74\n $ : int [1:4] 59 61 62 88\n $ : int [1:2] 59 87\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language dnearneigh(x = coords, d1 = 0, d2 = 62, longlat = TRUE)\n - attr(*, \"dnn\")= num [1:2] 0 62\n - attr(*, \"bounds\")= chr [1:2] \"GE\" \"LE\"\n - attr(*, \"nbtype\")= chr \"distance\"\n - attr(*, \"sym\")= logi TRUE\n\n\nAnother way to display the structure of weight matrix is to combine table() and card() of sddep.\n\ntable(hunan$County, card(wm_d62))\n\n               \n                1 2 3 4 5 6\n  Anhua         1 0 0 0 0 0\n  Anren         0 0 0 1 0 0\n  Anxiang       0 0 0 0 1 0\n  Baojing       0 0 0 0 1 0\n  Chaling       0 0 1 0 0 0\n  Changning     0 0 1 0 0 0\n  Changsha      0 0 0 1 0 0\n  Chengbu       0 1 0 0 0 0\n  Chenxi        0 0 0 1 0 0\n  Cili          0 1 0 0 0 0\n  Dao           0 0 0 1 0 0\n  Dongan        0 0 1 0 0 0\n  Dongkou       0 0 0 1 0 0\n  Fenghuang     0 0 0 1 0 0\n  Guidong       0 0 1 0 0 0\n  Guiyang       0 0 0 1 0 0\n  Guzhang       0 0 0 0 0 1\n  Hanshou       0 0 0 1 0 0\n  Hengdong      0 0 0 0 1 0\n  Hengnan       0 0 0 0 1 0\n  Hengshan      0 0 0 0 0 1\n  Hengyang      0 0 0 0 0 1\n  Hongjiang     0 0 0 0 1 0\n  Huarong       0 0 0 1 0 0\n  Huayuan       0 0 0 1 0 0\n  Huitong       0 0 0 1 0 0\n  Jiahe         0 0 0 0 1 0\n  Jianghua      0 0 1 0 0 0\n  Jiangyong     0 1 0 0 0 0\n  Jingzhou      0 1 0 0 0 0\n  Jinshi        0 0 0 1 0 0\n  Jishou        0 0 0 0 0 1\n  Lanshan       0 0 0 1 0 0\n  Leiyang       0 0 0 1 0 0\n  Lengshuijiang 0 0 1 0 0 0\n  Li            0 0 1 0 0 0\n  Lianyuan      0 0 0 0 1 0\n  Liling        0 1 0 0 0 0\n  Linli         0 0 0 1 0 0\n  Linwu         0 0 0 1 0 0\n  Linxiang      1 0 0 0 0 0\n  Liuyang       0 1 0 0 0 0\n  Longhui       0 0 1 0 0 0\n  Longshan      0 1 0 0 0 0\n  Luxi          0 0 0 0 1 0\n  Mayang        0 0 0 0 0 1\n  Miluo         0 0 0 0 1 0\n  Nan           0 0 0 0 1 0\n  Ningxiang     0 0 0 1 0 0\n  Ningyuan      0 0 0 0 1 0\n  Pingjiang     0 1 0 0 0 0\n  Qidong        0 0 1 0 0 0\n  Qiyang        0 0 1 0 0 0\n  Rucheng       0 1 0 0 0 0\n  Sangzhi       0 1 0 0 0 0\n  Shaodong      0 0 0 0 1 0\n  Shaoshan      0 0 0 0 1 0\n  Shaoyang      0 0 0 1 0 0\n  Shimen        1 0 0 0 0 0\n  Shuangfeng    0 0 0 0 0 1\n  Shuangpai     0 0 0 1 0 0\n  Suining       0 0 0 0 1 0\n  Taojiang      0 1 0 0 0 0\n  Taoyuan       0 1 0 0 0 0\n  Tongdao       0 1 0 0 0 0\n  Wangcheng     0 0 0 1 0 0\n  Wugang        0 0 1 0 0 0\n  Xiangtan      0 0 0 1 0 0\n  Xiangxiang    0 0 0 0 1 0\n  Xiangyin      0 0 0 1 0 0\n  Xinhua        0 0 0 0 1 0\n  Xinhuang      1 0 0 0 0 0\n  Xinning       0 1 0 0 0 0\n  Xinshao       0 0 0 0 0 1\n  Xintian       0 0 0 0 1 0\n  Xupu          0 1 0 0 0 0\n  Yanling       0 0 1 0 0 0\n  Yizhang       1 0 0 0 0 0\n  Yongshun      0 0 0 1 0 0\n  Yongxing      0 0 0 1 0 0\n  You           0 0 0 1 0 0\n  Yuanjiang     0 0 0 0 1 0\n  Yuanling      1 0 0 0 0 0\n  Yueyang       0 0 1 0 0 0\n  Zhijiang      0 0 0 0 1 0\n  Zhongfang     0 0 0 1 0 0\n  Zhuzhou       0 0 0 0 1 0\n  Zixing        0 0 1 0 0 0\n\n\n\nn_comp <- n.comp.nb(wm_d62)\nn_comp$nc\n\n[1] 1\n\n\n\ntable(n_comp$comp.id)\n\n\n 1 \n88 \n\n\n\nPlotting fixed distance weight matrix\n\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_d62, coords, add=TRUE)\nplot(k1, coords, add=TRUE, col=\"red\", length=0.08)\n\n\n\n\nThe red lines show the links of 1st nearest neighbors and the black lines show the links of neighbors within the cut-off distance of 62km.\nAlternatively, we can plot both of them next to each other by using the code chunk below.\n\npar(mfrow=c(1,2))\nplot(hunan$geometry, border=\"lightgrey\")\nplot(k1, coords, add=TRUE, col=\"red\", length=0.08, main=\"1st nearest neighbours\")\nplot(hunan$geometry, border=\"lightgrey\")\nplot(wm_d62, coords, add=TRUE, pch = 19, cex = 0.6, main=\"Distance link\")\n\n\n\n\n\n\n\nComputing adaptive distance weight matrix\nRemember about distance weight matrix.\n\nMore dense areas have more neighbors.\nLess dense areas have less neighbors.\nHaving many neighbors smoothens the relationship across all neighbors in the area.\n\nIt is possible to control the numbers of neighbors directly using k-nearest neighbors, either accepting asymmetric neighbors or imposing symmetry.\n\nknn6 <- knn2nb(knearneigh(coords, k=6))\nknn6\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 528 \nPercentage nonzero weights: 6.818182 \nAverage number of links: 6 \nNon-symmetric neighbours list\n\n\nDisplay knn6 content. Each county has 6 neighbors because we set k-nearest neighbors with k = 6.\n\nstr(knn6)\n\nList of 88\n $ : int [1:6] 2 3 4 5 57 64\n $ : int [1:6] 1 3 57 58 78 85\n $ : int [1:6] 1 2 4 5 57 85\n $ : int [1:6] 1 3 5 6 69 85\n $ : int [1:6] 1 3 4 6 69 85\n $ : int [1:6] 3 4 5 69 75 85\n $ : int [1:6] 9 66 67 71 74 84\n $ : int [1:6] 9 46 47 78 80 86\n $ : int [1:6] 8 46 66 68 84 86\n $ : int [1:6] 16 19 22 70 72 73\n $ : int [1:6] 10 14 16 17 70 72\n $ : int [1:6] 13 15 60 61 63 83\n $ : int [1:6] 12 15 60 61 63 83\n $ : int [1:6] 11 15 16 17 72 83\n $ : int [1:6] 12 13 14 17 60 83\n $ : int [1:6] 10 11 17 22 72 83\n $ : int [1:6] 10 11 14 16 72 83\n $ : int [1:6] 20 22 23 63 77 83\n $ : int [1:6] 10 20 21 73 74 82\n $ : int [1:6] 18 19 21 22 23 82\n $ : int [1:6] 19 20 35 74 82 86\n $ : int [1:6] 10 16 18 19 20 83\n $ : int [1:6] 18 20 41 77 79 82\n $ : int [1:6] 25 28 31 52 54 81\n $ : int [1:6] 24 28 31 33 54 81\n $ : int [1:6] 25 27 29 33 42 81\n $ : int [1:6] 26 29 30 37 42 81\n $ : int [1:6] 24 25 33 49 52 54\n $ : int [1:6] 26 27 37 42 43 81\n $ : int [1:6] 26 27 28 33 49 81\n $ : int [1:6] 24 25 36 39 40 54\n $ : int [1:6] 24 31 50 54 55 56\n $ : int [1:6] 25 26 28 30 49 81\n $ : int [1:6] 36 40 41 45 56 80\n $ : int [1:6] 21 41 46 47 80 82\n $ : int [1:6] 31 34 40 45 56 80\n $ : int [1:6] 26 27 29 42 43 44\n $ : int [1:6] 23 43 44 62 77 79\n $ : int [1:6] 25 40 42 43 44 81\n $ : int [1:6] 31 36 39 43 45 79\n $ : int [1:6] 23 35 45 79 80 82\n $ : int [1:6] 26 27 37 39 43 81\n $ : int [1:6] 37 39 40 42 44 79\n $ : int [1:6] 37 38 39 42 43 79\n $ : int [1:6] 34 36 40 41 79 80\n $ : int [1:6] 8 9 35 47 78 86\n $ : int [1:6] 8 21 35 46 80 86\n $ : int [1:6] 49 50 51 52 53 55\n $ : int [1:6] 28 33 48 51 52 54\n $ : int [1:6] 32 48 51 52 54 55\n $ : int [1:6] 28 48 49 50 52 54\n $ : int [1:6] 28 48 49 50 51 54\n $ : int [1:6] 48 50 51 52 55 75\n $ : int [1:6] 24 28 49 50 51 52\n $ : int [1:6] 32 48 50 52 53 75\n $ : int [1:6] 32 34 36 78 80 85\n $ : int [1:6] 1 2 3 58 64 68\n $ : int [1:6] 2 57 64 66 68 78\n $ : int [1:6] 12 13 60 61 87 88\n $ : int [1:6] 12 13 59 61 63 87\n $ : int [1:6] 12 13 60 62 63 87\n $ : int [1:6] 12 38 61 63 77 87\n $ : int [1:6] 12 18 60 61 62 83\n $ : int [1:6] 1 3 57 58 68 76\n $ : int [1:6] 58 64 66 67 68 76\n $ : int [1:6] 9 58 67 68 76 84\n $ : int [1:6] 7 65 66 68 76 84\n $ : int [1:6] 9 57 58 66 78 84\n $ : int [1:6] 4 5 6 32 75 85\n $ : int [1:6] 10 16 19 22 72 73\n $ : int [1:6] 7 19 73 74 84 86\n $ : int [1:6] 10 11 14 16 17 70\n $ : int [1:6] 10 19 21 70 71 74\n $ : int [1:6] 19 21 71 73 84 86\n $ : int [1:6] 6 32 50 53 55 69\n $ : int [1:6] 58 64 65 66 67 68\n $ : int [1:6] 18 23 38 61 62 63\n $ : int [1:6] 2 8 9 46 58 68\n $ : int [1:6] 38 40 41 43 44 45\n $ : int [1:6] 34 35 36 41 45 47\n $ : int [1:6] 25 26 28 33 39 42\n $ : int [1:6] 19 20 21 23 35 41\n $ : int [1:6] 12 13 15 16 22 63\n $ : int [1:6] 7 9 66 68 71 74\n $ : int [1:6] 2 3 4 5 56 69\n $ : int [1:6] 8 9 21 46 47 74\n $ : int [1:6] 59 60 61 62 63 88\n $ : int [1:6] 59 60 61 62 63 87\n - attr(*, \"region.id\")= chr [1:88] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language knearneigh(x = coords, k = 6)\n - attr(*, \"sym\")= logi FALSE\n - attr(*, \"type\")= chr \"knn\"\n - attr(*, \"knn-k\")= num 6\n - attr(*, \"class\")= chr \"nb\"\n\n\n\nPlotting distance based neighbors\n\nplot(hunan$geometry, border=\"lightgrey\")\nplot(knn6, coords, pch = 19, cex = 0.6, add = TRUE, col = \"red\")"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex1/In-class_ex1.html#weights-based-on-idw",
    "href": "In-class_Ex/In-class_Ex1/In-class_ex1.html#weights-based-on-idw",
    "title": "Spatial Weight and Applications",
    "section": "Weights based on IDW",
    "text": "Weights based on IDW\nIDW = Inverse Distance Method.\n\ndist <- nbdists(wm_q, coords, longlat = TRUE)\nids <- lapply(dist, function(x) 1/(x))\nids\n\n[[1]]\n[1] 0.01535405 0.03916350 0.01820896 0.02807922 0.01145113\n\n[[2]]\n[1] 0.01535405 0.01764308 0.01925924 0.02323898 0.01719350\n\n[[3]]\n[1] 0.03916350 0.02822040 0.03695795 0.01395765\n\n[[4]]\n[1] 0.01820896 0.02822040 0.03414741 0.01539065\n\n[[5]]\n[1] 0.03695795 0.03414741 0.01524598 0.01618354\n\n[[6]]\n[1] 0.015390649 0.015245977 0.021748129 0.011883901 0.009810297\n\n[[7]]\n[1] 0.01708612 0.01473997 0.01150924 0.01872915\n\n[[8]]\n[1] 0.02022144 0.03453056 0.02529256 0.01036340 0.02284457 0.01500600 0.01515314\n\n[[9]]\n[1] 0.02022144 0.01574888 0.02109502 0.01508028 0.02902705 0.01502980\n\n[[10]]\n[1] 0.02281552 0.01387777 0.01538326 0.01346650 0.02100510 0.02631658 0.01874863\n[8] 0.01500046\n\n[[11]]\n[1] 0.01882869 0.02243492 0.02247473\n\n[[12]]\n[1] 0.02779227 0.02419652 0.02333385 0.02986130 0.02335429\n\n[[13]]\n[1] 0.02779227 0.02650020 0.02670323 0.01714243\n\n[[14]]\n[1] 0.01882869 0.01233868 0.02098555\n\n[[15]]\n[1] 0.02650020 0.01233868 0.01096284 0.01562226\n\n[[16]]\n[1] 0.02281552 0.02466962 0.02765018 0.01476814 0.01671430\n\n[[17]]\n[1] 0.01387777 0.02243492 0.02098555 0.01096284 0.02466962 0.01593341 0.01437996\n\n[[18]]\n[1] 0.02039779 0.02032767 0.01481665 0.01473691 0.01459380\n\n[[19]]\n[1] 0.01538326 0.01926323 0.02668415 0.02140253 0.01613589 0.01412874\n\n[[20]]\n[1] 0.01346650 0.02039779 0.01926323 0.01723025 0.02153130 0.01469240 0.02327034\n\n[[21]]\n[1] 0.02668415 0.01723025 0.01766299 0.02644986 0.02163800\n\n[[22]]\n[1] 0.02100510 0.02765018 0.02032767 0.02153130 0.01489296\n\n[[23]]\n[1] 0.01481665 0.01469240 0.01401432 0.02246233 0.01880425 0.01530458 0.01849605\n\n[[24]]\n[1] 0.02354598 0.01837201 0.02607264 0.01220154 0.02514180\n\n[[25]]\n[1] 0.02354598 0.02188032 0.01577283 0.01949232 0.02947957\n\n[[26]]\n[1] 0.02155798 0.01745522 0.02212108 0.02220532\n\n[[27]]\n[1] 0.02155798 0.02490625 0.01562326\n\n[[28]]\n[1] 0.01837201 0.02188032 0.02229549 0.03076171 0.02039506\n\n[[29]]\n[1] 0.02490625 0.01686587 0.01395022\n\n[[30]]\n[1] 0.02090587\n\n[[31]]\n[1] 0.02607264 0.01577283 0.01219005 0.01724850 0.01229012 0.01609781 0.01139438\n[8] 0.01150130\n\n[[32]]\n[1] 0.01220154 0.01219005 0.01712515 0.01340413 0.01280928 0.01198216 0.01053374\n[8] 0.01065655\n\n[[33]]\n[1] 0.01949232 0.01745522 0.02229549 0.02090587 0.01979045\n\n[[34]]\n[1] 0.03113041 0.03589551 0.02882915\n\n[[35]]\n[1] 0.01766299 0.02185795 0.02616766 0.02111721 0.02108253 0.01509020\n\n[[36]]\n[1] 0.01724850 0.03113041 0.01571707 0.01860991 0.02073549 0.01680129\n\n[[37]]\n[1] 0.01686587 0.02234793 0.01510990 0.01550676\n\n[[38]]\n[1] 0.01401432 0.02407426 0.02276151 0.01719415\n\n[[39]]\n[1] 0.01229012 0.02172543 0.01711924 0.02629732 0.01896385\n\n[[40]]\n[1] 0.01609781 0.01571707 0.02172543 0.01506473 0.01987922 0.01894207\n\n[[41]]\n[1] 0.02246233 0.02185795 0.02205991 0.01912542 0.01601083 0.01742892\n\n[[42]]\n[1] 0.02212108 0.01562326 0.01395022 0.02234793 0.01711924 0.01836831 0.01683518\n\n[[43]]\n[1] 0.01510990 0.02629732 0.01506473 0.01836831 0.03112027 0.01530782\n\n[[44]]\n[1] 0.01550676 0.02407426 0.03112027 0.01486508\n\n[[45]]\n[1] 0.03589551 0.01860991 0.01987922 0.02205991 0.02107101 0.01982700\n\n[[46]]\n[1] 0.03453056 0.04033752 0.02689769\n\n[[47]]\n[1] 0.02529256 0.02616766 0.04033752 0.01949145 0.02181458\n\n[[48]]\n[1] 0.02313819 0.03370576 0.02289485 0.01630057 0.01818085\n\n[[49]]\n[1] 0.03076171 0.02138091 0.02394529 0.01990000\n\n[[50]]\n[1] 0.01712515 0.02313819 0.02551427 0.02051530 0.02187179\n\n[[51]]\n[1] 0.03370576 0.02138091 0.02873854\n\n[[52]]\n[1] 0.02289485 0.02394529 0.02551427 0.02873854 0.03516672\n\n[[53]]\n[1] 0.01630057 0.01979945 0.01253977\n\n[[54]]\n[1] 0.02514180 0.02039506 0.01340413 0.01990000 0.02051530 0.03516672\n\n[[55]]\n[1] 0.01280928 0.01818085 0.02187179 0.01979945 0.01882298\n\n[[56]]\n[1] 0.01036340 0.01139438 0.01198216 0.02073549 0.01214479 0.01362855 0.01341697\n\n[[57]]\n[1] 0.028079221 0.017643082 0.031423501 0.029114131 0.013520292 0.009903702\n\n[[58]]\n[1] 0.01925924 0.03142350 0.02722997 0.01434859 0.01567192\n\n[[59]]\n[1] 0.01696711 0.01265572 0.01667105 0.01785036\n\n[[60]]\n[1] 0.02419652 0.02670323 0.01696711 0.02343040\n\n[[61]]\n[1] 0.02333385 0.01265572 0.02343040 0.02514093 0.02790764 0.01219751 0.02362452\n\n[[62]]\n[1] 0.02514093 0.02002219 0.02110260\n\n[[63]]\n[1] 0.02986130 0.02790764 0.01407043 0.01805987\n\n[[64]]\n[1] 0.02911413 0.01689892\n\n[[65]]\n[1] 0.02471705\n\n[[66]]\n[1] 0.01574888 0.01726461 0.03068853 0.01954805 0.01810569\n\n[[67]]\n[1] 0.01708612 0.01726461 0.01349843 0.01361172\n\n[[68]]\n[1] 0.02109502 0.02722997 0.03068853 0.01406357 0.01546511\n\n[[69]]\n[1] 0.02174813 0.01645838 0.01419926\n\n[[70]]\n[1] 0.02631658 0.01963168 0.02278487\n\n[[71]]\n[1] 0.01473997 0.01838483 0.03197403\n\n[[72]]\n[1] 0.01874863 0.02247473 0.01476814 0.01593341 0.01963168\n\n[[73]]\n[1] 0.01500046 0.02140253 0.02278487 0.01838483 0.01652709\n\n[[74]]\n[1] 0.01150924 0.01613589 0.03197403 0.01652709 0.01342099 0.02864567\n\n[[75]]\n[1] 0.011883901 0.010533736 0.012539774 0.018822977 0.016458383 0.008217581\n\n[[76]]\n[1] 0.01352029 0.01434859 0.01689892 0.02471705 0.01954805 0.01349843 0.01406357\n\n[[77]]\n[1] 0.014736909 0.018804247 0.022761507 0.012197506 0.020022195 0.014070428\n[7] 0.008440896\n\n[[78]]\n[1] 0.02323898 0.02284457 0.01508028 0.01214479 0.01567192 0.01546511 0.01140779\n\n[[79]]\n[1] 0.01530458 0.01719415 0.01894207 0.01912542 0.01530782 0.01486508 0.02107101\n\n[[80]]\n[1] 0.01500600 0.02882915 0.02111721 0.01680129 0.01601083 0.01982700 0.01949145\n[8] 0.01362855\n\n[[81]]\n[1] 0.02947957 0.02220532 0.01150130 0.01979045 0.01896385 0.01683518\n\n[[82]]\n[1] 0.02327034 0.02644986 0.01849605 0.02108253 0.01742892\n\n[[83]]\n[1] 0.023354289 0.017142433 0.015622258 0.016714303 0.014379961 0.014593799\n[7] 0.014892965 0.018059871 0.008440896\n\n[[84]]\n[1] 0.01872915 0.02902705 0.01810569 0.01361172 0.01342099 0.01297994\n\n[[85]]\n [1] 0.011451133 0.017193502 0.013957649 0.016183544 0.009810297 0.010656545\n [7] 0.013416965 0.009903702 0.014199260 0.008217581 0.011407794\n\n[[86]]\n[1] 0.01515314 0.01502980 0.01412874 0.02163800 0.01509020 0.02689769 0.02181458\n[8] 0.02864567 0.01297994\n\n[[87]]\n[1] 0.01667105 0.02362452 0.02110260 0.02058034\n\n[[88]]\n[1] 0.01785036 0.02058034\n\n\n\nRow-standardized weights matrix\nDrawback of weight matrix method:\n\nThe polygons along the edges of the study area will base their lagged values on fewer polygons thus potentially over- or under-estimating the true nature of the spatial autocorrelation in the data. For this example, we’ll stick with the style=“W” option for simplicity’s sake but note that other more robust options are available, notably style=“B”.\n\n\nrswm_q <- nb2listw(wm_q, style=\"W\", zero.policy = TRUE)\nrswm_q\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n\n\nSee the weight of polygon four’s neighbors.\n\nrswm_q$weights[10]\n\n[[1]]\n[1] 0.125 0.125 0.125 0.125 0.125 0.125 0.125 0.125\n\n\nEach neighbor is assigned a value of 0.125 of the total weight.\nRow standardized distance weight matrix.\n\nrswm_ids <- nb2listw(wm_q, glist=ids, style=\"B\", zero.policy=TRUE)\nrswm_ids\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: B \nWeights constants summary:\n   n   nn       S0        S1     S2\nB 88 7744 8.786867 0.3776535 3.8137\n\n\n\nrswm_ids$weights[1]\n\n[[1]]\n[1] 0.01535405 0.03916350 0.01820896 0.02807922 0.01145113\n\n\n\nsummary(unlist(rswm_ids$weights))\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n0.008218 0.015088 0.018739 0.019614 0.022823 0.040338 \n\n\n\nsummary(unlist(rswm_ids$weights))\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n0.008218 0.015088 0.018739 0.019614 0.022823 0.040338"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex1/In-class_ex1.html#application-of-spatial-weight-matrix",
    "href": "In-class_Ex/In-class_Ex1/In-class_ex1.html#application-of-spatial-weight-matrix",
    "title": "Spatial Weight and Applications",
    "section": "Application of Spatial Weight Matrix",
    "text": "Application of Spatial Weight Matrix\n\nSpatial lag with row-standardized weights\nWe’ll compute the average neighbor GDPPC value for each polygon. These values are often referred to as spatially lagged values.\n\nGDPPC.lag <- lag.listw(rswm_q, hunan$GDPPC)\nGDPPC.lag\n\n [1] 24847.20 22724.80 24143.25 27737.50 27270.25 21248.80 43747.00 33582.71\n [9] 45651.17 32027.62 32671.00 20810.00 25711.50 30672.33 33457.75 31689.20\n[17] 20269.00 23901.60 25126.17 21903.43 22718.60 25918.80 20307.00 20023.80\n[25] 16576.80 18667.00 14394.67 19848.80 15516.33 20518.00 17572.00 15200.12\n[33] 18413.80 14419.33 24094.50 22019.83 12923.50 14756.00 13869.80 12296.67\n[41] 15775.17 14382.86 11566.33 13199.50 23412.00 39541.00 36186.60 16559.60\n[49] 20772.50 19471.20 19827.33 15466.80 12925.67 18577.17 14943.00 24913.00\n[57] 25093.00 24428.80 17003.00 21143.75 20435.00 17131.33 24569.75 23835.50\n[65] 26360.00 47383.40 55157.75 37058.00 21546.67 23348.67 42323.67 28938.60\n[73] 25880.80 47345.67 18711.33 29087.29 20748.29 35933.71 15439.71 29787.50\n[81] 18145.00 21617.00 29203.89 41363.67 22259.09 44939.56 16902.00 16930.00\n\n\nRetrieve the GDPPC of the areas.\n\nnb1 <- wm_q[[1]]\nnb1 <- hunan$GDPPC[nb1]\nnb1\n\n[1] 20981 34592 24473 21311 22879\n\n\nAppend the spatially lag GDPPC values onto hunan sf data frame.\n\nlag.list <- list(hunan$NAME_3, lag.listw(rswm_q, hunan$GDPPC))\nlag.res <- as.data.frame(lag.list)\ncolnames(lag.res) <- c(\"NAME_3\", \"lag GDPPC\")\nhunan <- left_join(hunan,lag.res)\n\nJoining, by = \"NAME_3\"\n\n\nDisplay the average neighboring income values (stored in the Inc.lag object) for each county.\n\nhead(hunan)\n\nSimple feature collection with 6 features and 36 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 110.4922 ymin: 28.61762 xmax: 112.3013 ymax: 30.12812\nGeodetic CRS:  WGS 84\n   NAME_2  ID_3  NAME_3   ENGTYPE_3 Shape_Leng Shape_Area  County    City\n1 Changde 21098 Anxiang      County   1.869074 0.10056190 Anxiang Changde\n2 Changde 21100 Hanshou      County   2.360691 0.19978745 Hanshou Changde\n3 Changde 21101  Jinshi County City   1.425620 0.05302413  Jinshi Changde\n4 Changde 21102      Li      County   3.474325 0.18908121      Li Changde\n5 Changde 21103   Linli      County   2.289506 0.11450357   Linli Changde\n6 Changde 21104  Shimen      County   4.171918 0.37194707  Shimen Changde\n  avg_wage deposite     FAI Gov_Rev Gov_Exp     GDP GDPPC     GIO   Loan  NIPCR\n1    31935   5517.2  3541.0  243.64  1779.5 12482.0 23667  5108.9 2806.9 7693.7\n2    32265   7979.0  8665.0  386.13  2062.4 15788.0 20981 13491.0 4550.0 8269.9\n3    28692   4581.7  4777.0  373.31  1148.4  8706.9 34592 10935.0 2242.0 8169.9\n4    32541  13487.0 16066.0  709.61  2459.5 20322.0 24473 18402.0 6748.0 8377.0\n5    32667    564.1  7781.2  336.86  1538.7 10355.0 25554  8214.0  358.0 8143.1\n6    33261   8334.4 10531.0  548.33  2178.8 16293.0 27137 17795.0 6026.5 6156.0\n   Bed    Emp  EmpR EmpRT Pri_Stu Sec_Stu Household Household_R NOIP Pop_R\n1 1931 336.39 270.5 205.9  19.584  17.819     148.1       135.4   53 346.0\n2 2560 456.78 388.8 246.7  42.097  33.029     240.2       208.7   95 553.2\n3  848 122.78  82.1  61.7   8.723   7.592      81.9        43.7   77  92.4\n4 2038 513.44 426.8 227.1  38.975  33.938     268.5       256.0   96 539.7\n5 1440 307.36 272.2 100.8  23.286  18.943     129.1       157.2   99 246.6\n6 2502 392.05 329.6 193.8  29.245  26.104     190.6       184.7  122 399.2\n    RSCG Pop_T    Agri Service Disp_Inc      RORP    ROREmp lag GDPPC\n1 3957.9 528.3 4524.41   14100    16610 0.6549309 0.8041262  24847.20\n2 4460.5 804.6 6545.35   17727    18925 0.6875466 0.8511756  22724.80\n3 3683.0 251.8 2562.46    7525    19498 0.3669579 0.6686757  24143.25\n4 7110.2 832.5 7562.34   53160    18985 0.6482883 0.8312558  27737.50\n5 3604.9 409.3 3583.91    7031    18604 0.6024921 0.8856065  27270.25\n6 6490.7 600.5 5266.51    6981    19275 0.6647794 0.8407091  21248.80\n                        geometry\n1 POLYGON ((112.0625 29.75523...\n2 POLYGON ((112.2288 29.11684...\n3 POLYGON ((111.8927 29.6013,...\n4 POLYGON ((111.3731 29.94649...\n5 POLYGON ((111.6324 29.76288...\n6 POLYGON ((110.8825 30.11675...\n\n\nPlot GDPPC and GDPPC spatial lag.\n\ngdppc <- qtm(hunan, \"GDPPC\")+\n  tm_layout(legend.text.size = 0.4)\nlag_gdppc <- qtm(hunan, \"lag GDPPC\")+\n  tm_layout(legend.text.size = 0.4)\ntmap_arrange(gdppc, lag_gdppc, asp=1, ncol=2)\n\n\n\n\n\n\nSpatial lag as a sum of neighboring values\n\nb_weights <- lapply(wm_q, function(x) 0*x + 1)\nb_weights2 <- nb2listw(wm_q, \n                       glist = b_weights, \n                       style = \"B\")\nb_weights2\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: B \nWeights constants summary:\n   n   nn  S0  S1    S2\nB 88 7744 448 896 10224\n\n\nUse lag.listw to compute a lag variable from weight and GDPPC.\n\nlag_sum <- list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))\nlag.res <- as.data.frame(lag_sum)\ncolnames(lag.res) <- c(\"NAME_3\", \"lag_sum GDPPC\")\n\nExamine the result.\n\nlag_sum\n\n[[1]]\n [1] \"Anxiang\"       \"Hanshou\"       \"Jinshi\"        \"Li\"           \n [5] \"Linli\"         \"Shimen\"        \"Liuyang\"       \"Ningxiang\"    \n [9] \"Wangcheng\"     \"Anren\"         \"Guidong\"       \"Jiahe\"        \n[13] \"Linwu\"         \"Rucheng\"       \"Yizhang\"       \"Yongxing\"     \n[17] \"Zixing\"        \"Changning\"     \"Hengdong\"      \"Hengnan\"      \n[21] \"Hengshan\"      \"Leiyang\"       \"Qidong\"        \"Chenxi\"       \n[25] \"Zhongfang\"     \"Huitong\"       \"Jingzhou\"      \"Mayang\"       \n[29] \"Tongdao\"       \"Xinhuang\"      \"Xupu\"          \"Yuanling\"     \n[33] \"Zhijiang\"      \"Lengshuijiang\" \"Shuangfeng\"    \"Xinhua\"       \n[37] \"Chengbu\"       \"Dongan\"        \"Dongkou\"       \"Longhui\"      \n[41] \"Shaodong\"      \"Suining\"       \"Wugang\"        \"Xinning\"      \n[45] \"Xinshao\"       \"Shaoshan\"      \"Xiangxiang\"    \"Baojing\"      \n[49] \"Fenghuang\"     \"Guzhang\"       \"Huayuan\"       \"Jishou\"       \n[53] \"Longshan\"      \"Luxi\"          \"Yongshun\"      \"Anhua\"        \n[57] \"Nan\"           \"Yuanjiang\"     \"Jianghua\"      \"Lanshan\"      \n[61] \"Ningyuan\"      \"Shuangpai\"     \"Xintian\"       \"Huarong\"      \n[65] \"Linxiang\"      \"Miluo\"         \"Pingjiang\"     \"Xiangyin\"     \n[69] \"Cili\"          \"Chaling\"       \"Liling\"        \"Yanling\"      \n[73] \"You\"           \"Zhuzhou\"       \"Sangzhi\"       \"Yueyang\"      \n[77] \"Qiyang\"        \"Taojiang\"      \"Shaoyang\"      \"Lianyuan\"     \n[81] \"Hongjiang\"     \"Hengyang\"      \"Guiyang\"       \"Changsha\"     \n[85] \"Taoyuan\"       \"Xiangtan\"      \"Dao\"           \"Jiangyong\"    \n\n[[2]]\n [1] 124236 113624  96573 110950 109081 106244 174988 235079 273907 256221\n[11]  98013 104050 102846  92017 133831 158446 141883 119508 150757 153324\n[21] 113593 129594 142149 100119  82884  74668  43184  99244  46549  20518\n[31] 140576 121601  92069  43258 144567 132119  51694  59024  69349  73780\n[41]  94651 100680  69398  52798 140472 118623 180933  82798  83090  97356\n[51]  59482  77334  38777 111463  74715 174391 150558 122144  68012  84575\n[61] 143045  51394  98279  47671  26360 236917 220631 185290  64640  70046\n[71] 126971 144693 129404 284074 112268 203611 145238 251536 108078 238300\n[81] 108870 108085 262835 248182 244850 404456  67608  33860\n\n\nSpatial lag as a sum of neighboring values calculate the values caused by nearby areas affecting each other on the variable observed.\n\nhunan <- left_join(hunan, lag.res)\n\nJoining, by = \"NAME_3\"\n\n\nPlot both the GDPPC and Spatial Lag Sum GDPPC.\n\ngdppc <- qtm(hunan, \"GDPPC\")+\n  tm_layout(legend.text.size = 0.45)\nlag_sum_gdppc <- qtm(hunan, \"lag_sum GDPPC\")+\n  tm_layout(legend.text.size = 0.45)\ntmap_arrange(gdppc, lag_sum_gdppc, asp=1, ncol=2)\n\n\n\n\n\n\nSpatial window average\n\nwm_q1 <- wm_q\n\nThe spatial window average uses row-standardized weights and includes the diagonal element. To do this in R, we need to go back to the neighbors structure and add the diagonal element before assigning weights. To begin we assign k6 to a new variable because we will directly alter its structure to add the diagonal elements. Then we add the diagonal element.\n\ninclude.self(wm_q1)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 536 \nPercentage nonzero weights: 6.921488 \nAverage number of links: 6.090909 \n\n\nObtain weight.\n\nwm_q1 <- nb2listw(wm_q1)\nwm_q1\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n\n\nCreate the lag variable from our weight structure and GDPPC variable.\n\nlag_w_avg_gpdpc <- lag.listw(wm_q1, \n                             hunan$GDPPC)\nlag_w_avg_gpdpc\n\n [1] 24847.20 22724.80 24143.25 27737.50 27270.25 21248.80 43747.00 33582.71\n [9] 45651.17 32027.62 32671.00 20810.00 25711.50 30672.33 33457.75 31689.20\n[17] 20269.00 23901.60 25126.17 21903.43 22718.60 25918.80 20307.00 20023.80\n[25] 16576.80 18667.00 14394.67 19848.80 15516.33 20518.00 17572.00 15200.12\n[33] 18413.80 14419.33 24094.50 22019.83 12923.50 14756.00 13869.80 12296.67\n[41] 15775.17 14382.86 11566.33 13199.50 23412.00 39541.00 36186.60 16559.60\n[49] 20772.50 19471.20 19827.33 15466.80 12925.67 18577.17 14943.00 24913.00\n[57] 25093.00 24428.80 17003.00 21143.75 20435.00 17131.33 24569.75 23835.50\n[65] 26360.00 47383.40 55157.75 37058.00 21546.67 23348.67 42323.67 28938.60\n[73] 25880.80 47345.67 18711.33 29087.29 20748.29 35933.71 15439.71 29787.50\n[81] 18145.00 21617.00 29203.89 41363.67 22259.09 44939.56 16902.00 16930.00\n\n\nConvert the lag variable list into a data frame.\n\nlag.list.wm_q1 <- list(hunan$NAME_3, lag.listw(wm_q1, hunan$GDPPC))\nlag_wm_q1.res <- as.data.frame(lag.list.wm_q1)\ncolnames(lag_wm_q1.res) <- c(\"NAME_3\", \"lag_window_avg GDPPC\")\n\n\nhunan <- left_join(hunan, lag_wm_q1.res)\n\nJoining, by = \"NAME_3\"\n\n\nPlot lag window average GDPPC map.\n\ngdppc <- qtm(hunan, \"GDPPC\")+\n  tm_layout(legend.text.size = 0.45)\nw_avg_gdppc <- qtm(hunan, \"lag_window_avg GDPPC\")+\n  tm_layout(legend.text.size = 0.45)\ntmap_arrange(gdppc, w_avg_gdppc, asp=1, ncol=2)\n\n\n\n\n\n\nSpatial window sum\nThe spatial window sum is the counter part of the window average, but without using row-standardized weights.\n\nwm_q1 <- wm_q\ninclude.self(wm_q1)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 536 \nPercentage nonzero weights: 6.921488 \nAverage number of links: 6.090909 \n\n\nCompare with wm_q1.\n\nwm_q1\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\n\nAssign binary weight to the neighbor structure.\n\nb_weights <- lapply(wm_q1, function(x) 0*x + 1)\nb_weights[1]\n\n[[1]]\n[1] 1 1 1 1 1\n\n\nExplicitly assign weight value.\n\nb_weights2 <- nb2listw(wm_q1, \n                       glist = b_weights, \n                       style = \"B\")\nb_weights2\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: B \nWeights constants summary:\n   n   nn  S0  S1    S2\nB 88 7744 448 896 10224\n\n\nCompute the lag variable.\n\nw_sum_gdppc <- list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))\nw_sum_gdppc\n\n[[1]]\n [1] \"Anxiang\"       \"Hanshou\"       \"Jinshi\"        \"Li\"           \n [5] \"Linli\"         \"Shimen\"        \"Liuyang\"       \"Ningxiang\"    \n [9] \"Wangcheng\"     \"Anren\"         \"Guidong\"       \"Jiahe\"        \n[13] \"Linwu\"         \"Rucheng\"       \"Yizhang\"       \"Yongxing\"     \n[17] \"Zixing\"        \"Changning\"     \"Hengdong\"      \"Hengnan\"      \n[21] \"Hengshan\"      \"Leiyang\"       \"Qidong\"        \"Chenxi\"       \n[25] \"Zhongfang\"     \"Huitong\"       \"Jingzhou\"      \"Mayang\"       \n[29] \"Tongdao\"       \"Xinhuang\"      \"Xupu\"          \"Yuanling\"     \n[33] \"Zhijiang\"      \"Lengshuijiang\" \"Shuangfeng\"    \"Xinhua\"       \n[37] \"Chengbu\"       \"Dongan\"        \"Dongkou\"       \"Longhui\"      \n[41] \"Shaodong\"      \"Suining\"       \"Wugang\"        \"Xinning\"      \n[45] \"Xinshao\"       \"Shaoshan\"      \"Xiangxiang\"    \"Baojing\"      \n[49] \"Fenghuang\"     \"Guzhang\"       \"Huayuan\"       \"Jishou\"       \n[53] \"Longshan\"      \"Luxi\"          \"Yongshun\"      \"Anhua\"        \n[57] \"Nan\"           \"Yuanjiang\"     \"Jianghua\"      \"Lanshan\"      \n[61] \"Ningyuan\"      \"Shuangpai\"     \"Xintian\"       \"Huarong\"      \n[65] \"Linxiang\"      \"Miluo\"         \"Pingjiang\"     \"Xiangyin\"     \n[69] \"Cili\"          \"Chaling\"       \"Liling\"        \"Yanling\"      \n[73] \"You\"           \"Zhuzhou\"       \"Sangzhi\"       \"Yueyang\"      \n[77] \"Qiyang\"        \"Taojiang\"      \"Shaoyang\"      \"Lianyuan\"     \n[81] \"Hongjiang\"     \"Hengyang\"      \"Guiyang\"       \"Changsha\"     \n[85] \"Taoyuan\"       \"Xiangtan\"      \"Dao\"           \"Jiangyong\"    \n\n[[2]]\n [1] 124236 113624  96573 110950 109081 106244 174988 235079 273907 256221\n[11]  98013 104050 102846  92017 133831 158446 141883 119508 150757 153324\n[21] 113593 129594 142149 100119  82884  74668  43184  99244  46549  20518\n[31] 140576 121601  92069  43258 144567 132119  51694  59024  69349  73780\n[41]  94651 100680  69398  52798 140472 118623 180933  82798  83090  97356\n[51]  59482  77334  38777 111463  74715 174391 150558 122144  68012  84575\n[61] 143045  51394  98279  47671  26360 236917 220631 185290  64640  70046\n[71] 126971 144693 129404 284074 112268 203611 145238 251536 108078 238300\n[81] 108870 108085 262835 248182 244850 404456  67608  33860\n\n\nConvert the lag variable list into a data frame.\n\nw_sum_gdppc.res <- as.data.frame(w_sum_gdppc)\ncolnames(w_sum_gdppc.res) <- c(\"NAME_3\", \"w_sum GDPPC\")\n\n\nhunan <- left_join(hunan, w_sum_gdppc.res)\n\nJoining, by = \"NAME_3\"\n\ngdppc <- qtm(hunan, \"GDPPC\")+\n  tm_layout(legend.text.size = 0.45)\nw_sum_gdppc <- qtm(hunan, \"w_sum GDPPC\")+\n  tm_layout(legend.text.size = 0.45)\ntmap_arrange(gdppc, w_sum_gdppc, asp=1, ncol=2)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex02.html",
    "href": "Hands-on_Ex/Hands-on_Ex02.html",
    "title": "Global and Local Measures of Spatial Autocorrelation",
    "section": "",
    "text": "This exercise provide the steps of computing the Global and Local Measures of Spatial Autocorrelation using spdep package."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex02.html#getting-started",
    "href": "Hands-on_Ex/Hands-on_Ex02.html#getting-started",
    "title": "Global and Local Measures of Spatial Autocorrelation",
    "section": "Getting Started",
    "text": "Getting Started\n\nThe analytical question\nWe may ask, is a character or attribute evenly distributed across areas or regions? If they are not, then is there a sign of spatial clustering, and if yes, where are the clusters? Those questions can be applied to a wide range of domains: development planning of city councils, shop outlet location setting of a fashion chain, examining the habitat clusters of a certain plant species, etc.\nIn this case study, we are interested to examine the spatial pattern of a selected development indicator (i.e. GDP per capita) of Hunan Provice, People Republic of China.\n\n\nThe study area and data\nTwo data sets will be used in this hands-on exercise, they are:\n\nHunan province administrative boundary layer at county level. This is a geospatial data set in ESRI shapefile format.\nHunan_2012.csv: This csv file contains selected Hunan’s local development indicators in 2012.\n\nWe will reuse the data that we exercised in the In-class Exercise 2 - Spatial Weights and Application segment of this website.\n\n\nSetting the analytical tools\nFirst, we load the necessary R packages.\n\npacman::p_load(sf, spdep, tmap, tidyverse)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01.html",
    "href": "Hands-on_Ex/Hands-on_Ex01.html",
    "title": "Geospatial Wrangling and Choropleth Mapping with R",
    "section": "",
    "text": "In this hands-on exercise, I learn how to import and wrangle geospatial data using appropriate R packages.\n\n\n\nThe code chunk below installs and loads sf and tidyverse.\nNotes: Make sure you imported the pacman package before running the code below.\n\npacman::p_load(sf, tidyverse)\n\n\n\n\nBefore importing anything, download the data zip file(s), unzip, and put them into the folder inside the directory of your page. Then create a Quarto document within that folder. The Quarto document and the data files need to be in the same folder, or you need to clarify the path to the data file while running the code below.\n\n\nNotes: You need to save your working R document as an qmd file before you can run the code below.\n\nmpsz <- st_read(dsn = \"data/geospatial\", layer = \"MP14_SUBZONE_WEB_PL\")\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/Hands-on_Ex/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\n\n\n\n\nRun the code chunk below.\n\ncyclingpath <- st_read(dsn = \"data/geospatial\", layer = \"CyclingPath\")\n\nReading layer `CyclingPath' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/Hands-on_Ex/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 1625 features and 2 fields\nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: 12711.19 ymin: 28711.33 xmax: 42626.09 ymax: 48948.15\nProjected CRS: SVY21\n\n\n\n\n\nRun the code chunk below.\n\npreschool <- st_read(\"data/geospatial/pre-schools-location-kml.kml\")\n\nReading layer `PRESCHOOLS_LOCATION' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/Hands-on_Ex/data/geospatial/pre-schools-location-kml.kml' \n  using driver `KML'\nSimple feature collection with 1359 features and 2 fields\nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6824 ymin: 1.248403 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\n\n\n\n\n\n\n\n\nThe type of geometry is multipolygon.\n\nst_geometry(mpsz)\n\nGeometry set for 323 features \nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\nFirst 5 geometries:\n\n\nMULTIPOLYGON (((31495.56 30140.01, 31980.96 296...\n\n\nMULTIPOLYGON (((29092.28 30021.89, 29119.64 300...\n\n\nMULTIPOLYGON (((29932.33 29879.12, 29947.32 298...\n\n\nMULTIPOLYGON (((27131.28 30059.73, 27088.33 297...\n\n\nMULTIPOLYGON (((26451.03 30396.46, 26440.47 303...\n\n\n\n\n\nGlimpse display a sneak peek into the data type and values of the variables. Notice that X_ADDR and Y_ADDR are double type. There are other types like character, integer, and date.\n\nglimpse(mpsz)\n\nRows: 323\nColumns: 16\n$ OBJECTID   <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, …\n$ SUBZONE_NO <int> 1, 1, 3, 8, 3, 7, 9, 2, 13, 7, 12, 6, 1, 5, 1, 1, 3, 2, 2, …\n$ SUBZONE_N  <chr> \"MARINA SOUTH\", \"PEARL'S HILL\", \"BOAT QUAY\", \"HENDERSON HIL…\n$ SUBZONE_C  <chr> \"MSSZ01\", \"OTSZ01\", \"SRSZ03\", \"BMSZ08\", \"BMSZ03\", \"BMSZ07\",…\n$ CA_IND     <chr> \"Y\", \"Y\", \"Y\", \"N\", \"N\", \"N\", \"N\", \"Y\", \"N\", \"N\", \"N\", \"N\",…\n$ PLN_AREA_N <chr> \"MARINA SOUTH\", \"OUTRAM\", \"SINGAPORE RIVER\", \"BUKIT MERAH\",…\n$ PLN_AREA_C <chr> \"MS\", \"OT\", \"SR\", \"BM\", \"BM\", \"BM\", \"BM\", \"SR\", \"QT\", \"QT\",…\n$ REGION_N   <chr> \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENT…\n$ REGION_C   <chr> \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\", \"CR\",…\n$ INC_CRC    <chr> \"5ED7EB253F99252E\", \"8C7149B9EB32EEFC\", \"C35FEFF02B13E0E5\",…\n$ FMEL_UPD_D <date> 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05, 2014-12-05…\n$ X_ADDR     <dbl> 31595.84, 28679.06, 29654.96, 26782.83, 26201.96, 25358.82,…\n$ Y_ADDR     <dbl> 29220.19, 29782.05, 29974.66, 29933.77, 30005.70, 29991.38,…\n$ SHAPE_Leng <dbl> 5267.381, 3506.107, 1740.926, 3313.625, 2825.594, 4428.913,…\n$ SHAPE_Area <dbl> 1630379.27, 559816.25, 160807.50, 595428.89, 387429.44, 103…\n$ geometry   <MULTIPOLYGON [m]> MULTIPOLYGON (((31495.56 30..., MULTIPOLYGON (…\n\n\n\n\n\nUse n = … to select the number of records to display. Head gives a look at the first few rows of the data frame.\n\nhead(mpsz, n = 5)\n\nSimple feature collection with 5 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 25867.68 ymin: 28369.47 xmax: 32362.39 ymax: 30435.54\nProjected CRS: SVY21\n  OBJECTID SUBZONE_NO      SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N\n1        1          1   MARINA SOUTH    MSSZ01      Y    MARINA SOUTH\n2        2          1   PEARL'S HILL    OTSZ01      Y          OUTRAM\n3        3          3      BOAT QUAY    SRSZ03      Y SINGAPORE RIVER\n4        4          8 HENDERSON HILL    BMSZ08      N     BUKIT MERAH\n5        5          3        REDHILL    BMSZ03      N     BUKIT MERAH\n  PLN_AREA_C       REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1         MS CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84\n2         OT CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06\n3         SR CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96\n4         BM CENTRAL REGION       CR 3775D82C5DDBEFBD 2014-12-05 26782.83\n5         BM CENTRAL REGION       CR 85D9ABEF0A40678F 2014-12-05 26201.96\n    Y_ADDR SHAPE_Leng SHAPE_Area                       geometry\n1 29220.19   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...\n2 29782.05   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...\n3 29974.66   1740.926   160807.5 MULTIPOLYGON (((29932.33 29...\n4 29933.77   3313.625   595428.9 MULTIPOLYGON (((27131.28 30...\n5 30005.70   2825.594   387429.4 MULTIPOLYGON (((26451.03 30...\n\n\n\n\n\n\nWith geospatial data, we can use the plot() function to display them as visual elements. We can use max.plot = … to define the number of plots shown. This data set has 15 plots at the maximum but we only sketch 9 plots here, hence max.plot = 9.\n\nplot(mpsz, max.plot = 9)\n\n\n\n\nWe can choose to plot just one plot using the code chunk below. This is the plot of the sf object, which is the frame of all plots.\n\nplot(st_geometry(mpsz))\n\n\n\n\nOr we can plot and view a specific attribute.\n\nplot(mpsz[\"PLN_AREA_N\"])\n\n\n\n\n\nNotes: plot is only used for a quickly. For high cartographic quality plot, use tmap R package.\n\n\n\n\nWhen we want to project two or more geospatial data sets, it is important to ensure the data sets are projected under the same coordinate system. Projection Transformation is the method of projecting a data frame from one coordinate system to another.\n\n\nIssues to notice: missing coordination or wrongly assigned coordination due to the importing process.\nUsing the code chunk below, we can see the coordinate system of mpsz.\n\nst_crs(mpsz)\n\nCoordinate Reference System:\n  User input: SVY21 \n  wkt:\nPROJCRS[\"SVY21\",\n    BASEGEOGCRS[\"SVY21[WGS84]\",\n        DATUM[\"World Geodetic System 1984\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ID[\"EPSG\",6326]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"Degree\",0.0174532925199433]]],\n    CONVERSION[\"unnamed\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"Degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]\n\n\n\nNotice the User input says the data is projected in svy21, but the EPSG code is 9001. This is a wrong EPSG code because the EPSG code for svy21 should be 3414.\n\nWe now assign the correct EPSG code using the code below.\n\nmpsz3414 <- st_set_crs(mpsz, 3414)\n\nWarning: st_crs<- : replacing crs does not reproject data; use st_transform for\nthat\n\n\nR warns us that st_crs does not reproject data. While this is true in case we want to do projection transformation, here we simply want to fix the EPSG code. Therefore, reprojection is not necessary and we can proceed with checking the EPSG of mpsz3414, which shows the correct EPSG code.\n\nst_crs(mpsz3414)\n\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n\n\n\n\n\nNow we inspect the geometry of preschool. It is clear that preschool is projected in the WGS84 coordinate system.\n\nst_geometry(preschool)\n\nGeometry set for 1359 features \nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 103.6824 ymin: 1.248403 xmax: 103.9897 ymax: 1.462134\nz_range:       zmin: 0 zmax: 0\nGeodetic CRS:  WGS 84\nFirst 5 geometries:\n\n\nPOINT Z (103.7614 1.308683 0)\n\n\nPOINT Z (103.7536 1.315748 0)\n\n\nPOINT Z (103.7645 1.305078 0)\n\n\nPOINT Z (103.765 1.305239 0)\n\n\nPOINT Z (103.7597 1.315983 0)\n\n\nWe will transform the projection of preschool to svy21 using st_transform.\n\npreschool3414 <- st_transform(preschool, crs = 3414)\n\nNow we can inspect the geometry of preschool3414, which is now projected in svy21 coordinate system.\n\nst_geometry(preschool3414)\n\nGeometry set for 1359 features \nGeometry type: POINT\nDimension:     XYZ\nBounding box:  xmin: 11203.01 ymin: 25667.6 xmax: 45404.24 ymax: 49300.88\nz_range:       zmin: 0 zmax: 0\nProjected CRS: SVY21 / Singapore TM\nFirst 5 geometries:\n\n\nPOINT Z (19997.26 32333.17 0)\n\n\nPOINT Z (19126.75 33114.35 0)\n\n\nPOINT Z (20345.12 31934.56 0)\n\n\nPOINT Z (20400.31 31952.36 0)\n\n\nPOINT Z (19810.78 33140.31 0)\n\n\n\nNotes: in Bounding box, the values are greater than 0-360 range of decimal degree commonly used by most of the geographic coordinate systems.\n\n\n\n\n\n\n\nBecause the listings dataset is in the csv format, we use the read.csv() function to import the data into an object called listings, which is a tibble data frame.\n\nlistings <- read.csv(\"data/aspatial/listings.csv\")\n\nTo inspect the data set, instead of using glimpse, now we use list because of the object type.\n\noptions(max.print = 10)\nlist(listings)\n\n[[1]]\n     id name host_id host_name neighbourhood_group neighbourhood latitude\n     longitude room_type price minimum_nights number_of_reviews last_review\n     reviews_per_month calculated_host_listings_count availability_365\n [ reached 'max' / getOption(\"max.print\") -- omitted 4252 rows ]\n\n\nWe can see that listings has 4,252 rows and 16 columns. We are going to use latitude and longitude.\n\nNote that they are in decimal degree format. As a best guess, we will assume that the data is in wgs84 Geographic Coordinate System.\n\n\n\n\nWe now convert listings into a simple feature data frame using st_as_sf().\n\nlistings_sf <- st_as_sf(listings, coords = c(\"longitude\", \"latitude\"), crs = 4326) %>%\n  st_transform(crs = 3414)\n\nNotes\n\n\ncoords argument requires you to provide the column name of the x-coordinates first then followed by the column name of the y-coordinates.\ncrs argument requires you to provide the coordinates system in epsg format. EPSG: 4326 is wgs84 Geographic Coordinate System and EPSG: 3414 is Singapore SVY21 Projected Coordinate System. You can search for other country’s epsg code by referring to epsg.io.\n%>% is used to nest st_transform() to transform the newly created simple feature data frame into svy21 projected coordinates system.\n\n\nAfter the transformation, we can examine the new object listings_sf using glimpse.\n\nglimpse(listings_sf)\n\nRows: 4,252\nColumns: 15\n$ id                             <int> 50646, 71609, 71896, 71903, 275343, 275…\n$ name                           <chr> \"Pleasant Room along Bukit Timah\", \"Ens…\n$ host_id                        <int> 227796, 367042, 367042, 367042, 1439258…\n$ host_name                      <chr> \"Sujatha\", \"Belinda\", \"Belinda\", \"Belin…\n$ neighbourhood_group            <chr> \"Central Region\", \"East Region\", \"East …\n$ neighbourhood                  <chr> \"Bukit Timah\", \"Tampines\", \"Tampines\", …\n$ room_type                      <chr> \"Private room\", \"Private room\", \"Privat…\n$ price                          <int> 80, 178, 81, 81, 52, 40, 72, 41, 49, 49…\n$ minimum_nights                 <int> 90, 90, 90, 90, 14, 14, 90, 8, 14, 14, …\n$ number_of_reviews              <int> 18, 20, 24, 48, 20, 13, 133, 105, 14, 1…\n$ last_review                    <chr> \"2014-07-08\", \"2019-12-28\", \"2014-12-10…\n$ reviews_per_month              <dbl> 0.22, 0.28, 0.33, 0.67, 0.20, 0.16, 1.2…\n$ calculated_host_listings_count <int> 1, 4, 4, 4, 50, 50, 7, 1, 50, 50, 50, 4…\n$ availability_365               <int> 365, 365, 365, 365, 353, 364, 365, 90, …\n$ geometry                       <POINT [m]> POINT (22646.02 35167.9), POINT (…\n\n\n\n\n\n\n\n\nThe scenario\nThe authority is planning to upgrade the exiting cycling path. To do so, they need to acquire 5 metres of reserved land on the both sides of the current cycling path. You are tasked to determine the extend of the land need to be acquired and their total area.\nSolution\nCompute the 5-meter buffers around cycling paths\n\nbuffer_cycling <- st_buffer(cyclingpath, dist = 5, nQuadSegs = 30)\n\nCalculate the area of the buffers as shown in the code chunk below.\n\nbuffer_cycling$AREA <- st_area(buffer_cycling)\n\nLastly, sum() of Base R will be used to derive the total land involved.\n\nsum(buffer_cycling$AREA)\n\n773143.9 [m^2]\n\n\n\n\n\nThe scenario\nA pre-school service group want to find out the numbers of pre-schools in each Planning Subzone.\nThe solution\nThe code chunk below performs two operations at one go. Firstly, identify pre-schools located inside each Planning Subzone by using st_intersects(). Next, length() of Base R is used to calculate numbers of pre-schools that fall inside each planning subzone.\n\nmpsz3414$`PreSch Count` <- lengths(st_intersects(mpsz3414, preschool3414))\n\nNow we check the new PreSch Count field.\n\nsummary(mpsz3414$`PreSch Count`)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  0.000   0.000   2.000   4.207   6.000  37.000 \n\n\nTo list the planning subzone with the most number of pre-school, the top_n() of dplyr package is used as shown in the code chunk below.\n\ntop_n(mpsz3414, 1, `PreSch Count`)\n\nSimple feature collection with 1 feature and 16 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 23449.05 ymin: 46001.23 xmax: 25594.22 ymax: 47996.47\nProjected CRS: SVY21 / Singapore TM\n     OBJECTID SUBZONE_NO SUBZONE_N SUBZONE_C CA_IND PLN_AREA_N PLN_AREA_C\n     REGION_N REGION_C INC_CRC FMEL_UPD_D X_ADDR Y_ADDR SHAPE_Leng SHAPE_Area\n     geometry PreSch Count\n [ reached 'max' / getOption(\"max.print\") -- omitted 1 rows ]\n\n\n\n\n\nFirstly, the code chunk below uses st_area() of sf package to derive the area of each planning subzone.\n\nmpsz3414$Area <- mpsz3414 %>%\n  st_area()\n\nNext, mutate() of dplyr package is used to compute the density by using the code chunk below.\n\nmpsz3414 <- mpsz3414 %>%\n  mutate(`PreSch Density` = `PreSch Count`/Area * 1000000)\n\nResults\n\nsummary(mpsz3414$`PreSch Density`)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  0.000   0.000   2.974   4.076   6.609  29.059 \n\n\n\ntop_n(mpsz3414, 1, `PreSch Density`)\n\nSimple feature collection with 1 feature and 18 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 28896.26 ymin: 28339.16 xmax: 29426.66 ymax: 28685.25\nProjected CRS: SVY21 / Singapore TM\n\n\nWarning in format.data.frame(if (omit) x[seq_len(n0), , drop = FALSE] else x, :\ncorrupt data frame: columns will be truncated or padded with NAs\n\n\n     OBJECTID SUBZONE_NO SUBZONE_N SUBZONE_C CA_IND PLN_AREA_N PLN_AREA_C\n     REGION_N REGION_C INC_CRC FMEL_UPD_D X_ADDR Y_ADDR SHAPE_Leng SHAPE_Area\n     geometry PreSch Count Area PreSch Density\n [ reached 'max' / getOption(\"max.print\") -- omitted 1 rows ]\n\n\n\n\n\n\nFirstly, we will plot a histogram to reveal the distribution of PreSch Density. Conventionally, hist() of R Graphics will be used as shown in the code chunk below.\n\nhist(mpsz3414$`PreSch Density`, main = \"Histogram of School Density\", xlab = \"School Density\")\n\n\n\n\nIn the code chunk below, appropriate ggplot2 functions will be used.\n\nggplot(data=mpsz3414, \n       aes(x= as.numeric(`PreSch Density`)))+\n  geom_histogram(bins=20, \n                 color=\"black\", \n                 fill=\"light blue\") +\n  labs(title = \"Are pre-school even distributed in Singapore?\",\n       subtitle= \"There are many planning sub-zones with a single pre-school, on the other hand, \\nthere are two planning sub-zones with at least 20 pre-schools\",\n      x = \"Pre-school density (per km sq)\",\n      y = \"Frequency\")\n\n\n\n\n\n\n\nggplot(data = mpsz3414,\n       aes(x = as.numeric(`PreSch Density`), y = as.numeric(`PreSch Count`))) +\n  geom_point() +\n  labs(x = \"Pre-school Density (per km square)\",\n       y = \"Pre-school Count\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01.html#overview-1",
    "href": "Hands-on_Ex/Hands-on_Ex01.html#overview-1",
    "title": "Geospatial Wrangling and Choropleth Mapping with R",
    "section": "Overview",
    "text": "Overview\nChoropleth map is a map showing different colors depending on the value of the attribute that the map is presenting. For example, a map showing population density have different colors for each areas with varying levels of population density."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01.html#getting-started-1",
    "href": "Hands-on_Ex/Hands-on_Ex01.html#getting-started-1",
    "title": "Geospatial Wrangling and Choropleth Mapping with R",
    "section": "Getting Started",
    "text": "Getting Started\nThis exercise will use the tmap R package and four other R packages.\n\nreadr for importing delimited text file,\ntidyr for tidying data,\ndplyr for wrangling data and\nsf for handling geospatial data.\n\nFirst, we load the packages into R Studio.\n\npacman::p_load(sf, tmap, tidyverse)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01.html#importing-data-into-r",
    "href": "Hands-on_Ex/Hands-on_Ex01.html#importing-data-into-r",
    "title": "Geospatial Wrangling and Choropleth Mapping with R",
    "section": "Importing Data into R",
    "text": "Importing Data into R\n\nImporting Geospatial Data into R\nSince we already imported and inspected the MP4_SUBZONE_WEB_PL shapefile as mpsz, we can skip this step.\n\n\nImporting Attribute Data into R\n\npopdata <- read_csv('~/sylvie-le/ISSS624/Hands-on_Ex/data/aspatial/respopagesextod2011to2020.csv')\n\nRows: 984656 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (5): PA, SZ, AG, Sex, TOD\ndbl (2): Pop, Time\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\n\nData Preparation\n\n\nWe need to prepare a data table with the necessary data points as below.\n\nYOUNG: age group 0 to 4 until age groyup 20 to 24,\nECONOMY ACTIVE: age group 25-29 until age group 60-64,\nAGED: age group 65 and above,\nTOTAL: all age group, and\nDEPENDENCY: the ratio between young and aged against economy active group\n\n\nData Wrangling\nThe functions below is used to wrangle the data as defined above.\n\npopdata2020 <- popdata %>%\n  filter(Time == 2020) %>%\n  group_by(PA, SZ, AG) %>%\n  summarise(`POP` = sum(`Pop`)) %>%\n  ungroup()%>%\n  pivot_wider(names_from=AG, \n              values_from=POP) %>%\n  mutate(YOUNG = rowSums(.[3:6])\n         +rowSums(.[12])) %>%\nmutate(`ECONOMY ACTIVE` = rowSums(.[7:11])+\nrowSums(.[13:15]))%>%\nmutate(`AGED`=rowSums(.[16:21])) %>%\nmutate(`TOTAL`=rowSums(.[3:21])) %>%  \nmutate(`DEPENDENCY` = (`YOUNG` + `AGED`)\n/`ECONOMY ACTIVE`) %>%\n  select(`PA`, `SZ`, `YOUNG`, \n       `ECONOMY ACTIVE`, `AGED`, \n       `TOTAL`, `DEPENDENCY`)\n\n`summarise()` has grouped output by 'PA', 'SZ'. You can override using the\n`.groups` argument.\n\n\n\n\nJoining the attribute data and geospatial data\nBefore we can perform the georelational join, one extra step is required to convert the values in PA and SZ fields to uppercase. This is because the values of PA and SZ fields are made up of upper- and lowercase. On the other, hand the SUBZONE_N and PLN_AREA_N are in uppercase.\nSince funs() was deprecated, we use list() instead.\n\npopdata2020 <- popdata2020 %>%\n  mutate_at(.vars = vars(PA, SZ), \n          .funs = list(toupper)) %>%\n  filter(`ECONOMY ACTIVE` > 0)\n\nAfter that, we conduct a left join of the data using left_join() , to ensure the output to be simple features data frame.\n\nmpsz_pop2020 <- left_join(mpsz, popdata2020,\n                          by = c(\"SUBZONE_N\" = \"SZ\"))\n\nNow we save the new file after creating a new folder called rds in data folder.\n\nwrite_rds(mpsz_pop2020, \"~/sylvie-le/ISSS624/Hands-on_Ex/data/rds/mpszpop2020.rds\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01.html#choropleth-mapping-geospatial-data-using-tmap",
    "href": "Hands-on_Ex/Hands-on_Ex01.html#choropleth-mapping-geospatial-data-using-tmap",
    "title": "Geospatial Wrangling and Choropleth Mapping with R",
    "section": "Choropleth Mapping Geospatial Data Using tmap",
    "text": "Choropleth Mapping Geospatial Data Using tmap\nTwo approaches can be used to prepare thematic map using tmap, they are:\n\nPlotting a thematic map quickly by using qtm().\nPlotting highly customisable thematic map by using tmap elements.\n\n\nMethod 1: Plotting using qtm()\n\ntmap_mode(mode = \"plot\")\n\ntmap mode set to plotting\n\nqtm(mpsz_pop2020, \n    fill = \"DEPENDENCY\")\n\n\n\n\nNotes\n\n\ntmap_mode() with “plot” option is used to produce a static map. For interactive mode, “view” option should be used.\nfill argument is used to map the attribute (i.e. DEPENDENCY)\n\n\n\n\nMethod 2: Creating a choropleth map by using tmap’s elements\nWhile being convenient and short, qtm() does not allow for drawing maps with high cartographic quality. To overcome qtm()’s disadvantage, we can use tmap’s elements.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\",\n          title = \"Dependency ratio\") +\n  tm_layout(main.title = \"Distribution of Dependency Ratio by planning subzone\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar() +\n  tm_grid(alpha =0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\\n and Population data from Department of Statistics DOS\", \n             position = c(\"left\", \"bottom\"))\n\n\n\n\nNext, let’s look at the code and draw the map step by step to understand how each element works.\n\nDrawing a base map\nThe building block of tmap is tm_shape(), which is followed by elements such as tm_fill() and tm_polygons(). We will use tm_polygons() as it allows us to fill the polygons with color as tm_fill() does, and also let us draw the border of the polygons as tm_border().\n\ntm_shape(mpsz_pop2020) +\n  tm_polygons()\n\n\n\n\n\n\nDrawing a choropleth map using tm_polygons()\nNext, we will define how the colors are filled into the map by letting tm_polygons() know the criteria to fill. In this case, the criteria is the variable DEPENDENCY.\n\ntm_shape(mpsz_pop2020)+\n  tm_polygons(\"DEPENDENCY\")\n\n\n\n\nNotes\n\n\nThe default binning to draw the choropleth map is called “pretty”. Refer to sub-section 4.3 for more details.\nThe default color scheme is YlOrRd. Refer to sub-section 4.4 for more details of color schemes.\nBy default, Missing value is filled with gray.\n\n\n\n\nDrawing a choropleth map using tm_fill() and tm_border()\nInstead of using tm_polygons(), we can use tm_fill() and tm_border() instead. The code will be longer but if some day we like to type more, we can opt for this option.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\")\n\n\n\n\nWith just tm_fill(), the map is drawn without the borders between the areas. To add the borders, we combine the code chunk above with tm_borders().\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\") +\n  tm_borders(lwd = 0.1,  alpha = 1)\n\n\n\n\nObserving the map, we see that the border thickness are different that what we achieved with tm_polygons(). This suggests that we can customize border thickness with tm_borders().\nThe argument to customize borders are at below.\n\n\ncol = border colour,\nlwd = border line width. The default is 1, and\nlty = border line type. The default is “solid”.\n\n\n\n\n\nData classification methods of tmap\nData classification is to group a large numbers of observations into ranges or classes. It helps us to better describe the data and present the information we want to highlight, besides other roles.\ntmap provides a total ten data classification methods, namely: fixed, sd, equal, pretty (default), quantile, kmeans, hclust, bclust, fisher, and jenks. Refer to R documentations details on the methods.\nTo define a data classification method, the style argument of tm_fill() or tm_polygons() will be used.\n\nPlotting choropleth maps with built-in classification methods\nUse n = 5 as in the code chunk below to classify the data into 5 classes.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\nThe code below classifies the data using equal classification method.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\nNotice that the distribution of quantile data classification method are more evenly distributed then equal data classification method.\nNext, we will use all of the classification methods and compare the results.\n\nMap Comparison\n\nm1 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"sd\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"SD\")\nm2 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Equal\")\nm3 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"pretty\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Pretty\")\nm4 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Quantile\")\nm5 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"kmeans\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Kmeans\")\nm6 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"hclust\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Hclust\")\nm7 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"bclust\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Bclust\")\nm8 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"fisher\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Fisher\")\nm9 <- tm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(main.title = \"Jenks\")\n\ntmap_arrange(m1, m2, asp=1, ncol=2)\n\n\n\ntmap_arrange(m3, m4, asp=1, ncol=2)\n\n\n\ntmap_arrange(m5, m6, asp=1, ncol=2)\n\n\n\ntmap_arrange(m7, m8, asp=1, ncol=2)\n\n\n\n\nCommittee Member: 1(1) 2(1) 3(1) 4(1) 5(1) 6(1) 7(1) 8(1) 9(1) 10(1)\nComputing Hierarchical Clustering\n\ntmap_arrange(m9, asp=1, ncol=2)\n\n\n\n\nEach data classification methods provide a different representation of the data. Therefore, we should consider which classification method to best presenting the data, and which classification methods are meaningful to the data. Data presentation can be misleading if we don’t choose carefully.\n\n\n\nPlotting choropleth map with custome break\nFor all the built-in styles, the category breaks are computed internally. In order to override these defaults, the breakpoints can be set explicitly by means of the breaks argument to the tm_fill(). It is important to note that, in tmap the breaks include a minimum and maximum. As a result, in order to end up with n categories, n+1 elements must be specified in the breaks option (the values must be in increasing order).\nBefore we get started, it is always a good practice to get some descriptive statistics on the variable before setting the break points. Code chunk below will be used to compute and display the descriptive statistics of DEPENDENCY field.\n\nsummary(mpsz_pop2020$DEPENDENCY)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n 0.0000  0.6519  0.7025  0.7742  0.7645 19.0000      92 \n\n\nWe set break point at 0.60, 0.70, 0.80, and 0.90 to reflect the quartiles, and include the min and max values as 0 and 100 respectively. Our breaks vector will be c(0, 0.60, 0.70, 0.80, 0.90, 100).\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          breaks = c(0, 0.60, 0.70, 0.80, 0.90, 100)) +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\nColour Scheme\ntmap supports colour ramps either defined by the user or a set of predefined colour ramps from the RColorBrewer package.\n\nUsing ColourBrewer palette\nUsing the palette argument of tm_fill(), we can define the color.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          n = 6,\n          style = \"quantile\",\n          palette = \"Blues\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\nIn this map, the color gets bolder when the value increases. To reverse the color map and make the higher values lighter, we use the prefix - before the color map’s name.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\",\n          style = \"quantile\",\n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\nMap Layouts\nMap layout refers to the combination of all map elements like title, legend, scale bar, etc. into a cohensive map.\n\nMap Legend\nWe can customize the legend with multiple arguments using tm_layouts(). A histogram legend can be added using legend.hist. legend.is.portrait determines if the legends are in portrait or landscape mode. Refer to R documentation on tm_fill() for more details of legend settings.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"jenks\", \n          palette = \"Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1) +\n  tm_layout(main.title = \"Distribution of Dependency Ratio by planning subzone \\n(Jenks classification)\",\n            main.title.position = \"center\",\n            main.title.size = 1,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            legend.outside = FALSE,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\nMap style\ntmap_style() is used to set many styles for the map. See Details of tm_layout() for predefined styles.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"classic\")\n\ntmap style set to \"classic\"\n\n\nother available styles are: \"white\", \"gray\", \"natural\", \"cobalt\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"watercolor\" \n\n\n\n\n\n\n\nCartographic Furniture\nBeside map style, tmap also also provides arguments to draw other map furniture such as compass, scale bar and grid lines. Refer to tm_layout()’s documentation for more details on the argument to customize the map.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\",\n          title = \"No. of persons\") +\n  tm_layout(main.title = \"Distribution of Dependency Ratio \\nby planning subzone\",\n            main.title.position = \"center\",\n            main.title.size = 1.2,\n            legend.height = 0.45, \n            legend.width = 0.35,\n            frame = TRUE) +\n  tm_borders(alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) +\n  tm_grid(lwd = 0.1, alpha = 0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\\n and Population data from Department of Statistics DOS\", \n             position = c(\"left\", \"bottom\"))\n\n\n\n\n\n\n\nDrawing Small Multiple Choropleth Maps\nSmall multiple maps, also referred to as facet maps, are composed of many maps arrange side-by-side, and sometimes stacked vertically.\nIn tmap, small multiple maps can be plotted in three ways:\n\nby assigning multiple values to at least one of the asthetic arguments,\nby defining a group-by variable in tm_facets(), and\nby creating multiple stand-alone maps with tmap_arrange().\n\n\nBy assigning multiple values to at least one of the aesthetic arguments\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(c(\"YOUNG\", \"AGED\"),\n          style = \"equal\", \n          palette = \"Blues\") +\n  tm_layout(legend.position = c(\"right\", \"bottom\")) +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"white\")\n\ntmap style set to \"white\"\n\n\nother available styles are: \"gray\", \"natural\", \"cobalt\", \"col_blind\", \"albatross\", \"beaver\", \"bw\", \"classic\", \"watercolor\" \n\n\n\n\n\nIn this example, small multiple choropleth maps are created by assigning multiple values to at least one of the aesthetic arguments.\n\ntm_shape(mpsz_pop2020)+ \n  tm_polygons(c(\"DEPENDENCY\",\"AGED\"),\n          style = c(\"equal\", \"quantile\"), \n          palette = list(\"Blues\",\"Greens\")) +\n  tm_layout(legend.position = c(\"right\", \"bottom\"))\n\n\n\n\n\n\nBy defining a group-by variable in tm_facets()\n\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          style = \"quantile\",\n          palette = \"Blues\",\n          thres.poly = 0) + \n  tm_facets(by=\"REGION_N\", \n            free.coords=TRUE, \n            drop.shapes=TRUE) +\n  tm_layout(legend.show = FALSE,\n            title.position = c(\"center\", \"center\"), \n            title.size = 20) +\n  tm_borders(alpha = 0.5)\n\nWarning: The argument drop.shapes has been renamed to drop.units, and is\ntherefore deprecated\n\n\n\n\n\n\n\nBy creating multiple stand-alone maps with tmap_arrange()\n\nyoungmap <- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"YOUNG\", \n              style = \"quantile\", \n              palette = \"Blues\")\n\nagedmap <- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"AGED\", \n              style = \"quantile\", \n              palette = \"Blues\")\n\ntmap_arrange(youngmap, agedmap, asp=1, ncol=2)\n\n\n\n\n\n\n\nMappping Spatial Object Meeting a Selection Criterion\nThis code chunk below filter the areas by the criterion determined below in tm_shape().\n\ntm_shape(mpsz_pop2020[mpsz_pop2020$REGION_N==\"CENTRAL REGION\", ])+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1) +\n  tm_layout(legend.outside = TRUE,\n            legend.height = 0.45, \n            legend.width = 5.0,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n\nWarning in pre_process_gt(x, interactive = interactive, orig_crs =\ngm$shape.orig_crs): legend.width controls the width of the legend within a map.\nPlease use legend.outside.size to control the width of the outside legend"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex02.html#getting-the-data-into-the-r-environment",
    "href": "Hands-on_Ex/Hands-on_Ex02.html#getting-the-data-into-the-r-environment",
    "title": "Global and Local Measures of Spatial Autocorrelation",
    "section": "Getting the Data into the R Environment",
    "text": "Getting the Data into the R Environment\n\nImport shapefile into R environment\nWe import the Hunan shapefile into R using the sf package.\n\nhunan <- st_read(dsn = \"~/sylvie-le/ISSS624/In-class_Ex/In-class_Ex1/dataC/geospatial\", layer = \"Hunan\")\n\nReading layer `Hunan' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/In-class_Ex/In-class_Ex1/dataC/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n\n\n\n\nImport CSV file into R environment\n\nhunan2012 <- read_csv(\"~/sylvie-le/ISSS624/In-class_Ex/In-class_Ex1/dataC/aspatial/Hunan_2012.csv\", show_col_types = FALSE)\n\n\n\nPerform relational join\n\nhunan <- left_join(hunan, hunan2012)\n\nJoining, by = \"County\"\n\n\n\n\nVisualize regional development indicator\nNow we will prepare a choropleth map showing the distribution of GDPPC 2012 in Hunan.\n\nequal <- tm_shape(hunan) +\n  tm_fill(\"GDPPC\",\n          n = 5,\n          style = \"equal\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal interval classification\",\n            main.title.size = 1,\n            main.title.position = \"center\",\n            legend.text.size = 0.45)\n\nquantile <- tm_shape(hunan) +\n  tm_fill(\"GDPPC\",\n          n = 5,\n          style = \"quantile\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Equal quantile classification\",\n            main.title.size = 1,\n            main.title.position = \"center\",\n            legend.text.size = 0.45)\n\ntmap_arrange(equal, quantile, asp = 1, ncol = 2)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex02.html#global-spatial-autocorrelation",
    "href": "Hands-on_Ex/Hands-on_Ex02.html#global-spatial-autocorrelation",
    "title": "Global and Local Measures of Spatial Autocorrelation",
    "section": "Global Spatial Autocorrelation",
    "text": "Global Spatial Autocorrelation\n\nComputing contiguity spatial weight\nBefore we can compute the global spatial autocorrelation statistics, we need to construct a spatial weights of the study area. The spatial weights is used to define the neighbourhood relationships between the geographical units (i.e. county) in the study area.\n\nwm_q <- poly2nb(hunan, queen = TRUE)\nsummary(wm_q)\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8  9 11 \n 2  2 12 16 24 14 11  4  2  1 \n2 least connected regions:\n30 65 with 1 link\n1 most connected region:\n85 with 11 links\n\n\n\n\nRow-standardized weights matrix\n\nrswm_q <- nb2listw(wm_q, style = \"W\", zero.policy = TRUE)\nrswm_q\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 448 \nPercentage nonzero weights: 5.785124 \nAverage number of links: 5.090909 \n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 88 7744 88 37.86334 365.9147\n\n\nRefer HERE for an explanation of the code and HERE for documentation on nb2listw().\n\n\nGlobal Spatial Autocorrelation: Moran’s I\n\nMoran’s Test\nWe will perform Moran test using moran.test() from spdep.\n\nmoran.test(hunan$GDPPC,\n           listw = rswm_q,\n           zero.policy = TRUE,\n           na.action = na.omit)\n\n\n    Moran I test under randomisation\n\ndata:  hunan$GDPPC  \nweights: rswm_q    \n\nMoran I statistic standard deviate = 4.7351, p-value = 1.095e-06\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.300749970      -0.011494253       0.004348351 \n\n\nMoran I statistic is approximately 0.3, indicating clustered data. The neighbor observations tend to be similar. p-valu is less than 0.05. Therefore, we reject the null hypothesis H0 of spatial randomness at 95% confidence level.\n\n\nComputing Monte Carlo Moran’s I\nWe will conduct a permutation test for Moran’s I statistic by generating 1,000 simulations.\n\nset.seed(1234) #to prevent the result from changing due to random calculation\nbperm = moran.mc(hunan$GDPPC,\n                 listw = rswm_q,\n                 nsim = 999,\n                 zero.policy = TRUE,\n                 na.action = na.omit)\nbperm\n\n\n    Monte-Carlo simulation of Moran I\n\ndata:  hunan$GDPPC \nweights: rswm_q  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.30075, observed rank = 1000, p-value = 0.001\nalternative hypothesis: greater\n\n\nThe result of 1,000 simulation is similar to the Moran’s I test. p-value is less than 0.05. Therefore, we are confident at 95% level of confidence that the data does not violate Moran’s I assumption of spatial randomness.\n\n\nVisulize Monte Carlo Moran’s I\n\nmean(bperm$res[1:999])\n\n[1] -0.01504572\n\n\n\nvar(bperm$res[1:999])\n\n[1] 0.004371574\n\n\n\nsummary(bperm$res[1:999])\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n-0.18339 -0.06168 -0.02125 -0.01505  0.02611  0.27593 \n\n\n\nhist(bperm$res,\n     freq = TRUE,\n     breaks = 20,\n     xlab = \"Simulated Moran's I\")\nabline(v = 0, col = \"red\")\n\n\n\n\nWe can see that I approaches 1, meaning similar values are clustered, corroborated Moran’s I test result.\nWe can use ggplot2 to visualize Monte Carlo Moran’s I. The plot is slightly different because ggplot2 binning algorithm is different from hist binning algorithm.\n\nlibrary(ggplot2)\ndf <- data.frame(bperm$res)\nggplot(df, aes(bperm$res)) +\n  geom_histogram(fill = \"gray\", color = \"black\", closed = \"right\") +\n  scale_x_continuous(breaks = 20) +\n  geom_vline(aes(xintercept = 0), color = \"red\") +\n  labs(title = \"Histogram of bperm$res\", x = \"Simulated Moran's I\", y = \"Frequency\") +\n  theme_bw() +\n  theme(plot.title = element_text(hjust = 0.5))\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\nGlobal Spatial Autocorrelation: Geary’s\nGeary’s C test\n\ngeary.test(hunan$GDPPC, listw = rswm_q)\n\n\n    Geary C test under randomisation\n\ndata:  hunan$GDPPC \nweights: rswm_q \n\nGeary C statistic standard deviate = 3.6108, p-value = 0.0001526\nalternative hypothesis: Expectation greater than statistic\nsample estimates:\nGeary C statistic       Expectation          Variance \n        0.6907223         1.0000000         0.0073364 \n\n\nc-value = 0.69 < 1. Therefore, the data is clustered and neighbor observations tend to be similar. p-value is less than 0.05 and z-score is positive. Therefore, the spatial distribution of high values in the dataset is more spatially clustered than would be expected if underlying spatial processes were truly random.\n\nCompute Monte Carlo Geary’s C\nWe will conduct 1,000 simulations of Geary’s C using geary.mc().\n\nset.seed(1234)\nbperm = geary.mc(hunan$GDPPC,\n                 listw = rswm_q,\n                 nsim = 999)\nbperm\n\n\n    Monte-Carlo simulation of Geary C\n\ndata:  hunan$GDPPC \nweights: rswm_q \nnumber of simulations + 1: 1000 \n\nstatistic = 0.69072, observed rank = 1, p-value = 0.001\nalternative hypothesis: greater\n\n\nThe result of the simulation is also 0.69 with p-value less than 0.05, corroborating the result of Geary’s C test. We can say with 95% confidence that the data does not violate Geary’s C assumption of spatial randomness.\n\n\nVisualizing Monte Carlo Geary’s C\n\nmean(bperm$res)\n\n[1] 1.004089\n\n\n\nvar(bperm$res)\n\n[1] 0.007527444\n\n\n\nsummary(bperm$res)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.6907  0.9501  1.0050  1.0041  1.0594  1.2722 \n\n\n\nhist(bperm$res, freq = TRUE, breaks = 20, xlab = \"Simulated Geary's C\")\nabline(v = 1, col = \"red\")\n\n\n\n\nWe can see that C approaches 0, meaning similar data is clustered."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex02.html#spatial-correlogram",
    "href": "Hands-on_Ex/Hands-on_Ex02.html#spatial-correlogram",
    "title": "Global and Local Measures of Spatial Autocorrelation",
    "section": "Spatial Correlogram",
    "text": "Spatial Correlogram\n\nCompute Moran’s I correlogram\n\nMI_corr <- sp.correlogram(wm_q,\n                          hunan$GDPPC,\n                          order = 6,\n                          method = \"I\",\n                          style = \"W\")\nplot(MI_corr)\n\n\n\n\nBy plotting the output might not allow us to provide complete interpretation. This is because not all autocorrelation values are statistically significant. Hence, it is important for us to examine the full analysis report by printing out the analysis results as in the code chunk below.\n\nprint(MI_corr)\n\nSpatial correlogram for hunan$GDPPC \nmethod: Moran's I\n         estimate expectation   variance standard deviate Pr(I) two sided    \n1 (88)  0.3007500  -0.0114943  0.0043484           4.7351       2.189e-06 ***\n2 (88)  0.2060084  -0.0114943  0.0020962           4.7505       2.029e-06 ***\n3 (88)  0.0668273  -0.0114943  0.0014602           2.0496        0.040400 *  \n4 (88)  0.0299470  -0.0114943  0.0011717           1.2107        0.226015    \n5 (88) -0.1530471  -0.0114943  0.0012440          -4.0134       5.984e-05 ***\n6 (88) -0.1187070  -0.0114943  0.0016791          -2.6164        0.008886 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n\n\nCompute Geary’s C correlogram and plot\n\nCG_corr <- sp.correlogram(wm_q,\n                          hunan$GDPPC,\n                          order = 6,\n                          method = \"C\",\n                          style = \"W\")\nplot(CG_corr)\n\n\n\n\n\nprint(CG_corr)\n\nSpatial correlogram for hunan$GDPPC \nmethod: Geary's C\n        estimate expectation  variance standard deviate Pr(I) two sided    \n1 (88) 0.6907223   1.0000000 0.0073364          -3.6108       0.0003052 ***\n2 (88) 0.7630197   1.0000000 0.0049126          -3.3811       0.0007220 ***\n3 (88) 0.9397299   1.0000000 0.0049005          -0.8610       0.3892612    \n4 (88) 1.0098462   1.0000000 0.0039631           0.1564       0.8757128    \n5 (88) 1.2008204   1.0000000 0.0035568           3.3673       0.0007592 ***\n6 (88) 1.0773386   1.0000000 0.0058042           1.0151       0.3100407    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex02.html#cluster-and-outlier-analysis",
    "href": "Hands-on_Ex/Hands-on_Ex02.html#cluster-and-outlier-analysis",
    "title": "Global and Local Measures of Spatial Autocorrelation",
    "section": "Cluster and Outlier Analysis",
    "text": "Cluster and Outlier Analysis\n\nCompute local Moran’s I\nThe code chunks below are used to compute local Moran’s I of GDPPC2012 at the county level.\n\nfips <- order(hunan$County)\nlocalMI <- localmoran(hunan$GDPPC, rswm_q)\nhead(localMI)\n\n            Ii          E.Ii       Var.Ii        Z.Ii Pr(z != E(Ii))\n1 -0.001468468 -2.815006e-05 4.723841e-04 -0.06626904      0.9471636\n2  0.025878173 -6.061953e-04 1.016664e-02  0.26266425      0.7928094\n3 -0.011987646 -5.366648e-03 1.133362e-01 -0.01966705      0.9843090\n4  0.001022468 -2.404783e-07 5.105969e-06  0.45259801      0.6508382\n5  0.014814881 -6.829362e-05 1.449949e-03  0.39085814      0.6959021\n6 -0.038793829 -3.860263e-04 6.475559e-03 -0.47728835      0.6331568\n\n\nThe code chunk below list the content of the local Moran matrix derived by using printCoefmat().\n\nprintCoefmat(data.frame(localMI[fips,], row.names=hunan$County[fips]), check.names=FALSE)\n\n                       Ii        E.Ii      Var.Ii        Z.Ii Pr.z....E.Ii..\nAnhua         -2.2493e-02 -5.0048e-03  5.8235e-02 -7.2467e-02         0.9422\nAnren         -3.9932e-01 -7.0111e-03  7.0348e-02 -1.4791e+00         0.1391\nAnxiang       -1.4685e-03 -2.8150e-05  4.7238e-04 -6.6269e-02         0.9472\nBaojing        3.4737e-01 -5.0089e-03  8.3636e-02  1.2185e+00         0.2230\nChaling        2.0559e-02 -9.6812e-04  2.7711e-02  1.2932e-01         0.8971\nChangning     -2.9868e-05 -9.0010e-09  1.5105e-07 -7.6828e-02         0.9388\nChangsha       4.9022e+00 -2.1348e-01  2.3194e+00  3.3590e+00         0.0008\nChengbu        7.3725e-01 -1.0534e-02  2.2132e-01  1.5895e+00         0.1119\nChenxi         1.4544e-01 -2.8156e-03  4.7116e-02  6.8299e-01         0.4946\nCili           7.3176e-02 -1.6747e-03  4.7902e-02  3.4200e-01         0.7324\nDao            2.1420e-01 -2.0824e-03  4.4123e-02  1.0297e+00         0.3032\nDongan         1.5210e-01 -6.3485e-04  1.3471e-02  1.3159e+00         0.1882\nDongkou        5.2918e-01 -6.4461e-03  1.0748e-01  1.6338e+00         0.1023\nFenghuang      1.8013e-01 -6.2832e-03  1.3257e-01  5.1198e-01         0.6087\nGuidong       -5.9160e-01 -1.3086e-02  3.7003e-01 -9.5104e-01         0.3416\nGuiyang        1.8240e-01 -3.6908e-03  3.2610e-02  1.0305e+00         0.3028\nGuzhang        2.8466e-01 -8.5054e-03  1.4152e-01  7.7931e-01         0.4358\nHanshou        2.5878e-02 -6.0620e-04  1.0167e-02  2.6266e-01         0.7928\nHengdong       9.9964e-03 -4.9063e-04  6.7742e-03  1.2742e-01         0.8986\nHengnan        2.8064e-02 -3.2160e-04  3.7597e-03  4.6294e-01         0.6434\nHengshan      -5.8201e-03 -3.0437e-05  5.1076e-04 -2.5618e-01         0.7978\nHengyang       6.2997e-02 -1.3046e-03  2.1865e-02  4.3486e-01         0.6637\nHongjiang      1.8790e-01 -2.3019e-03  3.1725e-02  1.0678e+00         0.2856\nHuarong       -1.5389e-02 -1.8667e-03  8.1030e-02 -4.7503e-02         0.9621\nHuayuan        8.3772e-02 -8.5569e-04  2.4495e-02  5.4072e-01         0.5887\nHuitong        2.5997e-01 -5.2447e-03  1.1077e-01  7.9685e-01         0.4255\nJiahe         -1.2431e-01 -3.0550e-03  5.1111e-02 -5.3633e-01         0.5917\nJianghua       2.8651e-01 -3.8280e-03  8.0968e-02  1.0204e+00         0.3076\nJiangyong      2.4337e-01 -2.7082e-03  1.1746e-01  7.1800e-01         0.4728\nJingzhou       1.8270e-01 -8.5106e-04  2.4363e-02  1.1759e+00         0.2396\nJinshi        -1.1988e-02 -5.3666e-03  1.1334e-01 -1.9667e-02         0.9843\nJishou        -2.8680e-01 -2.6305e-03  4.4028e-02 -1.3543e+00         0.1756\nLanshan        6.3334e-02 -9.6365e-04  2.0441e-02  4.4972e-01         0.6529\nLeiyang        1.1581e-02 -1.4948e-04  2.5082e-03  2.3422e-01         0.8148\nLengshuijiang -1.7903e+00 -8.2129e-02  2.1598e+00 -1.1623e+00         0.2451\nLi             1.0225e-03 -2.4048e-07  5.1060e-06  4.5260e-01         0.6508\nLianyuan      -1.4672e-01 -1.8983e-03  1.9145e-02 -1.0467e+00         0.2952\nLiling         1.3774e+00 -1.5097e-02  4.2601e-01  2.1335e+00         0.0329\nLinli          1.4815e-02 -6.8294e-05  1.4499e-03  3.9086e-01         0.6959\nLinwu         -2.4621e-03 -9.0703e-06  1.9258e-04 -1.7676e-01         0.8597\nLinxiang       6.5904e-02 -2.9028e-03  2.5470e-01  1.3634e-01         0.8916\nLiuyang        3.3688e+00 -7.7502e-02  1.5180e+00  2.7972e+00         0.0052\nLonghui        8.0801e-01 -1.1377e-02  1.5538e-01  2.0787e+00         0.0376\nLongshan       7.5663e-01 -1.1100e-02  3.1449e-01  1.3690e+00         0.1710\nLuxi           1.8177e-01 -2.4855e-03  3.4249e-02  9.9561e-01         0.3194\nMayang         2.1852e-01 -5.8773e-03  9.8049e-02  7.1663e-01         0.4736\nMiluo          1.8704e+00 -1.6927e-02  2.7925e-01  3.5715e+00         0.0004\nNan           -9.5789e-03 -4.9497e-04  6.8341e-03 -1.0988e-01         0.9125\nNingxiang      1.5607e+00 -7.3878e-02  8.0012e-01  1.8274e+00         0.0676\nNingyuan       2.0910e-01 -7.0884e-03  8.2306e-02  7.5356e-01         0.4511\nPingjiang     -9.8964e-01 -2.6457e-03  5.6027e-02 -4.1698e+00         0.0000\nQidong         1.1806e-01 -2.1207e-03  2.4747e-02  7.6396e-01         0.4449\nQiyang         6.1966e-02 -7.3374e-04  8.5743e-03  6.7712e-01         0.4983\nRucheng       -3.6992e-01 -8.8999e-03  2.5272e-01 -7.1814e-01         0.4727\nSangzhi        2.5053e-01 -4.9470e-03  6.8000e-02  9.7972e-01         0.3272\nShaodong      -3.2659e-02 -3.6592e-05  5.0546e-04 -1.4510e+00         0.1468\nShaoshan       2.1223e+00 -5.0227e-02  1.3668e+00  1.8583e+00         0.0631\nShaoyang       5.9499e-01 -1.1253e-02  1.3012e-01  1.6807e+00         0.0928\nShimen        -3.8794e-02 -3.8603e-04  6.4756e-03 -4.7729e-01         0.6332\nShuangfeng     9.2835e-03 -2.2867e-03  3.1516e-02  6.5174e-02         0.9480\nShuangpai      8.0591e-02 -3.1366e-04  8.9838e-03  8.5358e-01         0.3933\nSuining        3.7585e-01 -3.5933e-03  4.1870e-02  1.8544e+00         0.0637\nTaojiang      -2.5394e-01 -1.2395e-03  1.4477e-02 -2.1002e+00         0.0357\nTaoyuan        1.4729e-02 -1.2039e-04  8.5103e-04  5.0903e-01         0.6107\nTongdao        4.6482e-01 -6.9870e-03  1.9879e-01  1.0582e+00         0.2900\nWangcheng      4.4220e+00 -1.1067e-01  1.3596e+00  3.8873e+00         0.0001\nWugang         7.1003e-01 -7.8144e-03  1.0710e-01  2.1935e+00         0.0283\nXiangtan       2.4530e-01 -3.6457e-04  3.2319e-03  4.3213e+00         0.0000\nXiangxiang     2.6271e-01 -1.2703e-03  2.1290e-02  1.8092e+00         0.0704\nXiangyin       5.4525e-01 -4.7442e-03  7.9236e-02  1.9539e+00         0.0507\nXinhua         1.1810e-01 -6.2649e-03  8.6001e-02  4.2409e-01         0.6715\nXinhuang       1.5725e-01 -4.1820e-03  3.6648e-01  2.6667e-01         0.7897\nXinning        6.8928e-01 -9.6674e-03  2.0328e-01  1.5502e+00         0.1211\nXinshao        5.7578e-02 -8.5932e-03  1.1769e-01  1.9289e-01         0.8470\nXintian       -7.4050e-03 -5.1493e-03  1.0877e-01 -6.8395e-03         0.9945\nXupu           3.2406e-01 -5.7468e-03  5.7735e-02  1.3726e+00         0.1699\nYanling       -6.9021e-02 -5.9211e-04  9.9306e-03 -6.8667e-01         0.4923\nYizhang       -2.6844e-01 -2.2463e-03  4.7588e-02 -1.2202e+00         0.2224\nYongshun       6.3064e-01 -1.1350e-02  1.8830e-01  1.4795e+00         0.1390\nYongxing       4.3411e-01 -9.0735e-03  1.5088e-01  1.1409e+00         0.2539\nYou            7.8750e-02 -7.2728e-03  1.2116e-01  2.4714e-01         0.8048\nYuanjiang      2.0004e-04 -1.7760e-04  2.9798e-03  6.9181e-03         0.9945\nYuanling       8.7298e-03 -2.2981e-06  2.3221e-05  1.8121e+00         0.0700\nYueyang        4.1189e-02 -1.9768e-04  2.3113e-03  8.6085e-01         0.3893\nZhijiang       1.0476e-01 -7.8123e-04  1.3100e-02  9.2214e-01         0.3565\nZhongfang     -2.2685e-01 -2.1455e-03  3.5927e-02 -1.1855e+00         0.2358\nZhuzhou        3.2864e-01 -5.2432e-04  7.2391e-03  3.8688e+00         0.0001\nZixing        -7.6849e-01 -8.8210e-02  9.4057e-01 -7.0144e-01         0.4830\n\n\n\nMap the local Moran’s I\n\nhunan.localMI <- cbind(hunan,localMI) %>%\n  rename(Pr.Ii = Pr.z....E.Ii..)\n\n\n\nMap the local Moran’s I values\n\ntm_shape(hunan.localMI) +\n  tm_fill(col = \"Ii\", \n          style = \"pretty\",\n          palette = \"RdBu\",\n          title = \"local moran statistics\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.text.size = 0.5)\n\nVariable(s) \"Ii\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n\n\n\n\n\n\n\nMapping local Moran’s I p-values\n\ntm_shape(hunan.localMI) +\n  tm_fill(col = \"Pr.Ii\", \n          breaks=c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),\n          palette=\"-Blues\", \n          title = \"local Moran's I p-values\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.text.size = 0.5)\n\n\n\n\n\n\nMap both local Moran’s I value and p’s value\nFor effective interpretation, it is better to plot both the local Moran’s I values map and its corresponding p-values map next to each other.\n\nlocalMI.map <- tm_shape(hunan.localMI) +\n  tm_fill(col = \"Ii\", \n          style = \"pretty\", \n          title = \"local moran statistics\") +\n  tm_borders(alpha = 0.5)+\n  tm_layout(legend.text.size = 0.4, legend.title.size = 0.5)\n\npvalue.map <- tm_shape(hunan.localMI) +\n  tm_fill(col = \"Pr.Ii\", \n          breaks=c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),\n          palette=\"-Blues\", \n          title = \"local Moran's I p-values\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.text.size = 0.4, legend.title.size = 0.5)\n\ntmap_arrange(localMI.map, pvalue.map, asp=1, ncol=2)\n\nVariable(s) \"Ii\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex02.html#create-a-lisa-cluster-map",
    "href": "Hands-on_Ex/Hands-on_Ex02.html#create-a-lisa-cluster-map",
    "title": "Global and Local Measures of Spatial Autocorrelation",
    "section": "Create a LISA Cluster Map",
    "text": "Create a LISA Cluster Map\nThe LISA Cluster Map shows the significant locations color coded by type of spatial autocorrelation. The first step before we can generate the LISA cluster map is to plot the Moran scatterplot.\n\nPlotting Moran’s scatter plot\nThe Moran scatterplot is an illustration of the relationship between the values of the chosen attribute at each location and the average value of the same attribute at neighboring locations.\n\nnci <- moran.plot(hunan$GDPPC, rswm_q,\n                  labels=as.character(hunan$County), \n                  xlab=\"GDPPC 2012\", \n                  ylab=\"Spatially Lag GDPPC 2012\")\n\n\n\n\nNotice that the plot is split in 4 quadrants. The top right corner belongs to areas that have high GDPPC and are surrounded by other areas that have the average level of GDPPC. This are the high-high locations in the lesson slide.\n\n\nPlotting Moran scatter plot with standardised variable\n\nhunan$Z.GDPPC <- scale(hunan$GDPPC) %>% as.vector \n\nThe as.vector() added to the end is to make sure that the data type we get out of this is a vector, that map neatly into out dataframe.\n\nnci2 <- moran.plot(hunan$Z.GDPPC, rswm_q,\n                   labels=as.character(hunan$County),\n                   xlab=\"z-GDPPC 2012\", \n                   ylab=\"Spatially Lag z-GDPPC 2012\")\n\n\n\n\n\n\nPreparing LISA map classes\nStep 1: define the quadrant\n\nquadrant <- vector(mode=\"numeric\",length=nrow(localMI))\n\nStep 2: center the variable of interest around its means\n\nDV <- hunan$GDPPC - mean(hunan$GDPPC)     \n\nStep 3: center the local Moran around the mean\n\nC_mI <- localMI[,1] - mean(localMI[,1])    \n\nStep 4: set a statistical significance level for the local Moran\n\nsignif <- 0.05       \n\nThese four command lines define the high-high, low-low, low-high and high-low categories.\n\nquadrant[DV >0 & C_mI>0] <- 4      \nquadrant[DV <0 & C_mI<0] <- 1      \nquadrant[DV <0 & C_mI>0] <- 2\nquadrant[DV >0 & C_mI<0] <- 3\n\nStep 5: place non-significant Moran in the category 0\n\nquadrant[localMI[,5]>signif] <- 0\n\nWe can combined all the steps into one single code chunk as shown below.\n\nquadrant <- vector(mode=\"numeric\",length=nrow(localMI))\nDV <- hunan$GDPPC - mean(hunan$GDPPC)     \nC_mI <- localMI[,1] - mean(localMI[,1])    \nsignif <- 0.05       \nquadrant[DV >0 & C_mI>0] <- 4      \nquadrant[DV <0 & C_mI<0] <- 1      \nquadrant[DV <0 & C_mI>0] <- 2\nquadrant[DV >0 & C_mI<0] <- 3\nquadrant[localMI[,5]>signif] <- 0\n\n\n\nPlotting LISA map\n\nhunan.localMI$quadrant <- quadrant\ncolors <- c(\"#ffffff\", \"#2c7bb6\", \"#abd9e9\", \"#fdae61\", \"#d7191c\")\nclusters <- c(\"insignificant\", \"low-low\", \"low-high\", \"high-low\", \"high-high\")\n\ntm_shape(hunan.localMI) +\n  tm_fill(col = \"quadrant\", \n          style = \"cat\", \n          palette = colors[c(sort(unique(quadrant)))+1], \n          labels = clusters[c(sort(unique(quadrant)))+1],\n          popup.vars = c(\"\")) +\n  tm_view(set.zoom.limits = c(11,17)) +\n  tm_borders(alpha=0.5) +\n  tm_layout(legend.text.size = 0.5)\n\n\n\n\nFor effective interpretation, it is better to plot both the local Moran’s I values map and its corresponding p-values map next to each other.\n\ngdppc <- qtm(hunan, \"GDPPC\") +\n  tm_layout(legend.text.size = 0.5, legend.title.size = 0.6)\n\nhunan.localMI$quadrant <- quadrant\ncolors <- c(\"#ffffff\", \"#2c7bb6\", \"#abd9e9\", \"#fdae61\", \"#d7191c\")\nclusters <- c(\"insignificant\", \"low-low\", \"low-high\", \"high-low\", \"high-high\")\n\nLISAmap <- tm_shape(hunan.localMI) +\n  tm_fill(col = \"quadrant\", \n          style = \"cat\", \n          palette = colors[c(sort(unique(quadrant)))+1], \n          labels = clusters[c(sort(unique(quadrant)))+1],\n          popup.vars = c(\"\")) +\n  tm_view(set.zoom.limits = c(11,17)) +\n  tm_borders(alpha=0.5) +\n  tm_layout(legend.text.size = 0.5, legend.title.size = 0.6)\n\ntmap_arrange(gdppc, LISAmap, asp=1, ncol=2)\n\n\n\n\nThe red counties signify positive autocorrelation with high-value clusters surrounded by high-value neighbors. Those areas have high values of GDPPC in correlation with nearby counties that also have high GDPPC.\nThe darkblue counties signify positive autocorrelation with low-value clusters surrounded by low-value neighbors. They are the counties with relatively lower value of GDPPC in correlation with nearby counties with low GDPPC. For development planning, they need more investment because while being close to developed areas with generally higher GDPPC, it looks like they are not yet benefiting from the development of the region.\nThe light orange county shows that it is an outlier that has higher value than nearby lower neighbors. Spatial-wise, this county is more developed than its nearby counties and is getting the synergy of nearby counties with higher GDPPC.\nThe light blue counties are outlier with lower GDPPC than their neighbor counties. Being the remote counties far away from the more developed areas, they are the least developed counties that are lagged behind, requiring attention for development investment."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex02.html#hot-spot-and-cold-spot-area-analysis",
    "href": "Hands-on_Ex/Hands-on_Ex02.html#hot-spot-and-cold-spot-area-analysis",
    "title": "Global and Local Measures of Spatial Autocorrelation",
    "section": "Hot Spot and Cold Spot Area Analysis",
    "text": "Hot Spot and Cold Spot Area Analysis\nBeside detecting cluster and outliers, localised spatial statistics can be also used to detect hot spot and/or cold spot areas.\nThe term ‘hot spot’ has been used generically across disciplines to describe a region or value that is higher relative to its surroundings (Lepers et al 2005, Aben et al 2012, Isobe et al 2015).\n\nGetis and Ord’s G-Statistics\nAn alternative spatial statistics to detect spatial anomalies is the Getis and Ord’s G-statistics (Getis and Ord, 1972; Ord and Getis, 1995). It looks at neighbours within a defined proximity to identify where either high or low values clutser spatially. Here, statistically significant hot-spots are recognised as areas of high values where other areas within a neighbourhood range also share high values too.\nThe analysis consists of three steps:\n\nDeriving spatial weight matrix\nComputing Gi statistics\nMapping Gi statistics\n\n\n\nDeriving distance-based weight matrix\n\nDeriving the centroid\nTo get our longitude values we map the st_centroid() function over the geometry column of us.bound and access the longitude value through double bracket notation [[]] and 1. This allows us to get only the longitude, which is the first value in each centroid.\n\nlongitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])\n\nWe do the same for latitude with one key difference. We access the second value per each centroid with [[2]].\n\nlatitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])\n\nUse bin to put longitude and lattitude into the same object.\n\ncoords <- cbind(longitude, latitude)\n\n\n\nDetermine the cut-off distance\n\n#coords <- coordinates(hunan)\nk1 <- knn2nb(knearneigh(coords))\nk1dists <- unlist(nbdists(k1, coords, longlat = TRUE))\nsummary(k1dists)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  24.79   32.57   38.01   39.07   44.52   61.79 \n\n\nThe summary report shows that the largest first nearest neighbour distance is 61.79 km, so using this as the upper threshold gives certainty that all units will have at least one neighbour.\n\n\nComputing fixed distance weight matrix\n\nwm_d62 <- dnearneigh(coords, 0, 62, longlat = TRUE)\nwm_d62\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \n\n\n\nwm62_lw <- nb2listw(wm_d62, style = 'B')\nsummary(wm62_lw)\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 324 \nPercentage nonzero weights: 4.183884 \nAverage number of links: 3.681818 \nLink number distribution:\n\n 1  2  3  4  5  6 \n 6 15 14 26 20  7 \n6 least connected regions:\n6 15 30 32 56 65 with 1 link\n7 most connected regions:\n21 28 35 45 50 52 82 with 6 links\n\nWeights style: B \nWeights constants summary:\n   n   nn  S0  S1   S2\nB 88 7744 324 648 5440\n\n\nThe output spatial weights object is called wm62_lw.\n\n\n\nComputing adaptive distance weight matrix\nOne of the characteristics of fixed distance weight matrix is that more densely settled areas (usually the urban areas) tend to have more neighbors and the less densely settled areas (usually the rural counties) tend to have lesser neighbors. Having many neighbors smoothes the neighbor relationship across more neighbors.\n\nknn <- knn2nb(knearneigh(coords, k=8))\nknn\n\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 704 \nPercentage nonzero weights: 9.090909 \nAverage number of links: 8 \nNon-symmetric neighbours list\n\n\n\nknn_lw <- nb2listw(knn, style = 'B')\nsummary(knn_lw)\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 88 \nNumber of nonzero links: 704 \nPercentage nonzero weights: 9.090909 \nAverage number of links: 8 \nNon-symmetric neighbours list\nLink number distribution:\n\n 8 \n88 \n88 least connected regions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 with 8 links\n88 most connected regions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 with 8 links\n\nWeights style: B \nWeights constants summary:\n   n   nn  S0   S1    S2\nB 88 7744 704 1300 23014"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex02.html#computing-gi-statistics",
    "href": "Hands-on_Ex/Hands-on_Ex02.html#computing-gi-statistics",
    "title": "Global and Local Measures of Spatial Autocorrelation",
    "section": "Computing Gi statistics",
    "text": "Computing Gi statistics\n\nGi statistics using fixed distance\n\nfips <- order(hunan$County)\ngi.fixed <- localG(hunan$GDPPC, wm62_lw)\ngi.fixed\n\n [1]  0.436075843 -0.265505650 -0.073033665  0.413017033  0.273070579\n [6] -0.377510776  2.863898821  2.794350420  5.216125401  0.228236603\n[11]  0.951035346 -0.536334231  0.176761556  1.195564020 -0.033020610\n[16]  1.378081093 -0.585756761 -0.419680565  0.258805141  0.012056111\n[21] -0.145716531 -0.027158687 -0.318615290 -0.748946051 -0.961700582\n[26] -0.796851342 -1.033949773 -0.460979158 -0.885240161 -0.266671512\n[31] -0.886168613 -0.855476971 -0.922143185 -1.162328599  0.735582222\n[36] -0.003358489 -0.967459309 -1.259299080 -1.452256513 -1.540671121\n[41] -1.395011407 -1.681505286 -1.314110709 -0.767944457 -0.192889342\n[46]  2.720804542  1.809191360 -1.218469473 -0.511984469 -0.834546363\n[51] -0.908179070 -1.541081516 -1.192199867 -1.075080164 -1.631075961\n[56] -0.743472246  0.418842387  0.832943753 -0.710289083 -0.449718820\n[61] -0.493238743 -1.083386776  0.042979051  0.008596093  0.136337469\n[66]  2.203411744  2.690329952  4.453703219 -0.340842743 -0.129318589\n[71]  0.737806634 -1.246912658  0.666667559  1.088613505 -0.985792573\n[76]  1.233609606 -0.487196415  1.626174042 -1.060416797  0.425361422\n[81] -0.837897118 -0.314565243  0.371456331  4.424392623 -0.109566928\n[86]  1.364597995 -1.029658605 -0.718000620\nattr(,\"cluster\")\n [1] Low  Low  High High High High High High High Low  Low  High Low  Low  Low \n[16] High High High High Low  High High Low  Low  High Low  Low  Low  Low  Low \n[31] Low  Low  Low  High Low  Low  Low  Low  Low  Low  High Low  Low  Low  Low \n[46] High High Low  Low  Low  Low  High Low  Low  Low  Low  Low  High Low  Low \n[61] Low  Low  Low  High High High Low  High Low  Low  High Low  High High Low \n[76] High Low  Low  Low  Low  Low  Low  High High Low  High Low  Low \nLevels: Low High\nattr(,\"gstari\")\n[1] FALSE\nattr(,\"call\")\nlocalG(x = hunan$GDPPC, listw = wm62_lw)\nattr(,\"class\")\n[1] \"localG\"\n\n\nThe output of localG() is a vector of G or Gstar values, with attributes “gstari” set to TRUE or FALSE, “call” set to the function call, and class “localG”.\nThe Gi statistics is represented as a Z-score. Greater values represent a greater intensity of clustering and the direction (positive or negative) indicates high or low clusters.\nJoin the Gi values to their corresponding hunan sf data frame\n\nhunan.gi <- cbind(hunan, as.matrix(gi.fixed)) %>%\n  rename(gstat_fixed = as.matrix.gi.fixed.)\n\n\n\nMapping Gi values with fixed distance weights\n\ngdppc <- qtm(hunan, \"GDPPC\") +\n  tm_layout(legend.text.size = 0.5, legend.title.size = 0.5)\n\nGimap <-tm_shape(hunan.gi) +\n  tm_fill(col = \"gstat_fixed\", \n          style = \"pretty\",\n          palette=\"-RdBu\",\n          title = \"local Gi\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.text.size = 0.5, legend.title.size = 0.5)\n\ntmap_arrange(gdppc, Gimap, asp=1, ncol=2)\n\nVariable(s) \"gstat_fixed\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n\n\n\n\n\nThe fixed distance weight method reveals the hot spots, which are areas with higher GDPPC values among their neighbors, and cold spots, which have lower GDPPC value among their neighbors. However, due to the varying size of the counties, the fixed distance method shows scattering clusters which is not very useful for development decision.\n\n\nGi statistics using adaptive distance\n\nfips <- order(hunan$County)\ngi.adaptive <- localG(hunan$GDPPC, knn_lw)\nhunan.gi <- cbind(hunan, as.matrix(gi.adaptive)) %>%\n  rename(gstat_adaptive = as.matrix.gi.adaptive.)\n\n\n\nMapping Gi values with adaptive distance weights\n\ngdppc<- qtm(hunan, \"GDPPC\") +\n  tm_layout(legend.text.size = 0.6, legend.title.size = 0.6)\n\nGimap <- tm_shape(hunan.gi) + \n  tm_fill(col = \"gstat_adaptive\", \n          style = \"pretty\", \n          palette=\"-RdBu\", \n          title = \"local Gi\") + \n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.text.size = 0.6, legend.title.size = 0.6)\n\ntmap_arrange(gdppc, \n             Gimap, \n             asp=1, \n             ncol=2)\n\nVariable(s) \"gstat_adaptive\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n\n\n\n\n\nThe adaptive distance weight method shows clear border clusters. For the map on the right, we can see the hot spot areas with higher GDPPC than their neighbors being closer or overlap with high GDPPC counties. From this map, we can also see the ripple effect on GDPPC caused by the higher developed counties to the nearby provinces on the eastern side of Hunan. This map also shows the cold spot areas located on the far west side of Hunan with GDPPC being lower than their neighbors. They are the counties that are lagged behind in terms of GDPPC and may need the attention to development investment."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex2/In-class_Ex2.html",
    "href": "In-class_Ex/In-class_Ex2/In-class_Ex2.html",
    "title": "Birds of a feather flock together: Do functionally similar water points positively co-occur in Nigeria?",
    "section": "",
    "text": "In the code chunk below, p_load() of pacman package is used to install and load the following R packages into R environment:\n\nsf,\ntidyverse,\ntmap,\nspdep, and\nfunModeling will be used for rapid Exploratory Data Analysis\n\n\npacman::p_load(sf, tidyverse, tmap, spdep, funModeling)"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex2/In-class_Ex2.html#importing-geospatial-data",
    "href": "In-class_Ex/In-class_Ex2/In-class_Ex2.html#importing-geospatial-data",
    "title": "Birds of a feather flock together: Do functionally similar water points positively co-occur in Nigeria?",
    "section": "Importing Geospatial Data",
    "text": "Importing Geospatial Data\nIn this in-class data, two geospatial data sets will be used, they are:\n\ngeo_export\nnga_admbnda_adm2_osgof_20190417\n\n\nwp <- st_read(dsn = \"data\",\n              layer = \"geo_export\",\n              crs = 4326) %>%\n  filter(clean_coun == \"Nigeria\")\n\nReading layer `geo_export' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/In-class_Ex/In-class_Ex2/data' \n  using driver `ESRI Shapefile'\nSimple feature collection with 406566 features and 72 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -92.05073 ymin: -27.31495 xmax: 92.32694 ymax: 26.65622\nGeodetic CRS:  WGS 84\n\n\nThings to learn from the code chunk above:\n\nst_read() of sf package is used to import geo_export shapefile into R environment and save the imported geospatial data into simple feature data table.\nfilter() of dplyr package is used to extract water point records of Nigeria.\n\n\nBe warned: Avoid performing transformation if you plan to use st_intersects() of sf package in the later stage of the geoprocessing. This is because st_intersects() only works correctly if the geospatial data are in geographic coordinate system (i.e. wgs84).\nReminder: CRS stands for Coordinate Reference System.\n\nNext, write_rds() of readr package is used to save the extracted sf data table (i.e. wp) into an output file in rds data format. The output file is called wp_nga.rds and it is saved in data sub-folder.\n\nwrite_rds(wp, \"data/wp_nga.rds\")\n\n\nImporting Nigeria LGA boundary data\nNow, we are going to import the LGA boundary data into R environment by using the code chunk below.\n\nnga <- st_read(dsn = \"data\",\n               layer = \"geoBoundaries-NGA-ADM2\",\n               crs = 4326)\n\nReading layer `geoBoundaries-NGA-ADM2' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/In-class_Ex/In-class_Ex2/data' \n  using driver `ESRI Shapefile'\nSimple feature collection with 774 features and 5 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2.668534 ymin: 4.273007 xmax: 14.67882 ymax: 13.89442\nGeodetic CRS:  WGS 84\n\n\nst_read() of sf package is used to import geoBoundaries-NGA-ADM2 shapefile into R environment and save the imported geospatial data into simple feature data table."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex2/In-class_Ex2.html#data-wrangling",
    "href": "In-class_Ex/In-class_Ex2/In-class_Ex2.html#data-wrangling",
    "title": "Birds of a feather flock together: Do functionally similar water points positively co-occur in Nigeria?",
    "section": "Data Wrangling",
    "text": "Data Wrangling\n\nRecoding NA values into string\nIn the code chunk below, replace_na() is used to recode all the NA values in status_cle field into Unknown.\n\nwp_nga <- read_rds(\"data/wp_nga.rds\") %>%\n  mutate(status_cle = replace_na(status_cle, \"Unknown\"))\n\n\n\nEDA\nIn the code chunk below, freq() of funModeling package is used to display the distribution of status_cle field in wp_nga.\n\nfreq(data=wp_nga, \n     input = 'status_cle')\n\n\n\n\n                        status_cle frequency percentage cumulative_perc\n1                       Functional     45883      48.29           48.29\n2                   Non-Functional     29385      30.93           79.22\n3                          Unknown     10656      11.22           90.44\n4      Functional but needs repair      4579       4.82           95.26\n5 Non-Functional due to dry season      2403       2.53           97.79\n6        Functional but not in use      1686       1.77           99.56\n7         Abandoned/Decommissioned       234       0.25           99.81\n8                        Abandoned       175       0.18           99.99\n9 Non functional due to dry season         7       0.01          100.00"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex2/In-class_Ex2.html#extracting-water-point-data",
    "href": "In-class_Ex/In-class_Ex2/In-class_Ex2.html#extracting-water-point-data",
    "title": "Birds of a feather flock together: Do functionally similar water points positively co-occur in Nigeria?",
    "section": "Extracting Water Point Data",
    "text": "Extracting Water Point Data\nIn this section, we will extract the water point records by using classes in status_cle field.\n\nExtracting funtional water point\nIn the code chunk below, filter() of dplyr is used to select functional water points.\n\nwpt_functional <- wp_nga %>%\n  filter(status_cle %in%\n           c(\"Functional\", \n             \"Functional but not in use\",\n             \"Functional but needs repair\"))\n\n\nfreq(data=wpt_functional, \n     input = 'status_cle')\n\n\n\n\n                   status_cle frequency percentage cumulative_perc\n1                  Functional     45883      87.99           87.99\n2 Functional but needs repair      4579       8.78           96.77\n3   Functional but not in use      1686       3.23          100.00\n\n\n\n\nExtracting non-functional water point\nIn the code chunk below, filter() of dplyr is used to select non-functional water points.\n\nwpt_nonfunctional <- wp_nga %>%\n  filter(status_cle %in%\n           c(\"Abandoned/Decommissioned\", \n             \"Abandoned\",\n             \"Non-Functional\",\n             \"Non functional due to dry season\",\n             \"Non-Functional due to dry season\"))\n\n\nfreq(data=wpt_nonfunctional, \n     input = 'status_cle')\n\n\n\n\n                        status_cle frequency percentage cumulative_perc\n1                   Non-Functional     29385      91.25           91.25\n2 Non-Functional due to dry season      2403       7.46           98.71\n3         Abandoned/Decommissioned       234       0.73           99.44\n4                        Abandoned       175       0.54           99.98\n5 Non functional due to dry season         7       0.02          100.00\n\n\n\n\nExtracting water point with Unknown class\nIn the code chunk below, filter() of dplyr is used to select water points with unknown status.\n\nwpt_unknown <- wp_nga %>%\n  filter(status_cle == \"Unknown\")"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex2/In-class_Ex2.html#performing-point-in-polygon-count",
    "href": "In-class_Ex/In-class_Ex2/In-class_Ex2.html#performing-point-in-polygon-count",
    "title": "Birds of a feather flock together: Do functionally similar water points positively co-occur in Nigeria?",
    "section": "Performing Point-in-Polygon Count",
    "text": "Performing Point-in-Polygon Count\n\nnga_wp <- nga %>% \n  mutate(`total wpt` = lengths(\n    st_intersects(nga, wp_nga))) %>%\n  mutate(`wpt functional` = lengths(\n    st_intersects(nga, wpt_functional))) %>%\n  mutate(`wpt non-functional` = lengths(\n    st_intersects(nga, wpt_nonfunctional))) %>%\n  mutate(`wpt unknown` = lengths(\n    st_intersects(nga, wpt_unknown)))"
  },
  {
    "objectID": "In-class_Ex/In-class_Ex2/In-class_Ex2.html#saving-the-analytical-data-table",
    "href": "In-class_Ex/In-class_Ex2/In-class_Ex2.html#saving-the-analytical-data-table",
    "title": "Birds of a feather flock together: Do functionally similar water points positively co-occur in Nigeria?",
    "section": "Saving the Analytical Data Table",
    "text": "Saving the Analytical Data Table\n\nnga_wp <- nga_wp %>%\n  mutate(pct_functional = `wpt functional`/`total wpt`) %>%\n  mutate(`pct_non-functional` = `wpt non-functional`/`total wpt`)\n\nThings to learn from the code chunk above:\n\nmutate() of dplyr package is used to derive two fields namely pct_functional and pct_non-functional.\n\nNow, you have the tidy sf data table subsequent analysis. We will save the sf data table into rds format.\n\nwrite_rds(nga_wp, \"data/nga_wp.rds\")\n\nBefore you end this section, please remember to delete away all the raw data. Notice that the only data file left is nga_wp.rds and it’s file size is aroung 2.1MB."
  },
  {
    "objectID": "In-class_Ex/In-class_Ex2/In-class_Ex2.html#visualising-the-spatial-dsitribution-of-water-points",
    "href": "In-class_Ex/In-class_Ex2/In-class_Ex2.html#visualising-the-spatial-dsitribution-of-water-points",
    "title": "Birds of a feather flock together: Do functionally similar water points positively co-occur in Nigeria?",
    "section": "Visualising the spatial dsitribution of water points",
    "text": "Visualising the spatial dsitribution of water points\n\nnga_wp <- read_rds(\"data/nga_wp.rds\")\ntotal <- qtm(nga_wp, \"total wpt\") + tm_layout(legend.text.size = 0.4, legend.title.size = 0.5)\nwp_functional <- qtm(nga_wp, \"wpt functional\") + tm_layout(legend.text.size = 0.4, legend.title.size = 0.5)\nwp_nonfunctional <- qtm(nga_wp, \"wpt non-functional\") + tm_layout(legend.text.size = 0.4, legend.title.size = 0.5)\nunknown <- qtm(nga_wp, \"wpt unknown\") + tm_layout(legend.text.size = 0.4, legend.title.size = 0.5)\n\ntmap_arrange(total, wp_functional, wp_nonfunctional, unknown, nrow = 2, ncol=2)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html",
    "title": "Take-home Exercise 1: How Functional are the Water Points in Nigeria?",
    "section": "",
    "text": "Water is a critical asset of all communities and nations. It is the core neccessity to sustain the life of both humans and livestock. Lack of access to potable water can lead to serious health hazards and even conflicts between communities and states. According to a 2022 report by World Bank, about 70 million Nigerians do not have access to drinkable water. Access to piped water has decreased from 39% in 1990 to only 11% in 2021. This phenomenon contributes to a surge in violence in Nigeria when communities Fulani herders ad farmers fight over water supplies.\nWhy is there a water crisis in Nigeria? To gain a perspective on the answer, we will examine the quality and distribution of water supply points in Nigeria.\n\n\n\nThe objective of this exercise is to apply appropriate global and local measures of spatial association techniques to reveals the spatial patterns of non-functional water points in Nigeria."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#setup",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#setup",
    "title": "Take-home Exercise 1: How Functional are the Water Points in Nigeria?",
    "section": "Setup",
    "text": "Setup\n\nData\n\nAspatial Data\nThe aspatial data of water points quality, status and other relevant information is taken from WPdx Global Data Repositories - WPdx+ version. The data set is downloaded in Shapefile format.\n\n\nGeospatial Data\nThe geospatial data of Nigeria administrative regions is downloaded from Geoboundaries. The data level of ADM2, published in 2020, will be used.\n\n\n\nR Packages Used\n\nsf: used for importing, managing, and processing geospatial data\ntidyverse: a collection of packages for data science tasks. It contains the sub-packages dplyr, ggplot2, forcats, tibble, readr, stringr, tidyr, purrr\ntmap: used for creating thematic maps, such as choropleth and bubble maps\nspdep: used for calculating spatial dependence - weighting schemes and statistics\nfunModeling: used for EDA and data preparation\n\nWe load the packages into our working environment using the code below.\n\n\nShow code\npacman::p_load(sf, tidyverse, tmap, spdep, funModeling)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#data-wrangling",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#data-wrangling",
    "title": "Take-home Exercise 1: How Functional are the Water Points in Nigeria?",
    "section": "Data Wrangling",
    "text": "Data Wrangling\n\nGeospatial Data\n\nImport the water point geospatial data\nThe data from WPdx Global Data Repositories comes in four files in dbf, prj, shp, shx formats. The files are renamed into geo_export for a more convenient reference.\nUsing st_read() from the sf package, we import the aspatial data into our working environment. The data is imported as a simple feature data table.\n\nwp <- st_read(dsn = \"data\", layer = \"geo_export\")\n\nReading layer `geo_export' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/Take-home_Ex/Take-home_Ex1/data' \n  using driver `ESRI Shapefile'\nSimple feature collection with 406566 features and 72 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -92.05073 ymin: -27.31495 xmax: 92.32694 ymax: 26.65622\nGeodetic CRS:  WGS84(DD)\n\n\n\n\nCheck the content of water point simple feature data frame\nFirst, we use st_geometry() to check the geometry list column of wp. There are 406,566 observations under the WGS84 coordinate reference system (CRS).\n\nst_geometry(wp)\n\nGeometry set for 406566 features \nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -92.05073 ymin: -27.31495 xmax: 92.32694 ymax: 26.65622\nGeodetic CRS:  WGS84(DD)\nFirst 5 geometries:\n\n\nSince the shapefile is in WGS84 CRS, we will assign crs = 4326 to wp. 4326 is the code of WGS84 in EPSG code. The task is conducted using st_set_crs().\n\nwp <- st_set_crs(wp, 4326)\n\nNext, we will examine the attributes in the data table using glimpse() from dplyr.\n\nglimpse(wp)\n\nRows: 406,566\nColumns: 73\n$ row_id      <dbl> 651816, 584864, 509399, 21983, 660321, 666619, 657081, 669…\n$ source      <chr> \"Water For People\", \"Global Environment and Technology Fou…\n$ lat_deg     <dbl> -15.726464200, 6.723120000, 8.001933333, 8.084948140, 0.18…\n$ lon_deg     <dbl> 35.05067, -1.58151, -11.28760, -10.12595, 30.44659, 30.352…\n$ date_repor  <date> 2018-06-11, 2017-10-25, 2010-12-31, 2015-12-04, 2019-03-1…\n$ time_repor  <chr> \"00:00:00.000\", \"00:00:00.000\", \"00:00:00.000\", \"00:00:00.…\n$ status_id   <chr> \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Y…\n$ water_sour  <chr> NA, NA, NA, NA, \"Piped Water\", \"Piped Water\", NA, NA, NA, …\n$ water_so_2  <chr> NA, NA, NA, NA, \"Piped Water\", \"Piped Water\", NA, NA, NA, …\n$ water_te_2  <chr> \"Kiosk\", \"Tapstand\", \"Tapstand\", \"Tapstand\", NA, NA, \"Taps…\n$ X_water_tec <chr> \"Tapstand\", \"Tapstand\", \"Tapstand\", \"Tapstand\", NA, NA, \"T…\n$ facility_t  <chr> \"Improved\", \"Improved\", \"Improved\", \"Improved\", \"Improved\"…\n$ clean_coun  <chr> \"Malawi\", \"Ghana\", \"Sierra Leone\", \"Liberia\", \"Uganda\", \"U…\n$ clean_adm1  <chr> \"Blantyre\", \"Ashanti\", \"Eastern\", \"Lofa\", \"Western\", \"West…\n$ clean_adm2  <chr> \"Blantyre City\", \"Asokore Mampong Municipal\", \"Kenema\", \"K…\n$ clean_adm3  <chr> \"n.a. (2465)\", NA, \"Kando Leppeama\", \"Lucasu\", \"Kibale\", \"…\n$ clean_adm4  <chr> NA, NA, NA, NA, \"Kamwenge Town Council\", \"Buhanda\", \"Mahyo…\n$ install_ye  <dbl> NA, 2017, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ installer   <chr> NA, NA, \"Water Aid\", NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ rehab_year  <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ rehabilita  <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ manageme_2  <chr> NA, NA, NA, \"School Management\", NA, NA, NA, NA, NA, NA, N…\n$ status_cle  <chr> NA, NA, \"Functional\", NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ pay         <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ fecal_coli  <chr> NA, NA, NA, NA, \"Present\", \"Present\", \"Present\", NA, NA, \"…\n$ fecal_co_2  <chr> NA, \"0\", NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ subjective  <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ activity_i  <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ scheme_id   <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ wpdx_id     <chr> \"5GPQ73F2+C77\", \"6CRWPCF9+69X\", \"6CWC2P26+QXC\", \"6CWF3VMF+…\n$ notes       <chr> NA, NA, \"Poor?Jenneh?Kandu Leppiema??\", NA, NA, NA, NA, NA…\n$ orig_lnk    <chr> NA, NA, NA, \"https://wash-liberia.org/raw-water-point-data…\n$ photo_lnk   <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ country_id  <chr> \"MW\", \"GH\", \"SL\", \"LR\", \"UG\", \"UG\", \"UG\", \"UG\", \"UG\", \"UG\"…\n$ data_lnk    <chr> \"https://catalog.waterpointdata.org/datasets/wfp-2017-2020…\n$ distance_t  <dbl> 7034.8250, 3677.9101, 17540.3622, 21602.1376, 31948.1224, …\n$ distance_2  <dbl> 3431.81039, 3944.70081, 4052.93329, 37030.19501, 593.69582…\n$ distance_3  <dbl> 421.90674, 690.13048, 104.43156, 14456.72395, 149.01742, 1…\n$ distance_4  <dbl> 8321.854, 5362.011, 17003.136, 52727.389, 40206.411, 38061…\n$ distance_5  <dbl> 22044.5149, 7550.3392, 15474.4428, 31606.4649, 35770.4357,…\n$ water_poin  <chr> \"{\\\"2018-06-11\\\": {\\\"source\\\": \\\"Water For People\\\", \\\"sta…\n$ rehab_prio  <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ served_pop  <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ local_popu  <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ crucialnes  <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ pressure    <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ usage_cap   <dbl> 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250…\n$ is_urban    <chr> \"True\", \"True\", \"False\", \"False\", \"False\", \"False\", \"False…\n$ days_since  <dbl> 1562, 1791, 4281, 2482, 1286, 1281, 1660, 6222, 1663, 1280…\n$ staleness_  <dbl> 61.11805, 56.86178, 25.93887, 45.73258, 66.67340, 66.77856…\n$ is_latest   <chr> \"T\", \"T\", \"T\", \"T\", \"T\", \"T\", \"T\", \"T\", \"T\", \"T\", \"T\", \"T\"…\n$ location_i  <dbl> 355848, 349148, 98255, 285679, 362508, 362657, 351144, 777…\n$ cluster_si  <dbl> 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ clean_co_2  <chr> \"MWI\", \"GHA\", \"SLE\", \"LBR\", \"UGA\", \"UGA\", \"UGA\", \"UGA\", \"U…\n$ country_na  <chr> \"Malawi\", \"Ghana\", \"Sierra Leone\", \"Liberia\", \"Uganda\", \"U…\n$ water_so_3  <chr> NA, NA, \"Gravity stand-post\", \"Public standpipe\", NA, NA, …\n$ water_tech  <chr> \"Communal water kiosk\", \"Standpost\", NA, NA, \"Pumped piped…\n$ status      <chr> \"1\", NA, \"Functional\", NA, \"1\", \"0\", \"1\", \"1\", \"1\", \"1\", N…\n$ adm2        <chr> \"Kameza\", NA, \"Kenema\", NA, \"Kibale\", \"Kitagwenda\", \"Kitag…\n$ adm3        <chr> NA, NA, NA, NA, \"Kamwenge T/Council\", \"Buhanda\", \"Mahyoro\"…\n$ management  <chr> NA, NA, NA, \"Institutional Management - School\", NA, NA, N…\n$ adm1        <chr> \"Blantyre\", NA, \"Eastern\", \"Lofa\", \"Kamwenge\", \"Kamwenge\",…\n$ lat_deg_or  <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ lat_lon_de  <chr> \"(-15.7264642?, 35.0506729?)\", \"(6.72312?, -1.58151?)\", \"(…\n$ lon_deg_or  <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ public_dat  <chr> \"https://catalog.waterpointdata.org/datafiles/wfp-2017-202…\n$ converted   <chr> NA, NA, \"#install_year, #notes\", \"#status\", NA, NA, NA, NA…\n$ count       <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ date_creat  <date> 2022-02-18, 2020-07-29, 2020-07-30, 2020-09-11, 2022-02-1…\n$ time_creat  <chr> \"05:36:33.000\", \"19:21:47.000\", \"08:35:45.000\", \"11:22:31.…\n$ date_updat  <date> 2022-02-18, 2020-07-29, 2020-07-30, 2020-09-11, 2022-02-1…\n$ time_updat  <chr> \"05:36:33.000\", \"19:21:47.000\", \"08:35:45.000\", \"11:22:31.…\n$ geometry    <POINT [°]> POINT (35.05067 -15.72646), POINT (-1.58151 6.72312)…"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#importing-data",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#importing-data",
    "title": "Take-home Exercise 1: How Functional are the Water Points in Nigeria?",
    "section": "Importing Data",
    "text": "Importing Data\n\nImporting Nigeria water point geospatial data\nThe data from WPdx Global Data Repositories comes in four files in dbf, prj, shp, shx formats. The files are renamed into geo_export for a more convenient reference.\nUsing st_read() from the sf package, we import the aspatial data into our working environment. The data is imported as a simple feature data table.\n\n\nShow code\nwp <- st_read(dsn = \"data\", layer = \"geo_export\")\n\n\nReading layer `geo_export' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/Take-home_Ex/Take-home_Ex1/data' \n  using driver `ESRI Shapefile'\nSimple feature collection with 406566 features and 72 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -92.05073 ymin: -27.31495 xmax: 92.32694 ymax: 26.65622\nGeodetic CRS:  WGS84(DD)\n\n\n\n\nImporting Nigeria ADM2 aspatial data\nThe data from Geoboundaries comes in six files in dbf, geojson, prj, shp, shx, topojson formats. The files are renamed to NGA-ADM2 for easier reference. To import these files as a simple feature data table, we also use st_read().\n\n\nShow code\nnga <- st_read(dsn = \"data\", layer = \"NGA-ADM2\")\n\n\nReading layer `NGA-ADM2' from data source \n  `/Users/sylvia/sylvie-le/ISSS624/Take-home_Ex/Take-home_Ex1/data' \n  using driver `ESRI Shapefile'\nSimple feature collection with 774 features and 5 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2.668534 ymin: 4.273007 xmax: 14.67882 ymax: 13.89442\nGeodetic CRS:  WGS 84"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#exploratory-data-analysis-and-data-wrangling",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#exploratory-data-analysis-and-data-wrangling",
    "title": "Take-home Exercise 1: How Functional are the Water Points in Nigeria?",
    "section": "Exploratory Data Analysis and Data Wrangling",
    "text": "Exploratory Data Analysis and Data Wrangling\nThe goals of this step include:\n\nExamine the data structure and format, ensure consistent format between geospatial and aspatial data.\nStudy the content of the data tables and filter out data that are not related to water points in Nigeria.\nExplore data type and data validity relating to the functionality of water points in Nigeria, transform the data where necessary.\n\n\nwp geospatial data\n\nChecking the CRS of geospatial data\nFirst, we use st_geometry() to check the geometry list column of wp. There are 406,566 observations under the WGS84 coordinate reference system (CRS). Let’s take notes that the geometry type is point 🔑\n\n\nShow code\nst_geometry(wp)\n\n\nGeometry set for 406566 features \nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -92.05073 ymin: -27.31495 xmax: 92.32694 ymax: 26.65622\nGeodetic CRS:  WGS84(DD)\nFirst 5 geometries:\n\n\nSince the shapefile is in WGS84 CRS, we will assign crs = 4326 to wp. 4326 is the code of WGS84 in EPSG code. The task is conducted using st_set_crs().\n\n\nShow code\nwp <- st_set_crs(wp, 4326)\n\n\n\n\nFiltering relevant information\nNext, we will examine the attributes in the data table using glimpse() from dplyr.\n\n\nShow code\nglimpse(wp)\n\n\nRows: 406,566\nColumns: 73\n$ row_id      <dbl> 651816, 584864, 509399, 21983, 660321, 666619, 657081, 669…\n$ source      <chr> \"Water For People\", \"Global Environment and Technology Fou…\n$ lat_deg     <dbl> -15.726464200, 6.723120000, 8.001933333, 8.084948140, 0.18…\n$ lon_deg     <dbl> 35.05067, -1.58151, -11.28760, -10.12595, 30.44659, 30.352…\n$ date_repor  <date> 2018-06-11, 2017-10-25, 2010-12-31, 2015-12-04, 2019-03-1…\n$ time_repor  <chr> \"00:00:00.000\", \"00:00:00.000\", \"00:00:00.000\", \"00:00:00.…\n$ status_id   <chr> \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Y…\n$ water_sour  <chr> NA, NA, NA, NA, \"Piped Water\", \"Piped Water\", NA, NA, NA, …\n$ water_so_2  <chr> NA, NA, NA, NA, \"Piped Water\", \"Piped Water\", NA, NA, NA, …\n$ water_te_2  <chr> \"Kiosk\", \"Tapstand\", \"Tapstand\", \"Tapstand\", NA, NA, \"Taps…\n$ X_water_tec <chr> \"Tapstand\", \"Tapstand\", \"Tapstand\", \"Tapstand\", NA, NA, \"T…\n$ facility_t  <chr> \"Improved\", \"Improved\", \"Improved\", \"Improved\", \"Improved\"…\n$ clean_coun  <chr> \"Malawi\", \"Ghana\", \"Sierra Leone\", \"Liberia\", \"Uganda\", \"U…\n$ clean_adm1  <chr> \"Blantyre\", \"Ashanti\", \"Eastern\", \"Lofa\", \"Western\", \"West…\n$ clean_adm2  <chr> \"Blantyre City\", \"Asokore Mampong Municipal\", \"Kenema\", \"K…\n$ clean_adm3  <chr> \"n.a. (2465)\", NA, \"Kando Leppeama\", \"Lucasu\", \"Kibale\", \"…\n$ clean_adm4  <chr> NA, NA, NA, NA, \"Kamwenge Town Council\", \"Buhanda\", \"Mahyo…\n$ install_ye  <dbl> NA, 2017, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ installer   <chr> NA, NA, \"Water Aid\", NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ rehab_year  <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ rehabilita  <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ manageme_2  <chr> NA, NA, NA, \"School Management\", NA, NA, NA, NA, NA, NA, N…\n$ status_cle  <chr> NA, NA, \"Functional\", NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n$ pay         <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ fecal_coli  <chr> NA, NA, NA, NA, \"Present\", \"Present\", \"Present\", NA, NA, \"…\n$ fecal_co_2  <chr> NA, \"0\", NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ subjective  <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ activity_i  <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ scheme_id   <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ wpdx_id     <chr> \"5GPQ73F2+C77\", \"6CRWPCF9+69X\", \"6CWC2P26+QXC\", \"6CWF3VMF+…\n$ notes       <chr> NA, NA, \"Poor?Jenneh?Kandu Leppiema??\", NA, NA, NA, NA, NA…\n$ orig_lnk    <chr> NA, NA, NA, \"https://wash-liberia.org/raw-water-point-data…\n$ photo_lnk   <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ country_id  <chr> \"MW\", \"GH\", \"SL\", \"LR\", \"UG\", \"UG\", \"UG\", \"UG\", \"UG\", \"UG\"…\n$ data_lnk    <chr> \"https://catalog.waterpointdata.org/datasets/wfp-2017-2020…\n$ distance_t  <dbl> 7034.8250, 3677.9101, 17540.3622, 21602.1376, 31948.1224, …\n$ distance_2  <dbl> 3431.81039, 3944.70081, 4052.93329, 37030.19501, 593.69582…\n$ distance_3  <dbl> 421.90674, 690.13048, 104.43156, 14456.72395, 149.01742, 1…\n$ distance_4  <dbl> 8321.854, 5362.011, 17003.136, 52727.389, 40206.411, 38061…\n$ distance_5  <dbl> 22044.5149, 7550.3392, 15474.4428, 31606.4649, 35770.4357,…\n$ water_poin  <chr> \"{\\\"2018-06-11\\\": {\\\"source\\\": \\\"Water For People\\\", \\\"sta…\n$ rehab_prio  <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ served_pop  <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ local_popu  <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ crucialnes  <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ pressure    <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ usage_cap   <dbl> 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250, 250…\n$ is_urban    <chr> \"True\", \"True\", \"False\", \"False\", \"False\", \"False\", \"False…\n$ days_since  <dbl> 1562, 1791, 4281, 2482, 1286, 1281, 1660, 6222, 1663, 1280…\n$ staleness_  <dbl> 61.11805, 56.86178, 25.93887, 45.73258, 66.67340, 66.77856…\n$ is_latest   <chr> \"T\", \"T\", \"T\", \"T\", \"T\", \"T\", \"T\", \"T\", \"T\", \"T\", \"T\", \"T\"…\n$ location_i  <dbl> 355848, 349148, 98255, 285679, 362508, 362657, 351144, 777…\n$ cluster_si  <dbl> 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ clean_co_2  <chr> \"MWI\", \"GHA\", \"SLE\", \"LBR\", \"UGA\", \"UGA\", \"UGA\", \"UGA\", \"U…\n$ country_na  <chr> \"Malawi\", \"Ghana\", \"Sierra Leone\", \"Liberia\", \"Uganda\", \"U…\n$ water_so_3  <chr> NA, NA, \"Gravity stand-post\", \"Public standpipe\", NA, NA, …\n$ water_tech  <chr> \"Communal water kiosk\", \"Standpost\", NA, NA, \"Pumped piped…\n$ status      <chr> \"1\", NA, \"Functional\", NA, \"1\", \"0\", \"1\", \"1\", \"1\", \"1\", N…\n$ adm2        <chr> \"Kameza\", NA, \"Kenema\", NA, \"Kibale\", \"Kitagwenda\", \"Kitag…\n$ adm3        <chr> NA, NA, NA, NA, \"Kamwenge T/Council\", \"Buhanda\", \"Mahyoro\"…\n$ management  <chr> NA, NA, NA, \"Institutional Management - School\", NA, NA, N…\n$ adm1        <chr> \"Blantyre\", NA, \"Eastern\", \"Lofa\", \"Kamwenge\", \"Kamwenge\",…\n$ lat_deg_or  <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ lat_lon_de  <chr> \"(-15.7264642?, 35.0506729?)\", \"(6.72312?, -1.58151?)\", \"(…\n$ lon_deg_or  <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ public_dat  <chr> \"https://catalog.waterpointdata.org/datafiles/wfp-2017-202…\n$ converted   <chr> NA, NA, \"#install_year, #notes\", \"#status\", NA, NA, NA, NA…\n$ count       <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ date_creat  <date> 2022-02-18, 2020-07-29, 2020-07-30, 2020-09-11, 2022-02-1…\n$ time_creat  <chr> \"05:36:33.000\", \"19:21:47.000\", \"08:35:45.000\", \"11:22:31.…\n$ date_updat  <date> 2022-02-18, 2020-07-29, 2020-07-30, 2020-09-11, 2022-02-1…\n$ time_updat  <chr> \"05:36:33.000\", \"19:21:47.000\", \"08:35:45.000\", \"11:22:31.…\n$ geometry    <POINT [°]> POINT (35.05067 -15.72646), POINT (-1.58151 6.72312)…\n\n\nWe notice that in the clean_coun column, there are many countries name such as Malawi, Ghana, Sierra Leone, etc. This means that the wp data set contains the information of other countries besides Nigeria. filter() of the package dplyr is used to get the data that only belongs to Nigeria.\n\n\nShow code\nwp <- wp %>% filter(clean_coun == \"Nigeria\")\n\n\nNow we will examine the filtered wp data set using head() of Base R. The function reveals that wp now only contains Nigeria-relevant data.\n\n\nShow code\nhead(wp, n = 5)\n\n\nSimple feature collection with 5 features and 72 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 3.597668 ymin: 6.48694 xmax: 7.92972 ymax: 7.98\nGeodetic CRS:  WGS 84\n  row_id                                       source  lat_deg  lon_deg\n1 429068                                        GRID3 7.980000 5.120000\n2 222071 Federal Ministry of Water Resources, Nigeria 6.964532 3.597668\n3 160612                                     WaterAid 6.486940 7.929720\n4 160669                                     WaterAid 6.727570 7.648670\n5 160642                                     WaterAid 6.779900 7.664850\n  date_repor   time_repor status_id water_sour water_so_2      water_te_2\n1 2018-08-29 00:00:00.000   Unknown       <NA>       <NA>        Tapstand\n2 2015-08-16 00:00:00.000       Yes   Borehole       Well Mechanized Pump\n3 2020-12-04 00:00:00.000       Yes   Borehole       Well       Hand Pump\n4 2020-12-04 00:00:00.000       Yes   Borehole       Well            <NA>\n5 2020-12-04 00:00:00.000       Yes   Borehole       Well       Hand Pump\n      X_water_tec facility_t clean_coun clean_adm1    clean_adm2 clean_adm3\n1        Tapstand   Improved    Nigeria      Ekiti          Moba       <NA>\n2 Mechanized Pump   Improved    Nigeria       Ogun Obafemi-Owode       <NA>\n3       Hand Pump   Improved    Nigeria     Ebonyi       Ohaukwu       <NA>\n4            <NA>   Improved    Nigeria      Enugu       Isi-Uzo       <NA>\n5       Hand Pump   Improved    Nigeria      Enugu       Isi-Uzo       <NA>\n  clean_adm4 install_ye installer rehab_year rehabilita manageme_2 status_cle\n1       <NA>         NA      <NA>         NA       <NA>       <NA>       <NA>\n2       <NA>         NA      <NA>         NA       <NA>      Other Functional\n3       <NA>         NA      <NA>         NA       <NA>       <NA>       <NA>\n4       <NA>         NA      <NA>         NA       <NA>       <NA>       <NA>\n5       <NA>         NA      <NA>         NA       <NA>       <NA>       <NA>\n   pay fecal_coli fecal_co_2         subjective\n1 <NA>       <NA>       <NA>               <NA>\n2   No       <NA>       <NA> Acceptable quality\n3 <NA>       <NA>       <NA>               <NA>\n4 <NA>       <NA>       <NA>               <NA>\n5 <NA>       <NA>       <NA>               <NA>\n                            activity_i scheme_id      wpdx_id     notes\n1 1a117ba2-5256-4801-874c-f7611a4499dd      <NA> 6FV7X4JC+222 Tap Water\n2                                 <NA>      <NA> 6FR5XH7X+R37     Ajura\n3                                 <NA>      <NA> 6FR9FWPH+QVH      <NA>\n4                                 <NA>      <NA> 6FR9PJHX+2FF      <NA>\n5                                 <NA>      <NA> 6FR9QMH7+XW9      <NA>\n                                                                              orig_lnk\n1 https://nigeria.africageoportal.com/datasets/GRID3::grid3-nigeria-water-points/about\n2                                                                                 <NA>\n3                                                                                 <NA>\n4                                                                                 <NA>\n5                                                                                 <NA>\n  photo_lnk country_id\n1      <NA>         NG\n2      <NA>         NG\n3      <NA>         NG\n4      <NA>         NG\n5      <NA>         NG\n                                                                                          data_lnk\n1                  https://catalog.waterpointdata.org/datasets/grid3-nigeria-water-points-61ae7cd9\n2 https://catalog.waterpointdata.org/datasets/federal-ministry-of-water-resources-nigeria-5efb3667\n3                                https://catalog.waterpointdata.org/datasets/rain-nigeria-5fe0f6d7\n4                                https://catalog.waterpointdata.org/datasets/rain-nigeria-5fe0f6d7\n5                                https://catalog.waterpointdata.org/datasets/rain-nigeria-5fe0f6d7\n  distance_t  distance_2 distance_3 distance_4 distance_5\n1   767.3742   921.79187  3146.7332   41049.94    959.365\n2 13364.9005    48.87743  4167.5191   13898.65   9405.783\n3  9492.7619  4333.34280   693.2112   27381.92  72060.118\n4  9319.0815 23276.33227   307.7162   34823.61  31665.447\n5  5437.7141 18783.56566   134.6121   40785.89  31240.904\n                                                                                                                                                               water_poin\n1                                                                             {\"2018-08-29\": {\"source\": \"GRID3\", \"status_id\": \"Unknown\", \"water_tech_clean\": \"Tapstand\"}}\n2 {\"2015-08-16\": {\"source\": \"Federal Ministry of Water Resources, Nigeria\", \"status_id\": \"Yes\", \"water_source_clean\": \"Borehole\", \"water_tech_clean\": \"Mechanized Pump\"}}\n3                                           {\"2020-12-04\": {\"source\": \"WaterAid\", \"status_id\": \"Yes\", \"water_source_clean\": \"Borehole\", \"water_tech_clean\": \"Hand Pump\"}}\n4                                                                            {\"2020-12-04\": {\"source\": \"WaterAid\", \"status_id\": \"Yes\", \"water_source_clean\": \"Borehole\"}}\n5                                           {\"2020-12-04\": {\"source\": \"WaterAid\", \"status_id\": \"Yes\", \"water_source_clean\": \"Borehole\", \"water_tech_clean\": \"Hand Pump\"}}\n  rehab_prio served_pop local_popu crucialnes pressure usage_cap is_urban\n1         NA         NA         NA         NA       NA       250     True\n2         NA        140        887  0.1578354 0.140000      1000    False\n3         NA          0          0         NA       NA       300    False\n4         NA        492        492  1.0000000 1.640000       300    False\n5         NA        868       1919  0.4523189 2.893333       300    False\n  days_since staleness_ is_latest location_i cluster_si clean_co_2 country_na\n1       1483   62.65911         T     358773          1        NGA    Nigeria\n2       2592   44.17405         T     264633          1        NGA    Nigeria\n3        655   81.34550         T     397972          1        NGA    Nigeria\n4        655   81.34550         T     397984          1        NGA    Nigeria\n5        655   81.34550         T     397982          1        NGA    Nigeria\n                      water_so_3 water_tech                  status\n1                            Tap       <NA>                    <NA>\n2 Improved Tube well or borehole  Motorised Functional (and in use)\n3  Borehole fitted with Handpump       <NA>                    <NA>\n4      Gen. set powered borehole       <NA>                    <NA>\n5  Borehole fitted with Handpump       <NA>                    <NA>\n           adm2 adm3 management  adm1 lat_deg_or               lat_lon_de\n1          <NA> <NA>       <NA>  <NA>         NA           (7.98?, 5.12?)\n2 Obafemi-Owode <NA>      Other  Ogun         NA (6.9645317?, 3.5976683?)\n3          <NA> <NA>       <NA> Enugu         NA     (6.48694?, 7.92972?)\n4          <NA> <NA>       <NA> Enugu         NA     (6.72757?, 7.64867?)\n5          <NA> <NA>       <NA> Enugu         NA      (6.7799?, 7.66485?)\n  lon_deg_or\n1         NA\n2         NA\n3         NA\n4         NA\n5         NA\n                                                                                              public_dat\n1                   https://catalog.waterpointdata.org/datafiles/grid3-nigeria-water-points-61ae7cd9.csv\n2 https://catalog.waterpointdata.org/datafiles/federal-ministry-of-water-resources-nigeria-5efb3667.xlsx\n3                                https://catalog.waterpointdata.org/datafiles/rain-nigeria-5fe0f6d7.xlsx\n4                                https://catalog.waterpointdata.org/datafiles/rain-nigeria-5fe0f6d7.xlsx\n5                                https://catalog.waterpointdata.org/datafiles/rain-nigeria-5fe0f6d7.xlsx\n                                              converted count date_creat\n1                                                  <NA>     1 2021-12-06\n2 #status_id, #water_source, #pay, #status, #management     1 2020-06-30\n3                                                  <NA>     1 2020-12-21\n4                                                  <NA>     1 2020-12-21\n5                                                  <NA>     1 2020-12-21\n    time_creat date_updat   time_updat                  geometry\n1 21:12:57.000 2021-12-06 21:12:57.000         POINT (5.12 7.98)\n2 12:56:07.000 2020-06-30 12:56:07.000 POINT (3.597668 6.964532)\n3 19:26:15.000 2020-12-21 19:26:15.000   POINT (7.92972 6.48694)\n4 19:26:15.000 2020-12-21 19:26:15.000   POINT (7.64867 6.72757)\n5 19:26:15.000 2020-12-21 19:26:15.000    POINT (7.66485 6.7799)\n\n\nNow we will write the filtered data table into a new rds file named wp_nga using the write_rds() function from the sf package.\n\n\nShow code\nwrite_rds(wp, \"data/wp_nga.rds\")\n\n\nFrom this point on, we will work on the wp_nga file.\n\n\nExploring the water point status data\nFrom the result of the code above, we notice that column status_cle has NA values. Since our goal is to examine the functionality of the water points, the data in status_cle should be transformed to remove the NA values. One way to do it is to recode the NA values to “Unknown”. replace_na() from the tidyr package is used to do the mentioned task.\nTo preserve the existing variables while adding new ones, mutate() from the dplyr package is used.\nAll changes are written into the wp_nga file using read_rds().\n\n\nShow code\nwp_nga <- read_rds(\"data/wp_nga.rds\") %>%\n  mutate(status_cle = replace_na(status_cle, \"Unknown\"))\n\n\nLet’s look at the distribution of status_cle. We will use freq() from the funModeling package for this task.\n\n\nShow code\nfreq(data=wp_nga, \n     input = 'status_cle')\n\n\n\n\n\n                        status_cle frequency percentage cumulative_perc\n1                       Functional     45883      48.29           48.29\n2                   Non-Functional     29385      30.93           79.22\n3                          Unknown     10656      11.22           90.44\n4      Functional but needs repair      4579       4.82           95.26\n5 Non-Functional due to dry season      2403       2.53           97.79\n6        Functional but not in use      1686       1.77           99.56\n7         Abandoned/Decommissioned       234       0.25           99.81\n8                        Abandoned       175       0.18           99.99\n9 Non functional due to dry season         7       0.01          100.00\n\n\nWe can see that there are two variables that carry the same meaning: Non-Functional due to dry season and Non functional due to dry season. We will use replace() from dplyr to do this task.\n\n\nShow code\nwp_nga <- read_rds(\"data/wp_nga.rds\") %>%\n  mutate(status_cle = replace(status_cle, status_cle == \"Non functional due to dry season\", \"Non-Functional due to dry season\")) %>%\n  mutate(status_cle = replace_na(status_cle, \"Unknown\"))\n\n\nLet’s re-examine the distribution of status_cle.\n\n\nShow code\nfreq(data=wp_nga, \n     input = 'status_cle')\n\n\n\n\n\n                        status_cle frequency percentage cumulative_perc\n1                       Functional     45883      48.29           48.29\n2                   Non-Functional     29385      30.93           79.22\n3                          Unknown     10656      11.22           90.44\n4      Functional but needs repair      4579       4.82           95.26\n5 Non-Functional due to dry season      2410       2.54           97.80\n6        Functional but not in use      1686       1.77           99.57\n7         Abandoned/Decommissioned       234       0.25           99.82\n8                        Abandoned       175       0.18          100.00\n\n\n\n\nExtracting non-functional water point data\nNon-functional water points are defined as those which are not functional or abandoned. Using filter() from the dplyr package, we will save the non-functional water point data into a simple feature data table named wpt_nonfunctional.\n\n\nShow code\nwpt_nonfunctional <- wp_nga %>%\n  filter(status_cle %in%\n           c(\"Abandoned/Decommissioned\", \n             \"Abandoned\",\n             \"Non-Functional\",\n             \"Non-Functional due to dry season\"))\n\n\nNow we can inspect the distribution of non-functional water points by type using freq().\n\n\nShow code\nfreq(data = wpt_nonfunctional, input = \"status_cle\")\n\n\n\n\n\n                        status_cle frequency percentage cumulative_perc\n1                   Non-Functional     29385      91.25           91.25\n2 Non-Functional due to dry season      2410       7.48           98.73\n3         Abandoned/Decommissioned       234       0.73           99.46\n4                        Abandoned       175       0.54          100.00\n\n\n\n\n\nnga aspatial data\n\nChecking the CRS of aspatial data\nWe will check the CRS of nga using st_geometry().\n\n\nShow code\nst_geometry(nga)\n\n\nGeometry set for 774 features \nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2.668534 ymin: 4.273007 xmax: 14.67882 ymax: 13.89442\nGeodetic CRS:  WGS 84\nFirst 5 geometries:\n\n\nAs the CRS of nga is WGS84, we will assign crs = 4326 using st_set_crs().\n\n\nShow code\nnga <- st_set_crs(nga, 4326)\n\n\nNext, we plot the geometry using plot() of Base R. As our data is the regions of Nigeria by administrative division management level 2, the map below depicts the 774 Local Government Areas of Nigeria.\nFrom the map, it is noticeable that the size of government areas varies significantly. Let’s keep this in mind for further analysis 💪\n\n\nShow code\nplot(st_geometry(nga))\n\n\n\n\n\n\n\n\nPerforming Point-in-Polygon Count\nBecause the geometry type of our geospatial data is point, we need to compute the number of points inside each polygon. The functions below will be used for that task.\n\nmutate(): preserves the existing variables while adding new variables, from dplyr package\nst_intersects(): spatial intersect predicate for stars and sfc object, from stars package, a sub-package of tmap.\nlengths(): get the length of each element of a list or atomic vector as an integer or numeric vector, from Base R.\n\nAfter the aggregation, the output will in in polygon geometry shape.\n\n\nShow code\nnga_wp <- nga %>%\n  mutate(`total wpt` = lengths(\n    st_intersects(nga, wp_nga))) %>% \n  mutate(`wpt non-functional` = lengths(\n    st_intersects(nga, wpt_nonfunctional)))\n\n\n\n\nSaving the analytical data table\nBefore saving the data table, we will compute the percentage of non-functional water points over the total number of water points in Nigeria.\n\n\nShow code\nnga_wp <- nga_wp %>% \n  mutate(`pct_non-functional` = `wpt non-functional`/`total wpt`)\n\n\nNow, we will save the sf data table nga_wp into a new rds file.\n\n\nShow code\nwrite_rds(nga_wp, \"data/nga_wp.rds\")"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#visualizing-the-data",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#visualizing-the-data",
    "title": "Take-home Exercise 1: How Functional are the Water Points in Nigeria?",
    "section": "Visualizing the Data",
    "text": "Visualizing the Data\nFirst, let’s reload the nga_wp.rds file into our working environment.\n\n\nShow code\nnga_wp <- read_rds(\"data/nga_wp.rds\")\n\n\n\nDisplaying non-functional water points with choropleth map\nTo create the plots, we will use the tm_shape() and tm_fill() functions from tmap package. In addition, tm_borders() and tm_layout() will be used to customize the style of the map. Below are the functionality of the functions.\n\ntm_shape: creates a tmap element that specifies the spatial data object.\ntm_fill: creates a tmap element that draws the polygons.\ntm_borders: creates a tmap element that defines the border of the polygons.\ntm_layout: specifies the map layout\n\n\n\nShow code\nwp_pretty <- tm_shape(nga_wp) + \n  tm_fill(\"wpt non-functional\",\n          title = \"Water Point Count\") +\n  tm_layout(main.title = \"Pretty Classification\",\n            main.title.position = \"center\",\n            main.title.size = 2,\n            legend.height = 0.25,\n            legend.width = 0.3,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n\nwp_quantile <- tm_shape(nga_wp) + \n  tm_fill(\"wpt non-functional\",\n          title = \"Water Point Count\",\n          style = \"quantile\") +\n  tm_layout(main.title = \"Quantile Classification\",\n            main.title.position = \"center\",\n            main.title.size = 2,\n            legend.height = 0.25,\n            legend.width = 0.3,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n\nwp_equal <- tm_shape(nga_wp) + \n  tm_fill(\"wpt non-functional\",\n          title = \"Water Point Count\",\n          style = \"equal\") +\n  tm_layout(main.title = \"Equal Classification\",\n            main.title.position = \"center\",\n            main.title.size = 2,\n            legend.height = 0.25,\n            legend.width = 0.3,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n\nwp_jenks <- tm_shape(nga_wp) + \n  tm_fill(\"wpt non-functional\",\n          title = \"Water Point Count\",\n          style = \"jenks\") +\n  tm_layout(main.title = \"Jenks Classification\",\n            main.title.position = \"center\",\n            main.title.size = 2,\n            legend.height = 0.25,\n            legend.width = 0.3,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n\n\n\n\nShow code\nwp_equal\n\n\n\n\n\nShow code\nwp_pretty\n\n\n\n\n\nShow code\nwp_jenks\n\n\n\n\n\nShow code\nwp_quantile\n\n\n\n\n\nFrom the maps above, we can see that different interval classification produces different map views.\npretty and equal methods divide the values into groups of equally-spaced values, so they can smooth out the distribution of non-functional water points.\nThe Jenks method produces well-balanced intervals. By definition, the Jenks method defines intervals so that they have the smallest in-class variance. This makes the Jenks method more suitable for high-variance data sets like nga_wp.\nThe quantile method produces a rather dire situation with a large area of land having the highest numbers of non-functional water points. However, the range of the highest quantile is relatively huge comparing to other quantiles, suggesting high variance data. We can say that the quantile method exaggerates the disfunctionality of water points in Nigeria due to outliers.\n\nDisplaying data distribution with histogram\nTo confirm the distribution of the data, we will use a histogram. From the histogram, it is clear that the data is highly skewed toward the right.\n\n\nShow code\nhist(nga_wp$`wpt non-functional`, xlab = \"Non-functional Water Point Count\",\n     main = \"Histogram of non-functional water points\")"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#global-spatial-autocorrelation",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#global-spatial-autocorrelation",
    "title": "Take-home Exercise 1: How Functional are the Water Points in Nigeria?",
    "section": "Global Spatial Autocorrelation",
    "text": "Global Spatial Autocorrelation\nBased on the maps above, we see that there are some areas with a higher number of non-functional water points than others. Is there a pattern for the distribution of the non-functional water points or do they just occur randomly? To answer that question, we will explore the global spatial autocorrelation of non-functional water points in Nigeria.\n\nComputing Spatial Weights\nLet’s consider four spatial weight methods.\n\nPolygon Contiguity: this method defines the neighbor based on contiguity and is effective when the polygons are similar in size and distribution, and when spatial relationships are a function of polygon proximity. In this case, the size of the government areas of Nigeria have significantly varying sizes. Therefore, polygon contiguity is not a good fit.\nFixed Distance: this method is effective for polygon data with large variation in polygon size (very large polygons at the edge of the study area, and very small polygons at the center of the study areas). On the map, we can see that Nigeria has very small government areas in the south, while bigger areas are scattered in the rest of the country, together with smaller areas in between. Therefore, the Fixed Distance method is not a good fit.\nInverse Distance: this method is appropriate for with continuous data or to model the process where the closer the features are, the more likely they are going to interact/affect the other. The downside of this approach is that it considers every feature is potentially a neighbor of every other feature. Therefore, the method is computationally costly. Since our data set has up to 774 observations, this method is not appropriate considering the capability of our personal computer.\nAdaptive Distance (K Nearest Neighbor): this method is effective when the values associate with the features are skewed. Because our data is skewed to the right, this method is a good fit.\n\n\nConverting data into projected coordinate system\nBecause Adaptive Distance spatial weight method is distance-based spatial weight method, the data needs to be converted into projected coordinate system. The EPSG code we will convert the data into is EPSG:26391, used for Nigeria West Belt. We will use st_transform() from the sf package for the task.\n\n\nShow code\nnga_wp <- st_transform(nga_wp, crs = 26391)\n\n\n\n\nComputing Adaptive Weight Matrix\nAs a rule of thumb, when computing adaptive weight matrix, we should ensure that each feature has at least 8 neighbors. To do the task, the functions below are called:\n\nknn2nb(): converts a knn object returned by knearneigh into a neighbors list of class nb with a list of integer vectors containing neighbor region number ids.\nknearneigh(): returns a matrix with the indices of points belonging to the set of the k nearest neighbours of each other.\nmap_dbl(): returns an atomic vector of the indicative type.\nst_centroid(): calculates and retrieve the centroid of the feature.\ncbind(): merges two data frames/vectors/matrices together\n\n\n\nShow code\n#Calculate the longitude and latitude\nlongitude <- map_dbl(nga_wp$geometry, ~st_centroid(.x)[[1]])\nlatitude <- map_dbl(nga_wp$geometry, ~st_centroid(.x)[[2]])\ncoords <- cbind(longitude, latitude)\nwp_k8 <- knn2nb(knearneigh(coords, k = 8))\n\n\nDisplaying the content of wp_k8 matrix using str(). Each feature has 8 neighbors.\n\n\nShow code\nstr(wp_k8)\n\n\nList of 774\n $ : int [1:8] 2 321 364 548 597 624 721 725\n $ : int [1:8] 1 321 548 597 624 721 725 726\n $ : int [1:8] 241 250 261 447 492 507 509 526\n $ : int [1:8] 12 20 257 263 446 454 466 690\n $ : int [1:8] 203 208 286 288 331 334 539 738\n $ : int [1:8] 170 217 218 337 379 553 577 601\n $ : int [1:8] 8 176 214 281 283 306 544 555\n $ : int [1:8] 7 214 281 306 327 544 555 651\n $ : int [1:8] 18 19 218 337 574 576 601 757\n $ : int [1:8] 25 216 325 364 365 528 552 632\n $ : int [1:8] 26 27 43 68 191 524 565 762\n $ : int [1:8] 135 263 417 429 446 454 690 695\n $ : int [1:8] 31 37 211 320 393 570 583 584\n $ : int [1:8] 170 363 379 546 563 577 581 589\n $ : int [1:8] 22 49 82 177 297 306 580 623\n $ : int [1:8] 30 187 188 296 328 357 360 635\n $ : int [1:8] 35 275 295 378 460 591 638 639\n $ : int [1:8] 9 19 218 376 574 576 601 757\n $ : int [1:8] 9 18 56 103 376 574 576 601\n $ : int [1:8] 4 106 125 239 263 419 454 466\n $ : int [1:8] 60 61 162 269 520 578 596 626\n $ : int [1:8] 49 297 326 443 515 623 682 693\n $ : int [1:8] 54 291 292 536 537 614 618 619\n $ : int [1:8] 84 123 437 476 527 652 673 761\n $ : int [1:8] 10 181 216 314 325 366 552 730\n $ : int [1:8] 11 27 68 191 336 439 562 762\n $ : int [1:8] 11 26 191 439 562 565 663 762\n $ : int [1:8] 29 178 299 300 301 358 369 598\n $ : int [1:8] 172 173 178 182 358 378 460 591\n $ : int [1:8] 16 39 41 186 192 329 357 360\n $ : int [1:8] 13 37 211 289 561 570 583 584\n $ : int [1:8] 51 62 461 462 515 623 682 693\n $ : int [1:8] 47 166 227 238 242 655 743 750\n $ : int [1:8] 42 104 136 137 213 553 559 757\n $ : int [1:8] 17 275 276 277 278 279 295 460\n $ : int [1:8] 50 107 247 408 432 455 681 759\n $ : int [1:8] 38 40 211 212 570 583 584 629\n $ : int [1:8] 30 39 40 41 186 192 320 570\n $ : int [1:8] 30 38 40 41 186 192 320 329\n $ : int [1:8] 37 38 39 41 186 192 320 570\n $ : int [1:8] 30 38 39 40 186 192 360 634\n $ : int [1:8] 86 136 137 499 587 613 718 734\n $ : int [1:8] 11 68 157 524 549 565 590 645\n $ : int [1:8] 16 45 192 290 303 328 360 634\n $ : int [1:8] 44 187 290 303 328 341 360 599\n $ : int [1:8] 387 417 429 438 459 521 668 742\n $ : int [1:8] 33 111 166 234 238 691 698 750\n $ : int [1:8] 65 113 265 386 407 428 482 701\n $ : int [1:8] 22 32 297 326 515 623 682 693\n $ : int [1:8] 36 98 107 247 409 416 432 681\n $ : int [1:8] 32 62 461 462 515 580 623 693\n $ : int [1:8] 53 78 165 293 532 602 603 636\n $ : int [1:8] 52 78 80 165 280 602 621 636\n $ : int [1:8] 23 79 293 294 532 536 537 618\n $ : int [1:8] 122 169 246 333 430 571 605 697\n $ : int [1:8] 77 368 376 533 534 576 601 728\n $ : int [1:8] 53 58 199 312 322 323 621 622\n $ : int [1:8] 57 322 323 564 602 603 621 622\n $ : int [1:8] 88 128 129 259 493 700 714 748\n $ : int [1:8] 61 158 563 578 589 592 596 626\n $ : int [1:8] 21 60 269 578 589 592 596 626\n $ : int [1:8] 32 51 461 462 515 623 682 693\n $ : int [1:8] 90 237 384 416 467 497 765 772\n $ : int [1:8] 48 65 74 113 131 265 386 407\n $ : int [1:8] 48 64 74 113 265 407 683 701\n $ : int [1:8] 19 103 104 288 331 338 351 574\n $ : int [1:8] 347 348 560 566 567 609 640 694\n $ : int [1:8] 11 43 157 190 191 549 590 645\n $ : int [1:8] 140 146 248 274 473 500 512 513\n $ : int [1:8] 71 298 299 301 341 343 344 610\n $ : int [1:8] 70 172 173 298 299 343 344 625\n $ : int [1:8] 17 361 566 567 568 609 638 639\n $ : int [1:8] 72 361 374 377 404 607 665 666\n $ : int [1:8] 65 109 113 251 265 683 741 754\n $ : int [1:8] 110 272 398 422 433 485 501 768\n $ : int [1:8] 254 287 427 459 470 547 647 677\n $ : int [1:8] 56 195 533 534 579 618 619 728\n $ : int [1:8] 52 54 79 80 165 215 532 636\n $ : int [1:8] 54 78 165 293 532 579 618 636\n $ : int [1:8] 52 53 78 165 215 280 636 739\n $ : int [1:8] 99 145 227 233 426 483 689 760\n $ : int [1:8] 15 32 49 51 177 352 580 623\n $ : int [1:8] 132 258 383 414 433 529 767 768\n $ : int [1:8] 24 131 148 386 437 482 673 692\n $ : int [1:8] 105 156 267 394 654 675 707 712\n $ : int [1:8] 42 136 137 499 587 613 718 734\n $ : int [1:8] 149 151 221 226 399 410 486 657\n $ : int [1:8] 59 116 128 150 489 648 700 714\n $ : int [1:8] 260 408 463 542 674 676 681 759\n $ : int [1:8] 63 163 236 237 384 452 710 765\n $ : int [1:8] 160 271 388 406 473 475 492 525\n $ : int [1:8] 95 119 390 391 392 423 487 656\n $ : int [1:8] 73 354 374 402 594 607 665 666\n $ : int [1:8] 13 31 60 158 436 561 596 709\n $ : int [1:8] 92 390 391 392 405 423 469 656\n $ : int [1:8] 97 139 389 403 420 451 488 653\n $ : int [1:8] 96 168 389 420 451 653 662 773\n $ : int [1:8] 50 117 153 231 409 432 696 708\n $ : int [1:8] 81 145 426 483 667 689 760 769\n  [list output truncated]\n - attr(*, \"region.id\")= chr [1:774] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language knearneigh(x = coords, k = 8)\n - attr(*, \"sym\")= logi FALSE\n - attr(*, \"type\")= chr \"knn\"\n - attr(*, \"knn-k\")= num 8\n - attr(*, \"class\")= chr \"nb\"\n\n\nNow we can plot the adaptive spatial weight matrix.\n\n\nShow code\nplot(nga_wp$geometry, border = \"lightgrey\", main = \"K Nearest Neighbor Matrix\")\nplot(wp_k8, coords, pch = 19, cex = 0.2, add = TRUE, col = \"red\")\n\n\n\n\n\n\n\nRow standardized weight matrix\nWe will compute a row standardized weight matrix based on wp_k8 by using nb2listw() from spdep package. Since the data has 774 observations, which is a high number, style = \"B\" is used for a more robust analysis.\n\n\nShow code\nwp_rsw <- nb2listw(wp_k8, style = \"B\", zero.policy = TRUE)\nwp_rsw\n\n\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 774 \nNumber of nonzero links: 6192 \nPercentage nonzero weights: 1.033592 \nAverage number of links: 8 \nNon-symmetric neighbours list\n\nWeights style: B \nWeights constants summary:\n    n     nn   S0    S1     S2\nB 774 599076 6192 11154 201940\n\n\n\n\n\nGlobal Spatial Autocorrelation: Moran’s I\n\nMoran’s I test\nTo perform the Moran’s I test, we will use moran.test() from spdep package.\n\n\nShow code\nmoran.test(nga_wp$`wpt non-functional`, listw = wp_rsw, zero.policy = TRUE, na.action = na.omit)\n\n\n\n    Moran I test under randomisation\n\ndata:  nga_wp$`wpt non-functional`  \nweights: wp_rsw    \n\nMoran I statistic standard deviate = 22.72, p-value < 2.2e-16\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n     0.3830962455     -0.0012936611      0.0002862476 \n\n\nBecause the p-value of the test is less than 0.05, we reject the null hypothesis that the non-functional water points are spatially random at 95% confident interval. As the Moran statistic is 0.383, greater than 0, we can say that the non-functional water point observations are clustered.\n\n\nMonte Carlo Moran’s I\nTo compute 1,000 simulations of Monte Carlo Moran’s I, we will use moran.mc() from spdep package.\n\n\nShow code\nset.seed(1234)\nmc_moran = moran.mc(nga_wp$`wpt non-functional`,\n                    listw = wp_rsw,\n                    nsim = 999,\n                    zero.policy = TRUE,\n                    na.action = na.omit)\nmc_moran\n\n\n\n    Monte-Carlo simulation of Moran I\n\ndata:  nga_wp$`wpt non-functional` \nweights: wp_rsw  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.3831, observed rank = 1000, p-value = 0.001\nalternative hypothesis: greater\n\n\nAs p-value is 0.001 and less than 0.05, we reject the null hypothesis of spatial randomness among the non-functional water point observations. The statistic of the Moran’s I simulations is 0.3831, greater than 0, corroborating the test result that similar non-functional water point observations are clustered.\n\n\nVisualzing Monte Carlo Moran’s I\n\n\nShow code\nsummary(mc_moran$res)\n\n\n      Min.    1st Qu.     Median       Mean    3rd Qu.       Max. \n-0.0577464 -0.0127344 -0.0011002 -0.0002353  0.0109820  0.3830962 \n\n\n\n\nShow code\nhist(mc_moran$res,\n     freq = TRUE,\n     breaks = 20,\n     xlab = \"Simulated Moran's I\",\n     main = \"Histogram of Moran's I Simulation\")\nabline(v = 0, col = \"red\")\n\n\n\n\n\nWe can see that the min of the Moran’s I value is less than 0, while the max value is 0.38. The Moran’s I data is approaching 1, inferring similar values are clustered. In layman terms, government areas with similar number of non-functional water points tend to be closer together and form some clusters.\n\n\n\nGlobal Spatial Autocorrelation: Geary’s C\nThe following section will focus on Geary’s C test and Geary’s C Monte Carlo simulation using the functions from spdep package.\n\nGeary’s C Test\n\n\nShow code\ngeary.test(nga_wp$`wpt non-functional`, listw = wp_rsw)\n\n\n\n    Geary C test under randomisation\n\ndata:  nga_wp$`wpt non-functional` \nweights: wp_rsw \n\nGeary C statistic standard deviate = 19.419, p-value < 2.2e-16\nalternative hypothesis: Expectation greater than statistic\nsample estimates:\nGeary C statistic       Expectation          Variance \n     0.6045301723      1.0000000000      0.0004147472 \n\n\nBecause p-value is 0.001 and less than 0.05, we reject the null hypothesis of spatial randomness among the non-functional water point observations with 95% confident interval. The statistic of the Geary’s C simulations is 0.605, less than 1, we can say that the data tend to cluster among similar observations.\n\n\nMonte Carlo Geary’s C\nWe will compute 1000 simulations of Geary’s C using geary.mc().\n\n\nShow code\nset.seed(1234)\nmc_geary = geary.mc(nga_wp$`wpt non-functional`, listw = wp_rsw, nsim = 999)\nmc_geary\n\n\n\n    Monte-Carlo simulation of Geary C\n\ndata:  nga_wp$`wpt non-functional` \nweights: wp_rsw \nnumber of simulations + 1: 1000 \n\nstatistic = 0.60453, observed rank = 1, p-value = 0.001\nalternative hypothesis: greater\n\n\nThe result of the simulation corroborates the previous Geary’s C test with p-value less than 0.05 and Geary’s C statistic less than 1.\n\n\nVisualizing Monte Carlo Geary’s C\n\n\nShow code\nsummary(mc_geary$res)\n\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.6045  0.9857  0.9995  0.9987  1.0128  1.0690 \n\n\n\n\nShow code\nhist(mc_geary$res,\n     freq = TRUE,\n     breaks = 20,\n     main = \"Histogram of Geary's C Simulation\",\n     xlab = \"Simulated Geary's C\")\nabline(v = 1, col = \"red\")\n\n\n\n\n\nWe can see that the min Geary’s C is less than 1, while the max is greater than 1. The Geary’s C data is approaching 0, meaning similar values are clustered. This result again is similar to Moran’s I. We have areas with similar number of non-functional water points clustering together."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#spatial-correlogram-with-morans-i",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#spatial-correlogram-with-morans-i",
    "title": "Take-home Exercise 1: How Functional are the Water Points in Nigeria?",
    "section": "Spatial Correlogram with Moran’s I",
    "text": "Spatial Correlogram with Moran’s I\nWe will use sp.correlogram() from spdep package to compute a 6-lag spatial correlogram of non-functional water points.\n\n\nShow code\nMI_corr <- sp.correlogram(wp_k8, \n                          nga_wp$`wpt non-functional`, \n                          order=10, \n                          method=\"I\", \n                          style=\"W\")\nplot(MI_corr, main = \"Moran's I Correlogram of Non-functional Water Points\")\n\n\n\n\n\n\n\nShow code\nprint(MI_corr)\n\n\nSpatial correlogram for nga_wp$`wpt non-functional` \nmethod: Moran's I\n            estimate expectation    variance standard deviate Pr(I) two sided\n1 (774)   3.8310e-01 -1.2937e-03  2.8625e-04          22.7196       < 2.2e-16\n2 (774)   2.4978e-01 -1.2937e-03  1.4428e-04          20.9027       < 2.2e-16\n3 (774)   1.7519e-01 -1.2937e-03  9.8557e-05          17.7769       < 2.2e-16\n4 (774)   1.1512e-01 -1.2937e-03  7.3007e-05          13.6241       < 2.2e-16\n5 (774)   7.3384e-02 -1.2937e-03  5.7171e-05           9.8765       < 2.2e-16\n6 (774)   3.3259e-02 -1.2937e-03  4.7493e-05           5.0137       5.338e-07\n7 (774)   2.3599e-03 -1.2937e-03  4.1538e-05           0.5669       0.5708000\n8 (774)  -2.3438e-02 -1.2937e-03  3.7172e-05          -3.6322       0.0002811\n9 (774)  -5.8066e-02 -1.2937e-03  3.4217e-05          -9.7054       < 2.2e-16\n10 (774) -9.0732e-02 -1.2937e-03  3.2640e-05         -15.6549       < 2.2e-16\n            \n1 (774)  ***\n2 (774)  ***\n3 (774)  ***\n4 (774)  ***\n5 (774)  ***\n6 (774)  ***\n7 (774)     \n8 (774)  ***\n9 (774)  ***\n10 (774) ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nThe higher the lag value, the lower the estimation of Moran’s I value. From lag 8, the values start to be dispersed with Moran’s I estimation less than 0. Except for lag 7, we can reject the null hypothesis of spatial randomness for other lag values."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#cluster-and-outlier-analysis",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#cluster-and-outlier-analysis",
    "title": "Take-home Exercise 1: How Functional are the Water Points in Nigeria?",
    "section": "Cluster and Outlier Analysis",
    "text": "Cluster and Outlier Analysis\nIn this segment, we will examine the existence of clusters in the spatial arrangement of non-functional water points. The statistical method we will use is Local Indicators of Spatial Association, or LISA for short.\n\nComputing local Moran’s I\nTo compute local Moran's I, the localmoran() function of spdep will be used. We will display the local Moran matrix using printCoefmat().\n\n\nShow code\nfips <- order(nga_wp$shapeName)\nlocalMI <- localmoran(nga_wp$`wpt non-functional`, wp_rsw)\nhead(localMI)\n\n\n           Ii          E.Ii       Var.Ii       Z.Ii Pr(z != E(Ii))\n1 -0.64557011 -7.996194e-03 6.1268059630 -0.2575808    0.796730455\n2 -0.18338854 -3.273970e-04 0.2510973197 -0.3653214    0.714871500\n3 10.06559878 -1.302147e-02 9.9709777352  3.1917746    0.001414017\n4 -0.25538147 -4.342004e-04 0.3330057298 -0.4417988    0.658634818\n5  0.73333147 -2.072772e-03 1.5893664318  0.5833297    0.559671349\n6  0.06300119 -1.230756e-06 0.0009439673  2.0505897    0.040306916\n\n\n\n\nMapping the local Moran’s I\nBefore mapping the local Moran’s I, we will append the local Moran’s dataframe localMI into nga_wp using cbind().\n\n\nShow code\nnga_wp.LMI <- cbind(nga_wp, localMI) %>% \n  rename(Pr.Ii = Pr.z....E.Ii..)\n\n\nNow we can map the local Moran’s I statistics and their p-values.\n\n\nShow code\nlocalMI.map <- tm_shape(nga_wp.LMI) +\n  tm_fill(col = \"Ii\",\n          style = \"pretty\",\n          title = \"Local Moran Stats\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.height = 0.25,\n            legend.width = 0.3)\n\npvalueMI <- tm_shape(nga_wp.LMI) +\n  tm_fill(col = \"Pr.Ii\",\n          breaks = c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),\n          palette = \"-Blues\",\n          title = \"Local Moran p-value\") +\n  tm_borders(alpha = 0.5) +\n  tm_layout(legend.height = 0.25,\n            legend.width = 0.3)\n\ntmap_arrange(localMI.map, pvalueMI, asp = 1, ncol = 2)\n\n\n\n\n\nWhere p-values are less than 0.05, we can reject the null hypothesis of local spatial randomness. The areas with darker color on the p-value map is where the observations of non-functional water points are not distributed randomly."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#lisa-cluster-map",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#lisa-cluster-map",
    "title": "Take-home Exercise 1: How Functional are the Water Points in Nigeria?",
    "section": "LISA Cluster Map",
    "text": "LISA Cluster Map\n\nPlotting Moran scatterplots\nWith Moran scatterplot, we can see the relationship between the value of the chosen attribute at each location and the average value of the same attribute at neighboring locations. The Moran scatterplot is drawn using moran.plot() from spdep package.\nTwo scatterplots will be drawn. One with non-standardized variable and the other one with standardized variable.\nFirst, we will use scale to standardize the variables.\n\n\nShow code\nnga_wp$Z.wptnon <- scale(nga_wp$`wpt non-functional`) %>% \n  as.vector\n\n\nThe two scatterplots are drafted as below.\n\n\nShow code\nnci <- moran.plot(nga_wp$`wpt non-functional`, wp_rsw,\n                  labels = FALSE, \n                  xlab = \"Non-functional Water Points\", \n                  ylab = \"Spatially Lag Non-functional Water Points\")\n\n\n\n\n\nShow code\nnci2 <- moran.plot(nga_wp$Z.wptnon, wp_rsw,\n                   labels = FALSE,\n                   xlab = \"z-Nonfunctional Water Points\",\n                   ylab = \"Spatially Lag z-Nonfunctional Water Points\")\n\n\n\n\n\nWe can see that there are many observations in the high-high and low-high regions. We also have some observations in the high-low region. Let’s use the choropleth map to see more!\n\n\nPlotting LISA map\nBefore drawing the map, we need to prepare the data so that the observations are grouped into the four classes (quadrants) as displayed in the scatterplots.\n\n\nShow code\nquadrant <- vector(mode = \"numeric\", length = nrow(localMI))\nnga_wp$lag_wptnon <- lag.listw(wp_rsw, nga_wp$`wpt non-functional`)\nDV <- nga_wp$lag_wptnon - mean(nga_wp$lag_wptnon)\nLM_I <- localMI[,1] - mean(localMI[,1])\nsignif <- 0.5\nquadrant[DV <0 & LM_I>0] <- 1\nquadrant[DV >0 & LM_I<0] <- 2\nquadrant[DV <0 & LM_I<0] <- 3  \nquadrant[DV >0 & LM_I>0] <- 4\nquadrant[localMI[,5]>signif] <- 0\n\n\nBelow is the LISA map in comparison with the aggregate map of non-functional water point count. For the aggregate map, we will display wp_jenks, which is based on Jenks classification.\n\n\nShow code\nnga_wp.LMI$quadrant <- quadrant\ncolors <- c(\"#ffffff\", \"#2c7bb6\", \"#abd9e9\", \"#fdae61\", \"#d7191c\")\nclusters <- c(\"insignificant\", \"low-low\", \"low-high\", \"high-low\", \"high-high\")\n\nLISAmap <- tm_shape(nga_wp.LMI) +\n  tm_fill(col = \"quadrant\", \n          style = \"cat\", \n          palette = colors[c(sort(unique(quadrant)))+1], \n          labels = clusters[c(sort(unique(quadrant)))+1],\n          popup.vars = c(\"\")) +\n  tm_view(set.zoom.limits = c(11,17)) +\n  tm_borders(alpha=0.5) +\n  tm_layout(main.title = \"LISA Map\",\n            main.title.size = 1,\n            main.title.position = \"center\",\n            legend.height = 0.25,\n            legend.width = 0.3)\n\nwp_jenks1 <- wp_jenks + tm_layout(main.title = \"Aggregated Map (Jenks)\",\n                                  main.title.size = 1,\n                                  frame = TRUE)\n\ntmap_arrange(wp_jenks1, LISAmap, \n             asp=1, ncol=2)\n\n\n\n\n\nThe LISA map highlight the areas where spatial autocorrelation is statistically significant. The red polygons depict clusters of government areas that have a high number of non-functional water points. They are surrounded by clusters of low number of non-functional water points. The blue polygons are clusters of areas with low number of non-functional water points. Except for the east regions, those areas are surrounded by clusters of areas with more non-functional water points, which are shown in orange.\nBy comparing the LISA map with the aggregated map, we can see that the LISA map highlights the pattern of non-functional water points distribution better, especially when we want to compare how area clusters are different from their neighbors.\nInterestingly enough, the low-low areas in the north east overlap with the states that have lower population density. The small orange dot in the east is Maiduguri, the largest city in north-eastern Nigeria. In contrast, Lagos, the largest city of Nigeria lying on the south western coast, belongs to the low-low category. This Lagos pattern repeats in the northern city of Kano, Nigeria’s second largest city."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#hot-spot-and-cold-spot-analysis",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#hot-spot-and-cold-spot-analysis",
    "title": "Take-home Exercise 1: How Functional are the Water Points in Nigeria?",
    "section": "Hot Spot and Cold Spot Analysis",
    "text": "Hot Spot and Cold Spot Analysis\nAn alternative to detect spatial anomalies besides Moran’s I LISA is Getis and Ord’s G-statistics. This method is distance-based as it looks into areas within a predefined proximity and identifies if high/low values cluster spatially. Statistically areas of high values are considered hot spots, while areas with low values are considered cold spots.\n\nComputing Gi statistics\nBefore we can map the hot-and-cold-spot map, let’s calculate the Gi statistics using the adaptive distance weight method. The functions used are localG() from spdep. localG() calculates the spatial statistic G, returning a Z-value vector. The higher the Z-value, the higher the clustering intensity. Positive and negative Z-score means high an low clusters, respectively.\nAfter the Z-value vector is calculated, we convert it into an r matrix, then use cbind() to append it to nga_wp. We also rename as.matrix.gi.adaptive. to gstat_adaptive for easier reference.\n\n\nShow code\nfips <- order(nga_wp$shapeName)\ngi.adaptive <- localG(nga_wp$`wpt non-functional`, wp_rsw)\nwp_gi <- cbind(nga_wp, as.matrix(gi.adaptive)) %>% \n  rename(gstat_adaptive = as.matrix.gi.adaptive.)\n\n\n\n\nMapping Gi values\n\n\nShow code\nGimap <- tm_shape(wp_gi) + \n  tm_fill(col = \"gstat_adaptive\", \n          style = \"pretty\", \n          palette=\"-RdBu\", \n          title = \"local Gi\") + \n  tm_borders(alpha = 0.5) +\n  tm_layout(main.title = \"Gi Map\",\n            main.title.size = 1,\n            main.title.position = \"center\",\n            legend.height = 0.25,\n            legend.width = 0.3)\n\ntmap_arrange(wp_jenks1, Gimap, asp = 1, ncol = 2)\n\n\n\n\n\nWith GI map, we can see the intensity of the cluster values. The Gi map have some hot spots that overlap with the areas containing high number of non-functional water points on the aggregate map. What is interesting is that Gi map shows the “temperature” of those areas in relations with their neighbors."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#comparing-lisa-and-gi-maps",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#comparing-lisa-and-gi-maps",
    "title": "Take-home Exercise 1: How Functional are the Water Points in Nigeria?",
    "section": "Comparing LISA and Gi Maps",
    "text": "Comparing LISA and Gi Maps\n\n\nShow code\ntmap_arrange(LISAmap, Gimap, asp = 1, ncol = 2)\n\n\n\n\n\nThere are some difference in how each method define clusters of similarly high number of non-functional water points by area. However, there are also overlaps between the two maps. LISA map is more effective when we want to display the contrast between the clusters and how they allocate, while Gi map can be used to depict the intensity of the cluster and values."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#conclusion-and-improvement",
    "href": "Take-home_Ex/Take-home_Ex1/Take-home_Ex1.html#conclusion-and-improvement",
    "title": "Take-home Exercise 1: How Functional are the Water Points in Nigeria?",
    "section": "Conclusion and Improvement",
    "text": "Conclusion and Improvement\nBased on the LISA and Gi map, there is a consistent pattern of areas with high values of non-functional water points. Those areas with high number of water point malfunctions often cluster together, suggesting the effect of unknown factors affecting the quality of water points.\nThe blue areas regions lead to two hypothesis:\n\nThe blue areas in the south overlap with the Niger Delta. Do the presence of rivers and subsequent infrastructures affect the quality and maintenance of water points?\nThe blue areas in the north east overlap with the states that have low population density. Could it be that low population density leading to less water points installation or less usage, which leading to them malfunction less?\n\nMore data can be collected to determine the correlation of other variable with non-functional water points. There are many potential to continue on identifying the factors that affect water point functionality. Who knows, maybe we will find some solutions to improve Nigerians’ access to fresh water 💧"
  }
]